{
  "common": {
    "close": "閉じる",
    "cancel": "キャンセル",
    "save": "変更を保存",
    "add": "追加",
    "delete": "削除",
    "install": "インストール",
    "update": "今すぐ更新",
    "refresh": "更新",
    "reload": "再読み込み",
    "choose": "フォルダを選択",
    "swap": "サイドを入れ替え",
    "next": "次へ",
    "back": "戻る",
    "send": "送信",
    "sending": "送信中..."
  },
  "message": {
    "commitMessageWarning": "コミットメッセージを入力してください！",
    "noFilesWarning": "ファイルが選択されていません！",
    "configSaved": "設定が保存されました！",
    "configError": "設定の保存に失敗しました",
    "noResults": "まだ分析結果はありません。",
    "loading": "読み込み中...",
    "noIssues": "問題は見つかりませんでした",
    "selectIssue": "詳細を表示する問題を選択してください",
    "errorLoading": "差分ファイルの読み込みエラー：",
    "noFilesChanged": "最後のコミット以降、ファイルは変更または追加されていません。",
    "rowSelected": "{{0}} の {{1}} 行が選択されました。",
    "leastOneJavaFile": "Javaファイルを少なくとも1つ選択してください",
    "fileSaved": "ファイルが正常に保存されました。",
    "errorSavingFile": "ファイルの保存中にエラーが発生しました。"
  },
  "title": {
    "settings": "設定",
    "about": "このアプリについて",
    "checkForUpdate": "アップデートを確認",
    "checkForUpdate1": "新しいアップデートがあります！ ({{0}})",
    "contact": "お問い合わせ",
    "updateSvn": "SVN (現在のリビジョン: {{0}})",
    "updateSvn1": "新しい SVN リビジョンがあります！ ({{0}}) - (現在: {{1}})",
    "cleanSvn": "SVN をクリーンアップ",
    "showLogsSvn": "SVN ログを表示",
    "supportFeedback": "サポートとフィードバック"
  },
  "action": {
    "refresh": "更新",
    "refreshDiff": "差分を更新",
    "generate": "コミットメッセージを生成",
    "check": "コーディングルールを確認",
    "commit": "コードをコミット"
  },
  "label": {
    "changesMade": "変更内容",
    "commitMessage": "コミットメッセージ",
    "line": "行",
    "column": "列",
    "spaces": "スペース：",
    "encoding": "UTF-8"
  },
  "table": {
    "status": "ステータス",
    "filePath": "ファイルパス",
    "extension": "拡張子",
    "severity": "重要度",
    "issue": "問題",
    "line": "行",
    "type": "タイプ",
    "message": "メッセージ",
    "category": "カテゴリ",
    "priority": "優先度",
    "rank": "ランク",
    "location": "場所",
    "file": "ファイル",
    "class": "クラス",
    "method": "メソッド"
  },
  "placeholder": {
    "commitMessage": "コミットメッセージを入力してください...",
    "search": "検索",
    "selectLanguage": "言語を選択...",
    "noLanguage": "言語が見つかりません。"
  },
  "toast": {
    "success": "成功",
    "error": "エラー",
    "info": "情報",
    "warning": "警告",
    "commitSuccess": "コミットが成功しました",
    "commitError": "コミット中にエラーが発生しました",
    "checkSuccess": "コーディングルールの確認が成功しました",
    "checkError": "コーディングルールの確認中にエラーが発生しました",
    "generateSuccess": "コミットメッセージの生成が成功しました",
    "generateError": "コミットメッセージの生成中にエラーが発生しました",
    "updateAvailable": "新しいアップデートが利用可能です！",
    "isLatestVersion": "すべて最新の状態です。",
    "checkUpdates": "アップデートを確認",
    "updatingMessage": "SVNを更新中...",
    "updateSuccess": "SVNの更新が成功しました",
    "updateError": "SVNの更新中にエラーが発生しました",
    "spotbugsError": "SpotBugsの実行中にエラーが発生しました： {{0}}",
    "spotbugsSuccess": "SpotBugs分析が完了しました：{{0}}件の問題が見つかりました",
    "refreshingSpotbugs": "SpotBugs分析を更新中..."
  },
  "svn": {
    "status": {
      "added": "追加済み",
      "modified": "変更済み",
      "deleted": "削除済み",
      "replaced": "置換済み",
      "conflicted": "コンフリクト",
      "external": "外部",
      "ignored": "無視された",
      "unversioned": "バージョン管理外",
      "missing": "欠落",
      "typeChanged": "タイプ変更"
    }
  },
  "settings": {
    "fontSize": {
      "title": "文字サイズ",
      "small": "小",
      "medium": "中",
      "large": "大"
    },
    "theme": "テーマ",
    "language": "言語",
    "buttonVariant": "ボタンのバリアント",
    "fontFamily": "フォントファミリー",
    "description": "設定はローカルストレージに保存されます。アプリケーションのフォントサイズ、テーマ、言語を変更できます。",
    "tab": {
      "appearance": "外観",
      "configuration": "設定",
      "mailserver": "メールサーバー",
      "onedrive": "OneDrive"
    },
    "configuration": {
      "description": "プロジェクト設定を構成します。",
      "openaiApiKey": "OpenAI APIキー",
      "openaiApiKeyPlaceholder": "OpenAI APIキーを入力してください",
      "svnFolder": "SVNフォルダ",
      "svnFolderPlaceholder": "SVNフォルダを選択",
      "chooseFolder": "フォルダを選択",
      "sourceFolder": "ソースフォルダ",
      "sourceFolderPlaceholder": "ソースフォルダを選択",
      "emailPL": "メールPL",
      "emailPlaceholder": "メールアドレスを入力",
      "webhookMS": "Webhook MS",
      "selectWebhook": "Webhookを選択",
      "addNewWebhook": "新しいWebhookを追加"
    },
    "mailserver": {
      "description": "メールサーバー設定を構成します。",
      "smtpServer": "SMTPサーバー",
      "smtpServerPlaceholder": "SMTPサーバーを入力してください",
      "port": "ポート",
      "portPlaceholder": "SMTPポートを入力してください",
      "email": "メール",
      "emailPlaceholder": "メールアドレスを入力してください",
      "password": "パスワード",
      "passwordPlaceholder": "パスワードを入力してください"
    },
    "onedrive": {
      "description": "画像アップロード用のMicrosoft OneDriveを構成します。",
      "clientId": "クライアントID",
      "clientIdPlaceholder": "Microsoft アプリのクライアントIDを入力してください",
      "tenantId": "テナントID",
      "tenantIdPlaceholder": "Microsoft テナントIDを入力してください",
      "clientSecret": "クライアントシークレット",
      "clientSecretPlaceholder": "Microsoft アプリのクライアントシークレットを入力してください",
      "refreshToken": "リフレッシュトークン（オプション）",
      "refreshTokenPlaceholder": "リフレッシュトークンを入力してください（利用可能な場合）",
      "instructions": "画像アップロード用にOneDriveを使用するには、Azure Portalでアプリケーションを登録し、適切な権限を付与する必要があります。",
      "step1": "アクセス先",
      "azurePortal": "Azure Portal",
      "step2": "新しいアプリケーションを登録",
      "step3": "Microsoft Graph用のAPI権限を追加（Files.ReadWrite、Files.ReadWrite.All）",
      "step4": "クライアントシークレットを作成",
      "step5": "クライアントID、テナントID、クライアントシークレットをここに入力"
    }
  },
  "dialog": {
    "aboutDialog": {
      "title": "SVN Tool",
      "description": "このアプリケーションは、SVNの差分から意味のあるコミットメッセージを生成し、コーディング規約をチェックするために開発されました。",
      "developer": "開発者",
      "version": "バージョン",
      "email": "メール",
      "github": "GitHub",
      "close": "閉じる"
    },
    "codingRules": {
      "title": "コーディングルール分析",
      "refresh": "更新",
      "noResults": "分析結果はまだありません。"
    },
    "cleanSvn": {
      "title": "SVNクリーンアップオプション",
      "description": "作業コピーに対してクリーンアップオプションを選択してください：",
      "options": {
        "externals": {
          "label": "外部をクリーンアップ",
          "description": "外部もクリーンアップします"
        },
        "unversioned": {
          "label": "バージョン管理外のファイルとディレクトリを削除",
          "description": "作業コピーからすべてのバージョン管理外のファイルとディレクトリを削除します"
        },
        "ignored": {
          "label": "無視されたファイルとディレクトリを削除",
          "description": "作業コピーからすべての無視されたファイルとディレクトリを削除します"
        },
        "unused": {
          "label": "未使用のpristineコピーを削除",
          "description": "作業コピーで参照されていないすべてのpristineコピーを削除します"
        },
        "metadata": {
          "label": "作業コピーのステータスを更新",
          "description": "作業コピーのステータスをリフレッシュします"
        },
        "locks": {
          "label": "ロックを解除",
          "description": "作業コピー内のロックを解除・奪取します"
        },
        "fixTimestamps": {
          "label": "タイムスタンプを修正",
          "description": "作業コピー内のファイルのタイムスタンプを修正します"
        }
      },
      "clean": "クリーンアップ",
      "cleanSuccess": "SVNクリーンアップが正常に完了しました",
      "cleanError": "クリーンアップ中にエラーが発生しました"
    },
    "statisticSvn": {
      "title": "統計",
      "selectPeriodPlaceholder": "期間を選択",
      "period": {
        "day": "日",
        "week": "週",
        "month": "月",
        "year": "年",
        "all": "すべて"
      },
      "tabs": {
        "commitByDate": "日付別コミット",
        "commitByAuthor": "作成者別コミット",
        "authorship": "作成者比率",
        "summary": "概要テーブル"
      },
      "commitByDate": {
        "cardTitle": "期間別コミット",
        "cardDescription": "日付別コミット数のグラフ",
        "selectChartType": "グラフの種類を選択",
        "chartTypes": {
          "barMultiple": "棒グラフ - 複数",
          "barHorizontal": "棒グラフ - 横",
          "barStacked": "棒グラフ - 積み上げ",
          "lineMultiple": "折れ線グラフ - 複数",
          "areaMultiple": "面グラフ - 複数"
        }
      },
      "commitByAuthor": {
        "cardTitle": "作成者別コミット",
        "cardDescription": "作成者別コミット数のグラフ",
        "chartTypes": {
          "barVertical": "棒グラフ - 縦",
          "barHorizontal": "棒グラフ - 横"
        }
      },
      "authorship": {
        "title": "作成者貢献率",
        "cardTitle": "作成者別コミット",
        "cardDescription": "作成者貢献率"
      },
      "summary": {
        "title": "概要テーブル",
        "author": "作成者",
        "commitCount": "コミット数",
        "percentage": "割合",
        "total": "合計"
      },
      "cardFooter": "選択した期間のコミットデータ",
      "noData": "データがありません",
      "errorLoading": "統計データの読み込みエラー"
    },
    "spotbugs": {
      "title": "SpotBugs分析",
      "filesAnalyzed": "分析されたファイル",
      "totalIssues": "問題の総数",
      "high": "高",
      "medium": "中",
      "low": "低",
      "allIssues": "すべての問題",
      "issues": "問題",
      "issueDetails": "問題の詳細",
      "bugDetails": "バグの詳細",
      "location": "場所",
      "methodLocation": "メソッドの場所",
      "lines": "行：",
      "localVariables": "ローカル変数",
      "properties": "プロパティ",
      "name": "名前：",
      "value": "値：",
      "notAvailable": "該当なし",
      "static": "静的",
      "primary": "プライマリ",
      "fileList": "ファイルリスト",
      "chart": "チャート"
    },
    "diffViewer": {
      "language": {
        "select": "言語を選択...",
        "notFound": "言語が見つかりません。"
      }
    },
    "showLogs": {
      "title": "SVNログ",
      "titleWithPath": "SVNログ: {{0}}",
      "commitMessage": "コミットメッセージ",
      "changedFiles": "変更されたファイル",
      "revision": "リビジョン",
      "date": "日付",
      "author": "更新者",
      "action": "アクション",
      "message": "メッセージ",
      "path": "パス",
      "placeholderSearch": "リビジョン、更新者、メッセージを検索...",
      "totalEntries": "{{0}}件のエントリ",
      "page": "ページ{{0}} / {{1}}"
    },
    "supportFeedback": {
      "title": "サポートとフィードバック",
      "description": "サポートリクエストを送信するか、フィードバックを提供してください。",
      "typeLabel": "タイプ",
      "typePlaceholder": "タイプを選択",
      "typeSupport": "サポートリクエスト",
      "typeFeedback": "フィードバック",
      "emailLabel": "メールアドレス",
      "emailPlaceholder": "メールアドレスを入力してください",
      "messageLabel": "メッセージ",
      "messagePlaceholder": "メッセージを入力してください",
      "validationWarning": "メールアドレスを入力してください。",
      "sendSuccess": "メッセージが正常に送信されました！",
      "sendError": "メッセージの送信に失敗しました。後でもう一度試すか、Webhookの設定を確認してください。",
      "basicInfoTitle": "基本情報",
      "messageTitle": "メッセージ",
      "imagesTitle": "画像を添付",
      "dragImages": "ここに画像をドラッグ＆ドロップするか、クリックしてファイルを選択してください",
      "dropHere": "ここに画像をドロップしてください...",
      "imageLimit": "最大5枚の画像、各5MBまで",
      "tooManyImages": "最大5枚の画像しかアップロードできません",
      "onlyImages": "画像ファイルのみ許可されています"
    },
    "updateSvn": {
      "title": "最近の変更情報",
      "author": "更新者: ",
      "revision": "バージョン: ",
      "curRevision": "現在: ",
      "date": "日付: ",
      "changedFiles": "変更されたファイル",
      "action": "アクション",
      "path": "パス",
      "commitMessage": "コミットメッセージ"
    },
    "newWebhook_ja": {
      "title": "新しいWebhookを追加",
      "description": "追加したいWebhookの名前とURLを入力してください。",
      "msgRequiredName": "Webhook名は必須です。",
      "msgRequiredUrl": "WebhookのURLは必須です。",
      "placeholderName": "Webhook名を入力",
      "placeholderUrl": "WebhookのURLを入力"
    }
  },
  "spotbugs": {
    "categoryDescriptions": {
      "badPractice": "推奨および必須のコーディング慣行の違反。例としては、hash code と equals の問題、cloneable の使い方、例外の無視、Serializable の問題、finalize の誤用などが含まれます。この分析の正確性を追求していますが、一部のグループはこれらの悪い慣行に関心がないかもしれません。",
      "correctness": "潜在的なバグ - 明らかなコーディングミスであり、開発者の意図とは異なる可能性が高いコードになります。誤検出率を低く抑えるよう努めています。",
      "experimental": "実験的かつ十分に検証されていないバグパターン",
      "i18N": "国際化およびロケールに関するコードの欠陥",
      "maliciousCode": "信頼できないコードからの攻撃に対して脆弱なコード",
      "mtCorrectness": "スレッド、ロック、volatile に関するコードの欠陥",
      "noise": "偽のランダムノイズ：データマイニング実験での制御として有用であり、ソフトウェアの実際のバグの検出には使用されません",
      "performance": "必ずしも誤りではないが、非効率な可能性のあるコード",
      "security": "信頼できない入力を使用して、リモートから悪用可能なセキュリティ脆弱性を生じる可能性のあるコード",
      "style": "混乱を招く、不自然な、またはエラーを引き起こしやすい方法で書かれたコード。例としては、使用されないローカル変数、switch 文での fall through、未確認のキャスト、null であることが既知の値に対する冗長な null チェックなどがあります。より多くの誤検出を許容します。SpotBugs の以前のバージョンでは、このカテゴリは「Style」と呼ばれていました。"
    },
    "bugDescriptions": {
      "jua_dont_assert_instanceof_in_tests": "JUA: テストで instanceof の値をアサートするのは推奨されません。\n誤ったクラスのインスタンスが使用された原因を示すには、instanceof のアサートよりもクラスキャスト例外のメッセージの方が有効な場合があります。\n\nキャストの失敗によるテストのデバッグ時には、ClassCastException の出力から実際に遭遇した型の情報を得られる方が有用です。キャスト前に型をアサートすると、より意味のない「false is not true」といったメッセージしか得られません。\n\nJUnitとHamcrestを併用している場合は、Hamcrestの IsInstanceOf クラスを代わりに使用できます。",
      "aa_assertion_of_arguments": "AA: パブリックメソッドの引数を検証するためにアサーションが使用されています。\nアサーションは無効にできるため、パブリックメソッドの引数の検証に使用すべきではありません。\n\n詳細については、SEI CERTルール MET01-J「アサーションを引数の検証に使用しない」および CWE-617「到達可能なアサーション」を参照してください。",
      "ct_constructor_throw": "CT: コンストラクタで例外をスローすることには注意が必要です。\nコンストラクタで例外をスローするクラスはファイナライザ攻撃に対して脆弱です。\n\nファイナライザ攻撃は、クラスをfinalにする、空のfinalファイナライザを定義する、またはprivateコンストラクタをうまく活用することで防止できます。\n\n詳細については、SEI CERTルール OBJ-11 を参照してください。",
      "cnt_rough_constant_value": "CNT: 既知の定数の近似値が見つかりました。\nコードの明確さと精度を高めるため、定義済みのライブラリ定数を使用することを推奨します。\n\n詳細については、CWE-1106「記号定数の不十分な使用」を参照してください。",
      "np_boolean_return_null": "NP: Boolean型を返すメソッドが明示的にnullを返しています。\nBoolean.TRUE、Boolean.FALSEまたはnullを返すメソッドは事故の元です。このようなメソッドはboolean型の戻り値として扱われる可能性があり、コンパイラは自動的にBoolean値のアンボクシングを行います。nullが返された場合、NullPointerException が発生します。",
      "sw_swing_methods_invoked_in_swing_thread": "SW: 一部のSwingメソッドはSwingスレッドで呼び出す必要があります。\n（JDC Tech Tipより）show()、setVisible()、および pack() メソッドはフレームに対応するピアを作成します。ピアの作成時にイベントディスパッチスレッドが生成されるため、packやvalidateの処理中にリスナーへの通知が発生する可能性があります。このような状況では、2つのスレッドがSwingコンポーネントベースのGUIを通ることになり、デッドロックや他のスレッド関連の問題につながる重大な欠陥となり得ます。pack呼び出しはコンポーネントを実現させ、その際にリスナー通知がイベントディスパッチスレッド上で発生することがあります。",
      "fi_finalizer_only_nulls_fields": "FI: ファイナライザがフィールドをnullにするだけです。\nこのファイナライザはフィールドをnullにする以外のことを何もしません。これは完全に無意味であり、オブジェクトがガベージコレクションされ、ファイナライズされ、再びガベージコレクションされる必要があります。finalize メソッドは削除すべきです。",
      "fi_finalizer_nulls_fields": "FI: ファイナライザがフィールドをnullにしています。\nこのファイナライザは通常、誤りです。ガベージコレクションの助けにはならず、どうせオブジェクトは回収されるからです。",
      "ui_inheritance_unsafe_getresource": "UI: getResource の使用は、クラスが継承された場合に安全でない可能性があります。\nthis.getClass().getResource(...) を呼び出すと、このクラスが他のパッケージのクラスから継承された場合に予期しない結果を返す可能性があります。",
      "am_creates_empty_zip_file_entry": "AM: 空のZipファイルエントリを作成しています\nこのコードは putNextEntry() を呼び出し、すぐに closeEntry() を呼び出しています。これにより空のZipFileエントリが生成されます。エントリの内容は putNextEntry() と closeEntry() の間に書き込むべきです。",
      "am_creates_empty_jar_file_entry": "AM: 空のJarファイルエントリを作成しています\nこのコードは putNextEntry() を呼び出し、すぐに closeEntry() を呼び出しています。これにより空のJarFileエントリが生成されます。エントリの内容は putNextEntry() と closeEntry() の間に書き込むべきです。",
      "imse_dont_catch_imse": "IMSE: IllegalMonitorStateException の不適切な捕捉\nIllegalMonitorStateException は、通常コード内の設計上の欠陥（ロックを保持していないオブジェクトに対して wait や notify を呼び出すなど）の場合にのみスローされます。",
      "cn_implements_clone_but_not_cloneable": "CN: クラスが clone() を定義しているが Cloneable を実装していない\nこのクラスは clone() メソッドを定義していますが、Cloneable インターフェースを実装していません。これが意図的である場合（例えば、サブクラスのクローン方法を制御したい場合など）もありますが、それが意図通りであることを確認してください。",
      "cn_idiom": "CN: クラスが Cloneable を実装しているが clone メソッドを定義または使用していない\nこのクラスは Cloneable を実装していますが、clone メソッドを定義または使用していません。",
      "cn_idiom_no_super_call": "CN: clone メソッドが super.clone() を呼び出していない\nこのfinalでないクラスは clone() メソッドを定義していますが、super.clone() を呼び出していません。もしこのクラス（'A'）がサブクラス（'B'）によって継承され、Bが super.clone() を呼び出すと、Bの clone() メソッドは型Aのオブジェクトを返す可能性があり、これは clone() の標準契約に違反します。\n\nすべての clone() メソッドが super.clone() を呼び出していれば、正しい型のオブジェクトを返す Object.clone() が常に使用されることが保証されます。\n\n詳細は CWE-580「super.clone() を呼び出さない clone() メソッド」を参照してください。",
      "de_might_drop": "DE: メソッドが例外を無視する可能性があります\nこのメソッドは例外を無視してしまう可能性があります。一般的に、例外は何らかの方法で処理または報告されるべきであり、さもなければメソッド外にスローされるべきです。\n\n詳細は CWE-754「異常または例外条件の不適切なチェック」を参照してください。",
      "de_might_ignore": "DE: メソッドが例外を無視する可能性があります\nこのメソッドは例外を無視してしまう可能性があります。一般的に、例外は何らかの方法で処理または報告されるべきであり、さもなければメソッド外にスローされるべきです。\n\n詳細は CWE-754「異常または例外条件の不適切なチェック」を参照してください。",
      "dm_exit": "Dm: System.exit(...) を呼び出しています\nSystem.exit を呼び出すと、Java仮想マシン全体がシャットダウンされます。これは適切な場面でのみ行うべきです。このような呼び出しは、他のコードからこのコードを呼び出すことを困難または不可能にします。代わりに RuntimeException をスローすることを検討してください。\n\n詳細は CWE-382「J2EEの悪習: System.exit() の使用」を参照してください。",
      "nm_future_keyword_used_as_identifier": "Nm: 将来のJavaバージョンで予約語となる識別子を使用しています\nこの識別子は将来のJavaバージョンで予約語として扱われるため、将来のバージョンでコンパイルするにはコードを修正する必要があります。",
      "nm_future_keyword_used_as_member_identifier": "Nm: 将来のJavaバージョンで予約語となる識別子を使用しています\nこの識別子は将来のJavaバージョンで予約語として扱われるため、このコードおよびこのAPIを参照するコードは、将来のJavaバージョンでコンパイル可能にするために修正が必要です。",
      "jcip_field_isnt_final_in_immutable_class": "JCIP: 不変クラスのフィールドは final にすべきです\nこのクラスは net.jcip.annotations.Immutable または javax.annotation.concurrent.Immutable で注釈付けされていますが、それらの注釈のルールでは、すべてのフィールドが final である必要があります。\n\n詳細は CWE-471「不変と仮定されたデータの変更（MAID）」を参照してください。",
      "dm_run_finalizers_on_exit": "Dm: 危険なメソッド runFinalizersOnExit を呼び出すメソッドSystem.runFinalizersOnExit または Runtime.runFinalizersOnExit をどんな理由でも呼び出してはなりません。これらは Java ライブラリの中で最も危険なメソッドの一つです。-- Joshua Bloch",
      "np_equals_should_handle_null_argument": "NP: equals() メソッドが null 引数をチェックしていないequals(Object) のこの実装は java.lang.Object.equals() によって定義された契約に違反しています。なぜなら、null が引数として渡された場合のチェックを行っていないためです。すべての equals() メソッドは、null 値が渡された場合は false を返すべきです。",
      "fi_empty": "FI: 空のファイナライザは削除すべき空の finalize() メソッドは無意味であるため、削除すべきです。参照: CWE-568: super.finalize() を呼び出さない finalize() メソッド",
      "fi_nullify_super": "FI: ファイナライザがスーパークラスのファイナライザを無効にしているこの空の finalize() メソッドは、スーパークラスで定義されたファイナライザの効果を明示的に否定しています。スーパークラスに定義されたファイナライザの動作は実行されません。意図しない場合は、このメソッドを削除してください。参照: CWE-568: super.finalize() を呼び出さない finalize() メソッド",
      "fi_useless": "FI: ファイナライザはスーパークラスのファイナライザを呼び出すだけこの finalize() メソッドは、スーパークラスの finalize() メソッドを呼び出すだけであり、冗長です。削除してください。",
      "fi_missing_super_call": "FI: ファイナライザがスーパークラスのファイナライザを呼び出していないこの finalize() メソッドは、スーパークラスの finalize() メソッドを呼び出していません。そのため、スーパークラスに定義されたファイナライザの動作が実行されません。super.finalize() を呼び出すようにしてください。参照: CWE-568: super.finalize() を呼び出さない finalize() メソッド",
      "fi_explicit_invocation": "FI: ファイナライザを明示的に呼び出しているこのメソッドは、オブジェクトに対して finalize() メソッドを明示的に呼び出しています。finalizer メソッドは 1 回だけ、かつ仮想マシンによって実行されるべきものであるため、これは悪い実装です。もし関連するオブジェクト群がファイナライズ可能である場合、仮想マシンはそれらすべての finalize メソッドを、異なるスレッドで同時に呼び出す可能性があります。そのため、クラス X の finalize メソッド内で X が参照しているオブジェクトに対して finalize を呼び出すのは特に悪い考えです。なぜなら、それらのオブジェクトがすでに別のスレッドでファイナライズ中かもしれないからです。参照: CWE-586: finalize() の明示的な呼び出し",
      "eq_check_for_operand_not_compatible_with_this": "Eq: 非互換なオペランドに対する equals チェックこの equals メソッドは、引数が互換性のない型（equals メソッドを定義しているクラスのスーパータイプでもサブタイプでもないクラス）であるかをチェックしています。例として、Foo クラスの equals メソッドが以下のようなコードを含んでいるとします：public boolean equals(Object o) { if (o instanceof Foo)  return name.equals(((Foo)o).name); else if (o instanceof String)  return name.equals(o); else return false;}このような実装は良くない実践であり、equals メソッドの対称性や推移性を保つのが非常に困難になります。これらの性質が欠如すると、予期しない挙動が発生する可能性があります。",
      "eq_getclass_and_class_constant": "Eq: サブタイプに対して equals メソッドが正しく動作しないこのクラスの equals メソッドは、サブクラスに継承された場合に正しく動作しません。クラスリテラルと引数のクラスを比較しており（例: Foo.class == o.getClass()）、これを this.getClass() == o.getClass() に置き換えるのが望ましいです。参照: CWE-486: クラス名による比較",
      "eq_self_no_object": "Eq: 共変 equals() メソッドが定義されているこのクラスは共変型の equals() メソッドを定義しています。java.lang.Object の equals() メソッドを正しくオーバーライドするには、equals() の引数は java.lang.Object 型でなければなりません。",
      "co_self_no_object": "Co: 共変の compareTo() メソッドが定義されているこのクラスは共変型の compareTo() メソッドを定義しています。Comparable インターフェースの compareTo() メソッドを正しくオーバーライドするには、引数の型は java.lang.Object でなければなりません。",
      "co_compareto_results_min_value": "Co: compareTo()/compare() が Integer.MIN_VALUE を返すこの compareTo または compare メソッドは、特定の状況で定数 Integer.MIN_VALUE を返します。これは極めて悪い実践です。compareTo の返り値で重要なのは符号だけですが、開発者はしばしば compareTo の返り値に否定を適用して符号を反転させようとします。しかし、返り値が Integer.MIN_VALUE の場合、否定しても符号は反転されません。代わりに単に -1 を返すようにしてください。",
      "co_compareto_incorrect_floating": "Co: compareTo()/compare() が float または double 値を正しく扱わないこのメソッドは、次のようなパターンで double や float の値を比較しています: val1 > val2 ? 1 : val1 < val2 ? -1 : 0。このパターンは、-0.0 や NaN に対して正しく機能しないため、誤ったソート結果やコレクションの破損を引き起こす可能性があります。Double.compare または Float.compare の静的メソッドを使用することを検討してください。これらはすべての特殊なケースを正しく処理します。",
      "rv_negating_result_of_compareto": "RV: compareTo()/compare() の結果を否定しているこのコードは compareTo または compare メソッドの返り値に対して否定演算を行っています。返り値が Integer.MIN_VALUE の場合、否定しても符号は反転しないため、これは疑問のある、あるいは悪いプログラミング実践です。目的とする結果を得るには、オペランドの順序を反転する方法のほうが安全です。",
      "es_comparing_strings_with_eq": "ES: String オブジェクトを == または != で比較しているこのコードは、java.lang.String オブジェクトを == または != 演算子で参照比較しています。両方の文字列がソースファイル内の定数か、String.intern() メソッドでインターンされたものでない限り、同じ値の文字列でも異なる String オブジェクトとして表現される可能性があります。equals(Object) メソッドを使用することを検討してください。参照: CWE-595: オブジェクト参照の比較ではなくオブジェクト内容の比較",
      "es_comparing_parameter_string_with_eq": "ES: String パラメータを == または != で比較しているこのコードは、java.lang.String 型のパラメータを == または != 演算子で参照比較しています。呼び出し元に対して、String 定数または intern された文字列のみを渡すように要求するのは不安定であり、実際には性能向上に繋がることは稀です。equals(Object) メソッドを使用することを検討してください。参照: CWE-595: オブジェクト参照の比較ではなくオブジェクト内容の比較",
      "eq_compareto_use_object_equals": "Eq: compareTo(…) を定義しながら Object.equals() を使用しているこのクラスは compareTo(...) メソッドを定義していますが、equals() メソッドは java.lang.Object から継承されたものを使用しています。一般的に、compareTo の返り値が 0 の場合に限り、equals が true を返すべきです。これが守られていないと、PriorityQueue のようなクラスで予期しないエラーが発生する可能性があります。Java 5 では PriorityQueue.remove メソッドは compareTo を使用し、Java 6 では equals を使用します。Comparable インターフェースの compareTo メソッドの JavaDoc より：(x.compareTo(y)==0) == (x.equals(y)) となることが強く推奨されますが、必須ではありません。この条件に違反するクラスは、それを明確に示すべきです。推奨される表現は「注: このクラスは equals と整合性のない自然順序付けを持ちます。」です。",
      "he_hashcode_use_object_equals": "HE: hashCode() を定義し、Object.equals() を使用しているクラスこのクラスは hashCode() メソッドを定義していますが、equals() メソッドは java.lang.Object から継承しています（これは参照による等価性を定義します）。この実装は「等しいオブジェクトは同じハッシュコードを持つべき」という契約にはおそらく適合しますが、hashCode() をオーバーライドしている意図とは異なる可能性があります（hashCode() をオーバーライドするということは、オブジェクトの識別が単なる参照等価性よりも複雑な基準に基づいていることを示唆します）。このクラスのインスタンスを HashMap や HashTable に挿入しないと考える場合、推奨される hashCode 実装は以下の通りです：public int hashCode() {  assert false : 'hashCode not designed';  return 42; // 任意の定数で構いません}CWE-581: オブジェクトモデル違反：equals と hashCode の一方のみが定義されている場合を参照してください。",
      "he_hashcode_no_equals": "HE: hashCode() を定義しているが equals() は定義していないクラスこのクラスは hashCode() メソッドを定義していますが、equals() メソッドは定義していません。これにより「等しいオブジェクトは同じハッシュコードを持つべき」という不変条件を破る可能性があります。CWE-581: オブジェクトモデル違反：equals と hashCode の一方のみが定義されている場合を参照してください。",
      "he_equals_use_hashcode": "HE: equals() を定義し、Object.hashCode() を使用しているクラスこのクラスは equals(Object) メソッドをオーバーライドしていますが、hashCode() はオーバーライドしておらず、java.lang.Object から継承された hashCode()（VM によって割り当てられる識別ハッシュコード）を使用しています。このため「等しいオブジェクトは同じハッシュコードを持つべき」という不変条件に違反する可能性が非常に高いです。このクラスのインスタンスを HashMap や HashTable に挿入しないと考える場合、推奨される hashCode 実装は以下の通りです：public int hashCode() {  assert false : 'hashCode not designed';  return 42; // 任意の定数で構いません}CWE-581: オブジェクトモデル違反：equals と hashCode の一方のみが定義されている場合を参照してください。",
      "he_inherits_equals_use_hashcode": "HE: equals() を継承し、Object.hashCode() を使用しているクラスこのクラスは抽象スーパークラスから equals(Object) を継承し、hashCode() は java.lang.Object から継承されたもの（VM により割り当てられた識別ハッシュコード）を使用しています。このため「等しいオブジェクトは同じハッシュコードを持つべき」という不変条件に違反する可能性が非常に高いです。hashCode メソッドを定義したくない、あるいはこのオブジェクトが HashMap や Hashtable に格納されることはないと考える場合、hashCode() メソッドを UnsupportedOperationException をスローするように定義してください。CWE-581: オブジェクトモデル違反：equals と hashCode の一方のみが定義されている場合を参照してください。",
      "he_equals_no_hashcode": "HE: equals() を定義しているが hashCode() は定義していないクラスこのクラスは equals(Object) をオーバーライドしていますが、hashCode() はオーバーライドしていません。そのため「等しいオブジェクトは同じハッシュコードを持つべき」という不変条件に違反する可能性があります。CWE-581: オブジェクトモデル違反：equals と hashCode の一方のみが定義されている場合を参照してください。",
      "eq_abstract_self": "Eq: 共変 equals() メソッドを定義する抽象クラスこのクラスは共変型の equals() メソッドを定義しています。java.lang.Object の equals() メソッドを正しくオーバーライドするには、equals() の引数の型は java.lang.Object でなければなりません。",
      "co_abstract_self": "Co: 共変 compareTo() メソッドを定義する抽象クラスこのクラスは共変型の compareTo() メソッドを定義しています。Comparable インターフェースの compareTo() メソッドを正しくオーバーライドするには、compareTo() の引数の型は java.lang.Object でなければなりません。",
      "ic_superclass_uses_subclass_during_initialization": "IC: 初期化中にスーパークラスがサブクラスを使用しているクラスの初期化中に、そのクラスがサブクラスを能動的に使用しています。この使用時点ではサブクラスはまだ初期化されていません。例えば、以下のコードでは foo は null になります。public class CircularClassInitialization {  static class InnerClassSingleton extends CircularClassInitialization {    static InnerClassSingleton singleton = new InnerClassSingleton();  }  static CircularClassInitialization foo = InnerClassSingleton.singleton;}CWE-457: 初期化されていない変数の使用を参照してください。",
      "si_instance_before_finals_assigned": "SI: static 初期化子がすべての static final フィールドが代入される前にインスタンスを生成しているこのクラスの static 初期化子は、すべての static final フィールドが代入される前にクラスのインスタンスを生成しています。",
      "it_no_such_element": "It: Iterator の next() メソッドが NoSuchElementException をスローできないこのクラスは java.util.Iterator インターフェースを実装していますが、next() メソッドが java.util.NoSuchElementException をスローできません。返す要素が存在しない状態で呼び出された場合に NoSuchElementException をスローするよう next() メソッドを変更すべきです。",
      "me_mutable_enum_field": "ME: Enum フィールドが public かつ変更可能変更可能な public フィールドが public enum 内に定義されており、他のパッケージから悪意あるコードや偶発的に変更される可能性があります。遅延初期化のために変更可能な enum フィールドを使用することもありますが、それを外部に公開するのは悪い設計です。このフィールドを final にするか、package-private にすることを検討してください。",
      "me_enum_field_setter": "ME: Public enum メソッドが無条件にそのフィールドを設定しているpublic enum 内で宣言されたこの public メソッドは enum フィールドを無条件に設定しており、他のパッケージから悪意あるコードや偶発的にこのフィールドを変更可能にしています。遅延初期化のために変更可能な enum フィールドを使用することもありますが、それを外部に公開するのは悪い設計です。このメソッドを削除するか、package-private にすることを検討してください。",
      "nm_method_naming_convention": "Nm: メソッド名は小文字で始めるべきメソッドは動詞であるべきであり、先頭は小文字、内部の各単語の最初の文字は大文字とする混合ケースで命名するべきです。",
      "nm_field_naming_convention": "Nm: 非 final フィールド名は小文字で始め、final フィールド名は大文字およびアンダースコアで単語を区切るべきfinal でないフィールドの名前は、先頭を小文字、続く単語の先頭を大文字にした混合ケースであるべきです。final フィールドの名前はすべて大文字で、単語の区切りにはアンダースコア（'_'）を使用するべきです。",
      "nm_same_simple_name_as_interface": "Nm: クラス名は実装インターフェースの単純名と同じにすべきではないこのクラスまたはインターフェースの単純名が、異なるパッケージに存在する実装/拡張されたインターフェースと同一です（例: alpha.Foo が beta.Foo を extends）。これは非常に混乱を招き、参照を解決するためにインポート文を確認しなければならない状況を多く生み、スーパークラスのメソッドをオーバーライドしていないメソッドを意図せずに定義してしまう可能性があります。",
      "nm_same_simple_name_as_superclass": "Nm: クラス名はスーパークラスの単純名と同じにすべきではないこのクラスの単純名が、そのスーパークラスと同一であり、スーパークラスが異なるパッケージに存在します（例: alpha.Foo が beta.Foo を extends）。これは非常に混乱を招き、参照を解決するためにインポート文を確認しなければならない状況を多く生み、スーパークラスのメソッドをオーバーライドしていないメソッドを意図せずに定義してしまう可能性があります。",
      "nm_class_naming_convention": "Nm: クラス名は大文字で始めるべきですクラス名は名詞であり、各単語の最初の文字を大文字にした混合ケースにするべきです。クラス名はシンプルで説明的にしてください。省略語や略語は避け、完全な単語を使用してください（ただし、URL や HTML のように略語の方が一般的な場合は例外です）。",
      "nm_very_confusing_intentional": "Nm: 非常に紛らわしいメソッド名（ただし意図的な可能性あり）参照されたメソッドは大文字・小文字の違いのみで名前が異なっています。これは非常に紛らわしく、もし大文字・小文字が一致していれば、一方のメソッドが他方をオーバーライドすることになります。他のメソッドの存在から、両方のメソッドを意図的に保持しているようですが、それでも混乱を招きます。API が固定されていて両方必要な場合を除き、いずれか一方を排除するよう強く推奨します。",
      "nm_wrong_package_intentional": "Nm: メソッドがパラメータのパッケージの違いによりスーパークラスのメソッドをオーバーライドしていないサブクラスのメソッドは、対応するパラメータの型がスーパークラスと完全に一致しないため、スーパークラスの類似メソッドをオーバーライドしていません。たとえば、次のような場合です：import alpha.Foo;public class A { public int f(Foo x) { return 17; } }----import beta.Foo;public class B extends A { public int f(Foo x) { return 42; } public int f(alpha.Foo x) { return 27; } }クラス B に定義された f(Foo) メソッドは、クラス A の f(Foo) メソッドをオーバーライドしていません。なぜなら、引数の型が異なるパッケージの Foo だからです。この場合、サブクラスはスーパークラスと同じシグネチャのメソッドを定義しているように見えますが、非常に紛らわしいため、同様だが異なるシグネチャのメソッドは削除または非推奨にすることを強く推奨します。",
      "nm_confusing": "Nm: 紛らわしいメソッド名参照されたメソッドは、大文字・小文字の違いのみで名前が異なっています。",
      "nm_class_not_exception": "Nm: 'Exception' と名付けられているが、例外を継承していないクラスこのクラスは他の例外クラスを継承していないにもかかわらず、名前が 'Exception' で終わっています。このため、このクラスを使用するユーザーにとって紛らわしいものになります。",
      "rr_not_checked": "RR: メソッドが InputStream.read() の戻り値を無視しているこのメソッドは java.io.InputStream.read() のいずれかのバリエーションの戻り値を無視しています。このメソッドは複数バイトを返す可能性があり、戻り値を確認しないと、要求したバイト数より少ないバイト数しか読み取れなかった場合に適切に処理できません。この種のバグは非常に見つけにくく、多くのプログラムでは通常は完全なデータが読み取れるため、失敗は散発的にしか起こりません。CWE-252: 戻り値の未確認を参照してください。",
      "sr_not_checked": "RR: メソッドが InputStream.skip() の戻り値を無視しているこのメソッドは java.io.InputStream.skip() の戻り値を無視しています。skip() は複数バイトをスキップできる可能性があり、戻り値を確認しないと、要求されたバイト数より少ないバイト数しかスキップできなかった場合に正しく処理できません。この種のバグは非常に見つけにくく、多くのプログラムでは通常、入力ストリームからのスキップは完全に成功しますが、Buffered ストリームの場合、skip() はバッファ内のデータしかスキップできず、要求バイト数のスキップに失敗することが一般的です。CWE-252: 戻り値の未確認を参照してください。",
      "se_no_suitable_constructor": "Se: クラスは Serializable を実装しているが、スーパークラスに引数なしコンストラクタが定義されていないこのクラスは Serializable インターフェースを実装していますが、スーパークラスは実装していません。このようなオブジェクトがデシリアライズされるとき、スーパークラスのフィールドは引数なしコンストラクタを呼び出して初期化される必要があります。スーパークラスにそのようなコンストラクタが存在しないため、シリアライズおよびデシリアライズは実行時に失敗します。",
      "se_no_suitable_constructor_for_externalization": "Se: クラスは Externalizable を実装しているが、引数なしコンストラクタが定義されていないこのクラスは Externalizable インターフェースを実装していますが、public の引数なしコンストラクタが定義されていません。Externalizable オブジェクトをデシリアライズするときは、まず public 引数なしコンストラクタでインスタンスを生成する必要があります。したがって、このクラスにはそのようなコンストラクタがないため、シリアライズおよびデシリアライズは実行時に失敗します。",
      "se_comparator_should_be_serializable": "Se: Comparator が Serializable を実装していないこのクラスは Comparator インターフェースを実装しています。Serializable インターフェースも実装すべきかどうか検討してください。Comparator が TreeMap のような順序付きコレクションの構築に使用される場合、Comparator も Serializable でなければ TreeMap 自体もシリアライズできません。ほとんどの Comparator は状態をほとんど持たないため、Serializable にするのは一般的に容易であり、安全なプログラミング手法とされています。CWE-1066: シリアライズ制御要素の欠落 を参照してください。",
      "se_no_serialversionid": "SnVI: クラスは Serializable を実装しているが、serialVersionUID が定義されていないこのクラスは Serializable インターフェースを実装していますが、serialVersionUID フィールドが定義されていません。単に .class オブジェクトへの参照を追加するだけでも、クラスに合成フィールドが追加され、暗黙の serialVersionUID が変更されてしまいます（例：String.class への参照を追加すると、class$java$lang$String という static フィールドが生成される）。また、異なるソースコード → バイトコード コンパイラでは、合成変数名の命名規則が異なる可能性があります。バージョン間の互換性を確保するため、serialVersionUID を明示的に定義することを検討してください。",
      "se_read_resolve_must_return_object": "Se: readResolve メソッドは Object を返すように宣言する必要があります。readResolve メソッドがシリアライズ機構に認識されるためには、戻り値の型が Object である必要があります。",
      "se_transient_field_not_restored": "Se: デシリアライズで設定されない transient フィールドこのクラスには、クラス内の複数箇所で更新されるフィールドが存在しており、それはクラスの状態の一部と思われます。しかし、そのフィールドは transient としてマークされ、readObject または readResolve メソッド内で設定されていないため、デシリアライズ後のインスタンスではデフォルト値となります。",
      "se_prevent_ext_obj_overwrite": "Se: Externalizable オブジェクトの上書きを防止するreadExternal() メソッドは public として宣言されており、悪意ある呼び出し元から保護されていません。そのため、任意の呼び出し元がオブジェクトの値を随時リセットできてしまいます。Externalizable オブジェクトの上書きを防止するには、インスタンスフィールドが設定された後にフラグを true にする Boolean フィールドを使用することができます。また、プライベートなロックオブジェクトで同期処理を行うことで、競合状態を防ぐことも可能です。",
      "se_nonfinal_serialversionid": "Se: serialVersionUID が final ではないこのクラスでは serialVersionUID フィールドが定義されていますが、final 修飾子が付いていません。シリアライズのバージョン UID としてこのフィールドを使用する意図がある場合は、final として宣言すべきです。",
      "se_nonstatic_serialversionid": "Se: serialVersionUID が static ではないこのクラスでは serialVersionUID フィールドが定義されていますが、static 修飾子が付いていません。シリアライズのバージョン UID としてこのフィールドを使用する意図がある場合は、static として宣言すべきです。",
      "se_nonlong_serialversionid": "Se: serialVersionUID が long 型ではありませんこのクラスは serialVersionUID フィールドを定義していますが、その型が long ではありません。シリアライズのバージョン UID を指定する目的で使用する場合は、long 型にする必要があります。",
      "se_bad_field": "Se: Serializable クラスにおいて、transient でも Serializable でもないインスタンスフィールドがありますこの Serializable クラスは、プリミティブ型ではないインスタンスフィールドを定義していますが、それが transient でもなく、Serializable または java.lang.Object を実装しておらず、Externalizable インターフェースや readObject()・writeObject() メソッドも実装していません。このフィールドに Serializable でないオブジェクトが格納されている場合、オブジェクトのデシリアライズは正しく行われません。",
      "se_inner_class": "Se: Serializable な内部クラスこの Serializable クラスは内部クラスです。このクラスをシリアライズしようとすると、関連する外部インスタンスもシリアライズされます。外部インスタンスも Serializable なので失敗はしませんが、意図しない多くのデータをシリアライズしてしまう可能性があります。可能であれば、内部クラスを static 内部クラス（ネストされたクラス）にすることでこの問題を解決できます。",
      "se_bad_field_inner_class": "Se: Serializable な内部クラスが、非 Serializable な外部クラス内にあるこの Serializable クラスは、非 Serializable クラスの内部クラスです。これをシリアライズしようとすると、関連する外部クラスのインスタンスもシリアライズしようとして、実行時エラーになります。可能であれば、内部クラスを static 内部クラスにすることでこの問題を解決できます。外部クラスを Serializable にすることも可能ですが、そうすると内部クラスのインスタンスをシリアライズするたびに外部クラスのインスタンスも常にシリアライズされることになり、通常は望ましくありません。",
      "se_bad_field_store": "Se: Serializable クラスのインスタンスフィールドに非 Serializable な値が格納されている非 Serializable な値が、transient でない Serializable クラスのフィールドに格納されています。",
      "rv_return_value_ignored_bad_practice": "RV: メソッドが例外的な戻り値を無視しているこのメソッドは戻り値を返しますが、それがチェックされていません。戻り値は、予期しない動作や異常な実行を示すことがあるため、確認すべきです。例えば、File.delete() メソッドはファイルの削除に失敗した場合、例外を投げる代わりに false を返します。戻り値を確認しないと、メソッド呼び出しが予期しない動作を示しても気付くことができません。CWE-253: 関数戻り値の誤ったチェック を参照してください。",
      "np_tostring_could_return_null": "NP: toString メソッドが null を返す可能性があるこの toString メソッドは、特定の条件下で null を返す可能性があります。仕様の広義的な解釈では許容されるかもしれませんが、これは好ましくない実装であり、他のコードに不具合を引き起こす可能性があります。null の代わりに空文字列や適切な文字列を返すべきです。",
      "np_clone_could_return_null": "NP: clone メソッドが null を返す可能性があるこの clone メソッドは、ある条件下で null を返すようです。しかし、clone メソッドが null を返すことは許されていません。もしそのパスが到達不能であると確信している場合は、代わりに AssertionError をスローしてください。",
      "os_open_stream": "OS: メソッドがストリームを閉じ忘れる可能性があるこのメソッドは IO ストリームオブジェクトを生成しますが、それをフィールドに代入したり、他のメソッドに渡したり、戻り値として返したりせず、すべての経路でストリームを閉じているようには見えません。これによりファイルディスクリプタリークが発生する可能性があります。ストリームを確実に閉じるために、finally ブロックを使用するのが一般的に推奨されます。CWE-459: 不完全なクリーンアップ を参照してください。",
      "os_open_stream_exception_path": "OS: メソッドが例外時にストリームを閉じるのに失敗する可能性があるこのメソッドは IO ストリームオブジェクトを作成しますが、それをフィールドに代入したり、他のメソッドに渡したり、戻り値として返したりせず、例外が発生した場合にすべての経路でストリームを閉じているようには見えません。これによりファイルディスクリプタリークが発生する可能性があります。ストリームを確実に閉じるために、finally ブロックを使用するのが一般的に推奨されます。CWE-459: 不完全なクリーンアップ を参照してください。",
      "rc_ref_comparison_bad_practice": "RC: 定数との参照比較に疑問があるこのメソッドは参照値を定数と比較する際に == または != 演算子を使用していますが、このタイプのインスタンスを比較する正しい方法は通常 equals() メソッドを使用することです。同一であっても異なるオブジェクトとして比較されるインスタンスを作成することが可能です。通常、参照で比較すべきではないクラスの例としては java.lang.Integer、java.lang.Float などがあります。CWE-595: オブジェクト参照の比較ではなく、オブジェクト内容の比較 を参照してください。",
      "rc_ref_comparison_bad_practice_boolean": "RC: Boolean 値の参照比較に疑問があるこのメソッドは二つの Boolean 値を == または != 演算子で比較しています。通常、Boolean 値は二つ（Boolean.TRUE と Boolean.FALSE）のみですが、new Boolean(b) コンストラクタを使用して他の Boolean オブジェクトを作成することが可能です。このようなオブジェクトは避けるべきですが、もし存在する場合、Boolean オブジェクトを == または != で比較すると、.equals(...) を使用した場合と異なる結果を得ることになります。CWE-595: オブジェクト参照の比較ではなく、オブジェクト内容の比較 を参照してください。",
      "va_format_string_uses_newline": "FS: フォーマット文字列は n の代わりに %n を使用すべきこのフォーマット文字列は改行文字（\n）を含んでいます。フォーマット文字列では、通常プラットフォーム固有の行区切り文字を生成する %n を使用する方が望ましいです。Java 15 で導入されたテキストブロックを使用する場合は、 エスケープシーケンスを使用します: String value = ''' first line%n second line%n ''';",
      "fs_bad_date_format_flag_combo": "FS: 日付フォーマット文字列は予期しない動作を引き起こす可能性があるこのフォーマット文字列には予期しない動作を引き起こす可能性がある不適切なフラグの組み合わせが含まれています。考えられる不適切な組み合わせには以下が含まれます：週番号（'Y'）を月（'M'）や日（'d'）と組み合わせ、週の番号（'w'）を指定せずに使用する。代わりにフラグ（'y'）を使用する方が適切な場合があります。AM/PM 時刻（'h' または 'K'）を使用し、AM/PM マーカー（'a'）や日付の期間マーカー（'B'）を指定しない。24 時間形式の時刻（'H' または 'k'）を使用し、AM/PM や期間マーカーを指定しない。1日のミリ秒（'A'）を時間（'H'、'h'、'K'、'k'）や分（'m'）や秒（'s'）と一緒に使用する。1日のミリ秒（'A'）と1日のナノ秒（'N'）を一緒に使用する。秒の分数（'S'）とナノ秒（'n'）を一緒に使用する。AM/PM マーカー（'a'）と日付の期間（'B'）を一緒に使用する。年（'y'）と時代の年（'u'）を一緒に使用する。",
      "bit_signed_check": "BIT: ビット演算の符号チェックこのメソッドは、((event.detail & SWT.SELECTED) > 0) のような式を比較しています。ビット演算を使用し、その後 > 演算子で比較すると、予期しない結果を引き起こす可能性があります（もちろん、SWT.SELECTED の値に依存します）。もし SWT.SELECTED が負の数であれば、これはバグの候補です。SWT.SELECTED が負でない場合でも、'> 0' の代わりに '!= 0' を使用する方が良いプラクティスです。",
      "odr_open_database_resource": "ODR: メソッドがデータベースリソースを閉じるのに失敗する可能性があるこのメソッドはデータベースリソース（データベース接続や行セットなど）を作成し、それをフィールドに代入したり、他のメソッドに渡したり、戻り値として返したりせず、すべての経路でオブジェクトを閉じるようには見えません。メソッドからのすべての経路でデータベースリソースを閉じないと、パフォーマンスが低下し、アプリケーションがデータベースとの通信に問題を引き起こす可能性があります。CWE-459: 不完全なクリーンアップ を参照してください。",
      "odr_open_database_resource_exception_path": "ODR: メソッドが例外時にデータベースリソースを閉じるのに失敗する可能性があるこのメソッドはデータベースリソース（データベース接続や行セットなど）を作成し、それをフィールドに代入したり、他のメソッドに渡したり、戻り値として返したりせず、すべての例外経路でオブジェクトを閉じるようには見えません。メソッドからのすべての経路でデータベースリソースを閉じないと、パフォーマンスが低下し、アプリケーションがデータベースとの通信に問題を引き起こす可能性があります。CWE-459: 不完全なクリーンアップ を参照してください。",
      "isc_instantiate_static_class": "ISC: 静的メソッドのみを提供するクラスの不必要なインスタンス化このクラスは、静的メソッドのみを提供するクラスに基づいたオブジェクトを割り当てています。このオブジェクトは作成する必要はなく、クラス名を修飾子として静的メソッドに直接アクセスするべきです。",
      "dmi_random_used_only_once": "DMI: ランダムオブジェクトが一度だけ作成されて使用されるこのコードは java.util.Random オブジェクトを作成し、それを使って一つのランダムな数値を生成し、その後 Random オブジェクトを破棄しています。これではランダムな数値の質が低く、効率的ではありません。可能であれば、Random オブジェクトを一度だけ作成して保存し、毎回新しいランダムな数値が必要なときは既存の Random オブジェクトのメソッドを呼び出して取得するようにコードを書き換えるべきです。もし生成されるランダムな数値が予測されないことが重要であれば、毎回新しい Random を作成してはいけません。値が予測可能すぎます。代わりに java.security.SecureRandom を使用することを強くお勧めします（そして、各ランダムな数値のために新しい SecureRandom を割り当てるのを避けてください）。",
      "bc_equals_method_should_work_for_all_objects": "BC: Equals メソッドは引数の型に関して何も仮定すべきではないequals(Object o) メソッドは o の型に関して何も仮定すべきではありません。o がこのオブジェクトと同じ型でない場合、単に false を返すべきです。",
      "j2_ee_store_of_non_serializable_object_into_session": "J2EE: 非シリアライズ可能なオブジェクトを HttpSession に格納このコードは非シリアライズ可能なオブジェクトを HttpSession に格納しているようです。このセッションがパッシベートされたり移行されたりすると、エラーが発生します。CWE-579: J2EE の不適切なプラクティス：セッションに格納された非シリアライズ可能なオブジェクト を参照してください。",
      "gc_unchecked_type_in_generic_call": "GC: ジェネリック呼び出しでの型チェックの未確認このジェネリックなコレクションメソッドの呼び出しは、コンパイル時型 Object の引数を渡していますが、ジェネリック型パラメータから期待される特定の型は渡されていません。したがって、標準的な Java 型システムや静的解析では、渡されるオブジェクトが適切な型かどうかについて有益な情報を提供できません。",
      "pz_dont_reuse_entry_objects_in_iterators": "PZ: イテレータでエントリオブジェクトを再利用しないentrySet() メソッドは、Iterator と Map.Entry を返す Map の基盤となるビューを返すことが許可されています。この巧妙なアイデアは複数の Map 実装で使用されましたが、厄介なコーディングミスの可能性を引き起こします。もし map m がそのようなイテレータを entrySet のために返す場合、c.addAll(m.entrySet()) はうまくいきません。OpenJDK 7 のすべての Map 実装はこれを避けるように書き直されました。あなたもそうするべきです。",
      "dmi_entry_sets_may_reuse_entry_objects": "DMI: エントリセットの要素追加が失敗する可能性がある、Entry オブジェクトの再利用によるentrySet() メソッドは、イテレーション中に単一の Entry オブジェクトが再利用されて返される基盤となる Map のビューを返すことが許可されています。Java 6 以降、IdentityHashMap と EnumMap はこの方法を採用しています。このような Map をイテレートする際、Entry の値は次のイテレーションに進むまで有効です。例えば、entrySet を addAll メソッドに渡すと、うまくいかなくなります。",
      "dmi_using_removeall_to_clear_collection": "DMI: コレクションをクリアするために removeAll を使用しないコレクション c からすべての要素を削除したい場合、c.removeAll(c) ではなく、c.clear を使用してください。c.removeAll(c) をコレクションをクリアするために呼び出すのは、明確ではなく、タイプミスによるエラーが発生しやすく、効率が悪く、いくつかのコレクションでは ConcurrentModificationException をスローする可能性があります。",
      "throws_method_throws_runtimeexception": "THROWS: メソッドが意図的に RuntimeException をスローするメソッドは意図的に RuntimeException をスローします。SEI CERT ERR07-J ルールによると、RuntimeException をスローすることは、呼び出し元が例外を調べられず、したがって適切に回復できないというエラーを引き起こす可能性があります。さらに、RuntimeException をスローすることは、呼び出し元が RuntimeException をキャッチしなければならなくなり、SEI CERT ERR08-J ルールに違反することになります。例外や RuntimeException を継承して、新しいインスタンスをスローすることができますので、その点に注意してください。CWE-397: 一般的な例外に対する throws 宣言 を参照してください。",
      "throws_method_throws_clause_basic_exception": "THROWS: メソッドが throws 節で Exception をリストしているが、より具体的にすることができるメソッドは throws 節で Exception をリストしています。メソッドを宣言する際、throws 節で指定する例外のタイプは最も具体的であるべきです。したがって、throws 節で Exception を使用することは、呼び出し元がそれを自身の throws 節で使用するか、try-catch ブロック内で使用することを強制します（しかし、それは必ずしもスローされた例外について有益な情報を含むわけではありません）。詳細については、SEI CERT ERR07-J ルールを参照してください。CWE-397: 一般的な例外に対する throws 宣言 を参照してください。",
      "throws_method_throws_clause_throwable": "THROWS: メソッドが throws 節で Throwable をリストしているが、より具体的にすることができるメソッドは throws 節で Throwable をリストしています。メソッドを宣言する際、throws 節で指定する例外のタイプは最も具体的であるべきです。したがって、throws 節で Throwable を使用することは、呼び出し元がそれを自身の throws 節で使用するか、try-catch ブロック内で使用することを強制します（しかし、それは必ずしもスローされた例外について有益な情報を含むわけではありません）。さらに、そのように Throwable を使用するのは意味的に悪いプラクティスであり、Throwable は Error を含むため、定義上回復不可能なシナリオで発生します。詳細については、SEI CERT ERR07-J ルールを参照してください。CWE-397: 一般的な例外に対する throws 宣言 を参照してください。",
      "pa_public_primitive_attribute": "PA: プリミティブ型フィールドがpublicであるSEI CERT ルール OBJ01-J では、フィールドへのアクセスは制限されるべきだと要求されています。そうでない場合、フィールドの値はクラス外部から操作される可能性があり、予期しないまたは望ましくない動作が発生する可能性があります。一般的に、フィールドがpublicであってはならないという要件は過剰で非現実的です。このルールでは、final フィールドは public であっても構わないと述べています。final フィールドを除いて、public フィールドには他の利用法もあります。例えば、いくつかの public フィールドは、クラスの動作に影響を与える「フラグ」として機能する場合があります。このようなフラグフィールドは、現在のインスタンス（または static フィールドの場合は現在のクラス）によって読み取られ、他のクラスから書き込まれることが期待されています。もしフィールドが現在のインスタンス（または static フィールドの場合は現在のクラス）のメソッドと外部の両方から書き込まれている場合、そのコードは疑わしいです。これらのフィールドを private にして、必要に応じて適切な setter を提供することを検討してください。コンストラクター、初期化子、およびファイナライザーは例外であり、クラス内部でのみフィールドを書き込む場合、そのフィールドはクラス自身によって書き込まれたとは見なされません。CWE-766: 公開された重要なデータ要素 を参照してください。",
      "pa_public_array_attribute": "PA: 配列型フィールドがpublicであるSEI CERT ルール OBJ01-J では、フィールドへのアクセスは制限されるべきだと要求されています。配列型フィールドをfinalにしても、他のクラスが配列の内容を変更するのを防ぐことはできません。しかし、一般的に、フィールドがpublicであってはならないという要件は過剰で非現実的です。public フィールドには他の利用法もあります。例えば、いくつかの public フィールドは、クラスの動作に影響を与える「フラグ」として機能する場合があります。このようなフラグフィールドは、現在のインスタンス（または static フィールドの場合は現在のクラス）によって読み取られ、他のクラスから書き込まれることが期待されています。もしフィールドが現在のインスタンス（または static フィールドの場合は現在のクラス）のメソッドと外部の両方から書き込まれている場合、そのコードは疑わしいです。これらのフィールドを private にして、必要に応じて適切な setter を提供することを検討してください。コンストラクター、初期化子、およびファイナライザーは例外であり、クラス内部でのみフィールドを書き込む場合、そのフィールドはクラス自身によって書き込まれたとは見なされません。CWE-766: 公開された重要なデータ要素 を参照してください。",
      "pa_public_mutable_object_attribute": "PA: ミュータブルオブジェクト型フィールドがpublicであるSEI CERT ルール OBJ01-J では、フィールドへのアクセスは制限されるべきだと要求されています。ミュータブルオブジェクト型フィールドをfinalにしても、他のクラスがオブジェクトの内容を変更するのを防ぐことはできません。しかし、一般的に、フィールドがpublicであってはならないという要件は過剰で非現実的です。public フィールドには他の利用法もあります。例えば、いくつかの public フィールドは、クラスの動作に影響を与える「フラグ」として機能する場合があります。このようなフラグフィールドは、現在のインスタンス（または static フィールドの場合は現在のクラス）によって読み取られ、他のクラスから書き込まれることが期待されています。もしフィールドが現在のインスタンス（または static フィールドの場合は現在のクラス）のメソッドと外部の両方から書き込まれている場合、そのコードは疑わしいです。これらのフィールドを private にして、必要に応じて適切な setter を提供することを検討してください。コンストラクター、初期化子、およびファイナライザーは例外であり、クラス内部でのみフィールドを書き込む場合、そのフィールドはクラス自身によって書き込まれたとは見なされません。オブジェクト型フィールドの場合、「書き込み」とは、変更を示唆する名前のメソッドを呼び出すことを意味します。CWE-766: 公開された重要なデータ要素 を参照してください。",
      "pi_do_not_reuse_public_identifiers_class_names": "PI: JSLの公開識別子をクラス名として再利用しないJava標準ライブラリの公開識別子をクラス名として再利用しないことは良いプラクティスです。これは、Java標準ライブラリがJavaプラットフォームの一部であり、すべてのJava環境で利用可能であることが期待されているためです。このような再利用は、名前の競合や混乱を引き起こし、コードの理解や保守を難しくする可能性があります。最良のプラクティスは、独自で説明的なクラス名を選ぶことです。これにより、自分のコードの目的と機能を正確に表現できます。例えば、アプリケーションで日付を処理するクラスを作成したい場合、既存の java.util.Date クラスと競合する一般的な名前「Date」を使うのではなく、「AppDate」や「DisplayDate」のような具体的でユニークな名前を選ぶことができます。識別子を選ぶ際に注意すべきいくつかの重要なポイントは次の通りです：意味のある接頭辞や名前空間を使用する：クラス名にプロジェクト固有の接頭辞や名前空間を付けて、クラス名を区別します。例えば、プロジェクト名が「MyApp」の場合、「MyAppDate」のようなクラス名を使用できます。説明的な名前を使用する：クラスの目的や機能を明確に示す説明的な名前を選びます。これにより、既存のJava標準ライブラリの識別子を隠すことを避けることができます。例えば、「List」の代わりに「CustomAppList」を使用することを検討します。命名規則に従う：Javaの命名規則に従い、クラス名にキャメルケース（例：MyClass）を使用します。これによりコードの可読性が向上し、競合の可能性が減少します。SEI CERTルール DCL01-J を参照してください。Java標準ライブラリの公開識別子を再利用しないこと。",
      "pi_do_not_reuse_public_identifiers_field_names": "PI: JSLの公開識別子をフィールド名として再利用しないJava標準ライブラリの公開識別子をフィールド名として再利用しないことは良いプラクティスです。このような再利用は混乱や潜在的な競合を引き起こし、コードの理解や保守を難しくする可能性があります。代わりに、フィールドの目的を正確に表し、標準ライブラリの識別子と区別できるユニークで説明的な名前を選ぶことをお勧めします。例えば、アプリケーションで日付を処理するクラスを作成したい場合、既存の java.util.Date クラスと競合する一般的な名前「Date」を使うのではなく、「AppDate」や「DisplayDate」のような具体的でユニークな名前を選ぶことができます。例えば、アプリケーションで車を表現するクラスを作成する場合、既存の java.awt.Component クラスと競合する一般的な名前「Component」をフィールドとして使用するのではなく、「VehiclePart」や「CarComponent」など、より具体的で区別できる名前を選ぶべきです。識別子を選ぶ際に注意すべきいくつかの重要なポイントは次の通りです：説明的な名前を使用する：フィールドの目的や機能を明確に示す説明的な名前を選びます。これにより、既存のJava標準ライブラリの識別子を隠すことを避けることができます。例えば、「list」の代わりに「myFancyList」を使用することを検討します。命名規則に従う：Javaの命名規則に従い、フィールド名にミックスケースを使用します。最初の文字は小文字で始まり、内部の単語は大文字で始めます（例：myFieldUsesMixedCase）。これによりコードの可読性が向上し、競合の可能性が減少します。SEI CERTルール DCL01-J を参照してください。Java標準ライブラリの公開識別子を再利用しないこと。",
      "pi_do_not_reuse_public_identifiers_method_names": "PI: JSLの公開識別子をメソッド名として再利用しないJava標準ライブラリの公開識別子をメソッド名として再利用しないことは良いプラクティスです。このような再利用は混乱を招き、潜在的な競合や予期しない動作を引き起こす可能性があります。コードの明確さを維持し、適切な機能を保証するために、メソッド名には目的を正確に表し、標準ライブラリの識別子と区別できるユニークで説明的な名前を選ぶことが推奨されます。例えば、アプリケーションでカスタムファイルの作成を処理するメソッドを作成したい場合、既存の java.io.File クラスと競合する一般的な名前「File」をメソッド名として使用するのではなく、「generateFile」や「createOutPutFile」のような具体的でユニークな名前を選ぶことができます。識別子を選ぶ際に注意すべきいくつかの重要なポイントは次の通りです：説明的な名前を使用する：メソッド名はその目的や機能を明確に示す説明的な名前を選びます。これにより、既存のJava標準ライブラリの識別子を隠すことを避けることができます。例えば、「abs()」の代わりに「calculateAbsoluteValue()」を使用することを検討します。命名規則に従う：Javaの命名規則に従い、メソッド名にはミックスケースを使用します。メソッド名は動詞で始まり、最初の文字は小文字で、内部の単語の最初の文字は大文字にします（例：runFast()）。これによりコードの可読性が向上し、競合の可能性が減少します。SEI CERTルール DCL01-J を参照してください。Java標準ライブラリの公開識別子を再利用しないこと。",
      "pi_do_not_reuse_public_identifiers_local_variable_names": "PI: JSLの公開識別子をローカル変数名として再利用しないJavaでローカル変数を宣言する際、Java標準ライブラリの公開識別子を再利用しないことは良いプラクティスです。これらの識別子をローカル変数名として再利用すると、混乱を招き、コードの理解を妨げ、Java標準ライブラリからの既存の公開識別子名と競合する可能性があります。コードの明確さを維持し、そのような問題を避けるために、ローカル変数にはユニークで説明的な名前を選ぶことが最良のプラクティスです。例えば、カスタムフォントの値を変数に格納したい場合、既存の java.awt.Font クラスと競合する一般的な名前「Font」を変数名として使用するのではなく、「customFont」や「loadedFontName」のような具体的でユニークな名前を選ぶことができます。識別子を選ぶ際に注意すべきいくつかの重要なポイントは次の通りです：説明的な名前を使用する：変数名はその目的や機能を明確に示す説明的な名前を選びます。これにより、既存のJava標準ライブラリの識別子を隠すことを避けることができます。例えば、「variable」の代わりに「myVariableName」を使用することを検討します。命名規則に従う：Javaの命名規則に従い、変数名にはミックスケースを使用します。最初の文字は小文字で始まり、内部の単語は大文字で始めます（例：myVariableName）。これによりコードの可読性が向上し、競合の可能性が減少します。SEI CERTルール DCL01-J を参照してください。Java標準ライブラリの公開識別子を再利用しないこと。",
      "env_use_property_instead_of_env": "ENV: 環境変数ではなく、ポータブルなJavaプロパティを使用することが推奨されます。環境変数はポータブルではなく、変数名自体（値だけでなく）が実行中のOSによって異なる場合があります。特定の環境変数の名前（例えば、Windowsでは USERNAME、Unixシステムでは USER）だけでなく、意味が異なる場合もあります。例えば、大文字小文字の区別（Windowsは大文字小文字を区別せず、Unixは区別します）。さらに、java.lang.System.getenv() で返される環境変数のMapおよびそのコレクションビューは、Object.equals(java.lang.Object) や Object.hashCode() メソッドの一般契約に従わない場合があります。したがって、環境変数の使用は意図しない副作用を引き起こす可能性があります。また、環境変数の可視性はJavaプロパティに比べて制限が少なく、定義プロセスのすべての子孫に可視であり、即時のJavaサブプロセスだけに見えるわけではありません。これらの理由から、java.lang.System のJava APIは可能な限り、環境変数（java.lang.System.getenv(java.lang.String)）ではなく、Javaプロパティ（java.lang.System.getProperty(java.lang.String)）の使用を推奨しています。もし値が System.getProperty() と System.getenv() の両方でアクセス可能な場合は、前者を使用してアクセスすべきです。対応するJavaシステムプロパティのマッピング：環境変数\tプロパティJAVA_HOME\tjava.homeJAVA_VERSION\tjava.versionTEMP\tjava.io.tmpdirTMP\tjava.io.tmpdirPROCESSOR_ARCHITECTURE\tos.archOS\tos.nameUSER\tuser.nameUSERNAME\tuser.nameHOME\tuser.homeHOMEPATH\tuser.homeCD\tuser.dirPWD\tuser.dirSEI CERTルール ENV02-J を参照してください。環境変数の値を信頼しないこと。",
      "overriding_methods_must_invoke_super": "CN: スーパーメソッドには @OverridingMethodsMustInvokeSuper が注釈されていますが、オーバーライドメソッドがスーパーメソッドを呼び出していません。スーパーメソッドには @OverridingMethodsMustInvokeSuper が注釈されていますが、オーバーライドメソッドがスーパーメソッドを呼び出していません。",
      "np_optional_return_null": "NP: Optional型の戻り値メソッドが明示的なnullを返すOptional型の戻り値（java.util.Optional または com.google.common.base.Optional）を使用することは、設計上明示的なnull返却が望ましくないことを意味します。このような場合にnull値を返すことは契約違反となり、クライアントコードが破損する可能性が高いです。",
      "np_nonnull_field_not_initialized_in_constructor": "NP: 非nullフィールドが初期化されていないフィールドは非nullとしてマークされていますが、コンストラクタによって書き込まれていません。このフィールドはコンストラクタの他の場所で初期化されるか、使用前に常に初期化される可能性があります。",
      "vr_unresolvable_reference": "VR: クラスが解決できないクラスまたはメソッドを参照しているこのクラスは、使用されているライブラリで解決できないクラスまたはメソッドを参照しています。",
      "il_infinite_loop": "IL: 明らかな無限ループこのループには終了する方法がないようです（例外を投げることで終了する可能性があります）。CWE-835: 到達不可能な終了条件によるループ（「無限ループ」）を参照してください。",
      "io_appending_to_object_output_stream": "IO: オブジェクト出力ストリームに追加しようとする無駄な試みこのコードはファイルを追加モードで開き、その結果をオブジェクト出力ストリームでラップします。次のように：OutputStream out = new FileOutputStream(anyFile, true);new ObjectOutputStream(out);これでは、ファイルに保存された既存のオブジェクト出力ストリームに追加することはできません。オブジェクト出力ストリームに追加できるようにしたい場合は、オブジェクト出力ストリームを開いたままにする必要があります。ファイルを追加モードで開き、その後オブジェクト出力ストリームを書き込むことで動作する唯一の状況は、ファイルを読み取るときにランダムアクセスモードで開き、追加が開始されたバイトオフセットにシークする場合です。",
      "il_infinite_recursive_loop": "IL: 明らかな無限再帰ループこのメソッドは無条件に自分自身を呼び出します。これは無限再帰ループを示唆しており、スタックオーバーフローを引き起こす可能性があります。CWE-674: 制御されていない再帰とCWE-835: 到達不可能な終了条件によるループ（「無限ループ」）を参照してください。",
      "il_container_added_to_itself": "IL: コレクションが自分自身に追加されているコレクションが自分自身に追加されています。その結果、このセットの hashCode を計算すると StackOverflowException が発生します。",
      "rp_c_repeated_conditional_test": "RpC: 条件式の繰り返しテストコードには条件式のテストが2回連続して実行されている箇所があります（例： `x == 0",
      "fl_math_using_float_precision": "FL: メソッドが浮動小数点精度を使用して数学を行っているこのメソッドは浮動小数点精度を使用して数学的操作を行っていますが、浮動小数点精度は非常に不正確です。例えば、16777216.0f + 1.0f = 16777216.0f になります。代わりに double 精度を使用することを検討してください。CWE-1339: 実数の精度不足または不正確さを参照してください。",
      "caa_covariant_array_element_store": "CAA: 共変配列に互換性のない要素が格納されている可能性値が配列に格納され、値の型が配列の型と一致しません。分析から、実際の配列の型がその変数またはフィールドの宣言型よりも狭く、この代入が元の配列型を満たしていないことがわかります。この代入は実行時に ArrayStoreException を引き起こす可能性があります。",
      "dmi_vacuous_call_to_easymock_method": "Dm: EasyMockメソッドへの無駄な/無意味な呼び出しこの呼び出しでは、EasyMockメソッドにオブジェクトを渡していないため、呼び出しは何も行いません。",
      "dmi_futile_attempt_to_change_maxpool_size_of_scheduled_thread_pool_executor": "Dm: ScheduledThreadPoolExecutorの最大プールサイズを変更しようとする無駄な試み(Javadoc) ScheduledThreadPoolExecutorはThreadPoolExecutorを継承していますが、継承したチューニングメソッドのいくつかはそれには役立ちません。特に、コアプールサイズのスレッドと無制限のキューを使用する固定サイズプールとして機能するため、maximumPoolSize の調整は有効な効果を持ちません。",
      "dmi_bigdecimal_constructed_from_double": "DMI: 精密に表現されないダブルから構築されたBigDecimalこのコードは、ダブル値からBigDecimalを作成していますが、そのダブル値は十進数にうまく変換されません。例えば、new BigDecimal(0.1) をJavaで書くと、BigDecimalは0.1と正確に等しい（スケール1で未スケールの値1）と思うかもしれませんが、実際には次のような値になります： 0.1000000000000000055511151231257827021181583404541015625。代わりに、BigDecimal.valueOf(double d) メソッドを使用することをお勧めします。このメソッドはダブルの文字列表現を使ってBigDecimalを作成します（例えば、BigDecimal.valueOf(0.1) は 0.1 を返します）。CWE-1339: 実数の精度不足または不正確さを参照してください。",
      "dmi_scheduled_thread_pool_executor_with_zero_core_threads": "Dm: ScheduledThreadPoolExecutorのコアスレッド数がゼロの作成",
      "dmi_annotation_is_not_visible_to_reflection": "Dm: 実行時保持がないアノテーションの存在をリフレクションで確認できませんアノテーション自体が @Retention(RetentionPolicy.RUNTIME) でアノテートされていない限り、そのアノテーションはリフレクションを使用して観察できません（例：isAnnotationPresent メソッドを使用）。",
      "np_argument_might_be_null": "NP: メソッドがヌル引数の確認を行っていませんこのメソッドのパラメータは常にヌルかどうかを確認する必要がある値として識別されていますが、ヌルチェックが行われる前に参照されています。",
      "rv_absolute_value_of_random_int": "RV: 符号付きランダム整数の絶対値を計算しようとする不正な試みこのコードはランダムな符号付き整数を生成し、その整数の絶対値を計算します。もしランダム番号生成器が返す番号が Integer.MIN_VALUE であれば、結果も負の値になります（Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE）。（同様の問題は long 値にも発生します）。",
      "rv_absolute_value_of_hashcode": "RV: 符号付き32ビットハッシュコードの絶対値を計算しようとする不正な試みこのコードはハッシュコードを生成し、そのハッシュコードの絶対値を計算します。もしハッシュコードが Integer.MIN_VALUE であれば、結果も負の値になります（Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE）。2^32のうち1つの文字列が Integer.MIN_VALUE のハッシュコードを持っています。例えば、'polygenelubricants', 'GydZG_' と ''DESIGNING WORKHOUSES' などです。",
      "rv_01_to_int": "RV: 0から1の間のランダムな値が整数0に強制変換されている0から1の間のランダムな値が整数値0に強制変換されています。整数に強制変換する前にランダム値を別の値で乗算するか、Random.nextInt(n) メソッドを使用することをお勧めします。",
      "dm_invalid_min_max": "Dm: Math.max と Math.min の不正な組み合わせこのコードは Math.min(0, Math.max(100, value)) のような構文を使用して値の範囲を制限しようとしています。しかし、定数の順番が誤っています。正しくは Math.min(100, Math.max(0, value)) です。この結果、このコードは常に同じ結果を生成します（value が NaN の場合は NaN）。",
      "eq_comparing_class_names": "Eq: equals メソッドがクラスオブジェクトではなくクラス名を比較していますこのクラスは、オブジェクトのクラス名が等しいかどうかを確認して、2つのオブジェクトが同じクラスかどうかを確認する equals メソッドを定義しています。異なるクラスローダーでロードされた同じ名前の異なるクラスを持つことができます。クラスオブジェクトが同じかどうかを確認するだけで十分です。CWE-486: クラスを名前で比較することを参照してください。",
      "eq_always_true": "Eq: equals メソッドが常に true を返しますこのクラスは、常に true を返す equals メソッドを定義しています。これは創造的ですが、あまり賢くはありません。さらに、equals メソッドが対称的でないことを意味します。CWE-571: 式が常に true であることを参照してください。",
      "eq_always_false": "Eq: equals メソッドが常に false を返しますこのクラスは、常に false を返す equals メソッドを定義しています。これは、オブジェクトが自分自身と等しくないことを意味し、このクラスの有用なマップやセットを作成することが不可能になります。もっと基本的には、equals が反射的でないことを意味します。equals メソッドの要件の1つです。おそらく意図された意味論はオブジェクトの同一性です：オブジェクトは自分自身と等しいということです。これは Object クラスから継承された動作です。もし他のスーパークラスから継承された equals をオーバーライドする必要がある場合は、次のようにできます：public boolean equals(Object o) {   return this == o;}CWE-570: 式が常に false であることを参照してください。",
      "eq_overriding_equals_not_symmetric": "Eq: equals メソッドがスーパークラスの equals をオーバーライドしており、対称性がない可能性がありますこのクラスは、スーパークラスの equals メソッドをオーバーライドする equals メソッドを定義しています。両方の equals メソッドは、2つのオブジェクトが等しいかどうかを判断する際に instanceof を使用します。これは危険を伴います。なぜなら、equals メソッドが対称的であることが重要だからです（言い換えれば、a.equals(b) == b.equals(a) であるべきです）。もし B が A のサブタイプで、A の equals メソッドが引数が A のインスタンスかどうかを確認し、B の equals メソッドが引数が B のインスタンスかどうかを確認すると、これらのメソッドによって定義された等価関係が対称的でない可能性が高いです。",
      "eq_dont_define_equals_for_enum": "Eq: 列挙型のために共変の equals() メソッドが定義されていますこのクラスは列挙型を定義しており、列挙型の等価性はオブジェクト同一性を使用して定義されます。列挙型値に共変の equals メソッドを定義することは非常に悪いプラクティスです。なぜなら、共変の列挙型メソッドを使用して等しいと比較される2つの異なる列挙型値が、通常の方法で比較すると等しくない結果になる可能性があるからです。これは避けるべきです。",
      "eq_self_use_object": "Eq: 共変の equals() メソッドが定義され、Object.equals(Object) が継承されていますこのクラスは equals() メソッドの共変バージョンを定義していますが、base java.lang.Object クラスで定義された通常の equals(Object) メソッドを継承しています。このクラスは、おそらく boolean equals(Object) メソッドを定義するべきです。",
      "eq_other_use_object": "Eq: equals() メソッドが定義されているが、Object.equals(Object) をオーバーライドしていないこのクラスは、Object クラスで定義された通常の equals(Object) メソッドをオーバーライドしない equals() メソッドを定義しています。このクラスは、おそらく boolean equals(Object) メソッドを定義するべきです。",
      "eq_other_no_object": "Eq: equals() メソッドが定義されているが、equals(Object) をオーバーライドしていないこのクラスは、Object クラスで定義された通常の equals(Object) メソッドをオーバーライドしない equals() メソッドを定義しています。その代わりに、スーパークラスから equals(Object) メソッドを継承しています。このクラスは、おそらく boolean equals(Object) メソッドを定義するべきです。",
      "he_signature_declares_hashing_of_unhashable_class": "HE: ハッシュされた構造で非ハッシュ可能なクラスを使用することが宣言されていますメソッド、フィールド、またはクラスは、ハッシュ可能なクラスが必要なコンテキストで非ハッシュ可能なクラスを使用するジェネリックシグネチャを宣言します。equals メソッドを宣言しているが、Object から hashCode() メソッドを継承しているクラスはハッシュ不可能です。なぜなら、等しいオブジェクトが等しいハッシュコードを持つという要求を満たしていないからです。",
      "he_use_of_unhashable_class": "HE: ハッシュされたデータ構造で hashCode() メソッドのないクラスを使用しているこのクラスは equals(Object) メソッドを定義していますが、hashCode() メソッドは定義していません。したがって、等しいオブジェクトが等しいハッシュコードを持つという要求を満たしていません。このクラスのインスタンスがハッシュデータ構造で使用されているため、この問題を修正することが最も重要です。",
      "ur_uninit_read": "UR: コンストラクタでフィールドの初期化前に読み取っていますこのコンストラクタは、まだ値が割り当てられていないフィールドを読み取っています。これは、プログラマーがフィールドではなく、コンストラクタのパラメータの1つを誤って使用した場合にしばしば発生します。See CWE-457: Use of Uninitialized Variable.",
      "ur_uninit_read_called_from_super_constructor": "UR: コンストラクタから呼び出されたフィールドメソッドの未初期化の読み取り\nこのメソッドはスーパークラスのコンストラクタ内で呼び出されます。この時点で、クラスのフィールドはまだ初期化されていません。\n\n具体例を考えてみましょう：\n\nabstract class A {\n    int hashCode;\n    abstract Object getValue();\n\n    A() {\n        hashCode = getValue().hashCode();\n    }\n}\n\nclass B extends A {\n    Object value;\n\n    B(Object v) {\n        this.value = v;\n    }\n\n    Object getValue() {\n        return value;\n    }\n}\nBが構築されるとき、AクラスのコンストラクタはBのコンストラクタでvalueが設定される前に呼び出されます。したがって、AのコンストラクタがgetValueを呼び出すとき、未初期化の値がvalueに対して読み取られます。\n\nSee CWE-457: Use of Uninitialized Variable.",
      "nm_very_confusing": "Nm: 非常に混乱を招くメソッド名\n参照されたメソッドは、大文字と小文字の違いだけで名前が異なります。大文字と小文字が同じであれば、一方のメソッドが他方をオーバーライドすることになるので、非常に混乱を招きます。",
      "nm_wrong_package": "Nm: パラメータのパッケージが間違っているため、メソッドがスーパークラスのメソッドをオーバーライドしない\nサブクラスのメソッドは、パラメータの型がスーパークラスの対応するパラメータの型と正確に一致しないため、スーパークラスの類似のメソッドをオーバーライドしません。例えば、次のような場合です：\n\nimport alpha.Foo;\n\npublic class A {\n    public int f(Foo x) { return 17; }\n}\n----\nimport beta.Foo;\n\npublic class B extends A {\n    public int f(Foo x) { return 42; }\n}\nクラスBで定義されたf(Foo)メソッドは、クラスAで定義されたf(Foo)メソッドをオーバーライドしていません。なぜなら、引数の型が異なるパッケージからのFooだからです。",
      "nm_method_constructor_confusion": "Nm: メソッド/コンストラクタの名前が混乱しているように見える\nこの通常のメソッドは、定義されているクラスと同じ名前を持っています。これはコンストラクタであることが意図されていた可能性が高いです。もしコンストラクタであることが意図されていたのであれば、void の戻り値を削除してください。もしこのメソッドを誤って定義し、誤りに気づいて適切なコンストラクタを定義したが、後方互換性のためにこのメソッドを削除できない場合は、このメソッドを非推奨にしてください。",
      "nm_lcase_hashcode": "Nm: クラスが hashcode() を定義していますが、それは hashCode() であるべきではありませんか？\nこのクラスは hashcode() というメソッドを定義しています。このメソッドは、java.lang.Object の hashCode() メソッドをオーバーライドしていません。おそらく、意図されていたのは hashCode() メソッドです。",
      "nm_lcase_tostring": "Nm: クラスが tostring() を定義していますが、それは toString() であるべきではありませんか？\nこのクラスは tostring() というメソッドを定義しています。このメソッドは、java.lang.Object の toString() メソッドをオーバーライドしていません。おそらく、意図されていたのは toString() メソッドです。",
      "nm_bad_equal": "Nm: クラスが equal(Object) を定義していますが、それは equals(Object) であるべきではありませんか？\nこのクラスは equal(Object) というメソッドを定義しています。このメソッドは、java.lang.Object の equals(Object) メソッドをオーバーライドしていません。おそらく、意図されていたのは equals(Object) メソッドです。",
      "se_read_resolve_is_static": "Se: readResolve メソッドは static メソッドとして宣言してはいけません。\nreadResolve メソッドがシリアライズメカニズムによって認識されるためには、それは static メソッドとして宣言してはいけません。",
      "se_method_must_be_private": "Se: シリアライズが機能するためにはメソッドは private でなければなりません\nこのクラスは Serializable インターフェースを実装し、カスタムシリアライズ/デシリアライズのメソッドを定義しています。しかし、そのメソッドが private として宣言されていないため、シリアライズ/デシリアライズ API によって無視されます。",
      "sf_dead_store_due_to_switch_fallthrough": "SF: switch文のフォールスルーによるデッドストア\n前のswitchケースに格納された値が、switch文のフォールスルーによってここで上書きされます。おそらく、前のケースの最後にbreakまたはreturnを入れ忘れた可能性があります。\n\nSee CWE-484: Omitted Break Statement in Switch.",
      "sf_dead_store_due_to_switch_fallthrough_to_throw": "SF: switch文のフォールスルーによるデッドストア（例外がスローされる場所に）\n前のswitchケースに格納された値が、switch文のフォールスルーによって無視され、例外がスローされる場所に進みます。おそらく、前のケースの最後にbreakまたはreturnを入れ忘れた可能性があります。\n\nSee CWE-484: Omitted Break Statement in Switch.",
      "np_unwritten_field": "NP: 書き込まれていないフィールドの読み取り\nプログラムが、値がnull以外に書き込まれることがないフィールドをデリファレンスしています。分析で確認されないメカニズムでフィールドが初期化されていない限り、この値をデリファレンスするとnullポインタ例外が発生します。\n\nSee CWE-457: Use of Uninitialized Variable.",
      "uwf_null_field": "UwF: フィールドが常にnullに設定されている\nこのフィールドへの書き込みはすべて定数値nullであり、そのためフィールドの読み取りはすべてnullを返します。エラーを確認するか、無用であれば削除してください。",
      "uwf_unwritten_field": "UwF: 書き込まれていないフィールド\nこのフィールドは決して書き込まれません。すべての読み取りはデフォルト値を返します。エラーを確認するか（初期化すべきだったのか？）、無用であれば削除してください。\n\nSee CWE-457: Use of Uninitialized Variable.",
      "sic_threadlocal_deadly_embrace": "SIC: 非静的内部クラスとスレッドローカルの致命的な抱擁\nこのクラスは内部クラスですが、おそらく静的内部クラスであるべきです。現在の状態では、内部クラスと外部クラスのスレッドローカル間で致命的な抱擁が発生する危険があります。内部クラスが静的でないため、外部クラスへの参照を保持します。もしスレッドローカルが内部クラスのインスタンスへの参照を保持していると、内部と外部のインスタンスが両方とも参照可能になり、ガーベジコレクションの対象外になります。",
      "range_array_index": "RANGE: 配列インデックスが範囲外\n配列操作が実行されましたが、配列インデックスが範囲外であるため、ランタイムでArrayIndexOutOfBoundsExceptionが発生します。",
      "range_array_offset": "RANGE: 配列オフセットが範囲外\n配列パラメータとオフセットパラメータが渡されましたが、オフセットが範囲外です。これにより、ランタイムでIndexOutOfBoundsExceptionが発生します。",
      "range_array_length": "RANGE: 配列長さが範囲外\n配列パラメータと長さパラメータが渡されましたが、長さが範囲外です。これにより、ランタイムでIndexOutOfBoundsExceptionが発生します。",
      "range_string_index": "RANGE: 文字列インデックスが範囲外\n文字列メソッドが呼び出され、指定された文字列インデックスが範囲外です。これにより、ランタイムでStringIndexOutOfBoundsExceptionが発生します。",
      "rv_return_value_ignored": "RV: メソッドが戻り値を無視している\nこのメソッドの戻り値は確認するべきです。この警告の一般的な原因の一つは、不変オブジェクトにメソッドを呼び出して、オブジェクトが更新されると思い込んでいることです。例えば、次のコード断片では、\n\nString dateString = getHeaderField(name);\ndateString.trim();\nプログラマーはtrim()メソッドがdateStringによって参照されるStringを更新すると考えています。しかし、Stringは不変なので、trim()関数は新しいString値を返し、ここではそれが無視されています。コードは次のように修正する必要があります：\n\nString dateString = getHeaderField(name);\ndateString = dateString.trim();\n<p>\nSee CWE-252: Unchecked Return Value.",
      "rv_exception_not_thrown": "RV: 例外が作成され、スローされずに破棄される\nこのコードは例外（またはエラー）オブジェクトを作成しますが、それを何もせずに破棄します。例えば、次のように書かれている場合:\n\nif (x < 0) {\n    new IllegalArgumentException('x must be nonnegative');\n}\nおそらくプログラマーの意図は、作成した例外をスローすることだったはずです：\n\nif (x < 0) {\n    throw new IllegalArgumentException('x must be nonnegative');\n}",
      "rv_check_compareto_for_specific_return_value": "RV: コードがcompareToメソッドによって返される特定の値をチェックする\nこのコードはcompareToまたはcompareメソッドを呼び出し、その戻り値が特定の値（例えば1または-1）であるかどうかをチェックします。これらのメソッドを呼び出すとき、戻り値の符号のみを確認すべきであり、特定の非ゼロの値をチェックすべきではありません。多くのcompareToおよびcompareメソッドは-1、0、1のいずれかのみを返しますが、いくつかのメソッドは他の値を返す場合もあります。\n\nSee CWE-253: Incorrect Check of Function Return Value.",
      "np_always_null": "NP: ヌルポインタのデリファレンス\nここでヌルポインタがデリファレンスされています。これにより、コードが実行されるとNullPointerExceptionが発生します。",
      "np_closing_null": "NP: 常にnullの値に対してclose()が呼ばれる\n常にnullの値に対してclose()が呼び出されています。このステートメントが実行されると、nullポインタ例外が発生します。しかし、ここでの大きなリスクは、閉じるべきものが決して閉じられないことです。",
      "np_store_into_nonnull_field": "NP: @Nonnull注釈が付けられたフィールドにnull値が格納される\nnullの可能性がある値が@Nonnullとして注釈が付けられたフィールドに格納されます。",
      "np_always_null_exception": "NP: 例外パスでメソッド内のヌルポインタデリファレンス\n例外パスでnullであるポインタがここでデリファレンスされています。これにより、コードが実行されるとNullPointerExceptionが発生します。SpotBugsは現在、実行不可能な例外パスをプルーニングしないため、これは誤警告である可能性があります。\n\nまた、SpotBugsはswitch文のデフォルトケースを例外パスと見なします。デフォルトケースは実行不可能な場合が多いためです。",
      "np_null_on_some_path": "NP: ヌルポインタデリファレンスの可能性\n実行されると、ヌル値がデリファレンスされることが確実な条件分岐が存在します。これにより、コードが実行されるとNullPointerExceptionが発生します。もちろん、この分岐やステートメントが実行不可能であり、ヌルポインタ例外が発生することがない可能性もあります。その判断はSpotBugsの能力を超えています。",
      "np_null_on_some_path_exception": "NP: 例外パスでメソッド内のヌルポインタデリファレンスの可能性\nある例外制御パスでnullである参照値がここでデリファレンスされています。これにより、コードが実行されるとNullPointerExceptionが発生する可能性があります。SpotBugsは現在、実行不可能な例外パスをプルーニングしないため、これは誤警告である可能性があります。\n\nまた、SpotBugsはswitch文のデフォルトケースを例外パスと見なします。デフォルトケースは実行不可能な場合が多いためです。",
      "np_null_param_deref": "NP: 非nullパラメータにnullが渡されるメソッド呼び出し\nこのメソッド呼び出しでは、非nullパラメータにnull値が渡されています。パラメータは常に非nullであるべきだと注釈されているか、解析によって常にデリファレンスされることが示されています。",
      "np_null_param_deref_nonvirtual": "NP: 非仮想メソッド呼び出しで非nullパラメータにnullが渡される\nおそらくnullの値が非nullメソッドパラメータに渡されます。パラメータは常に非nullであるべきだと注釈されているか、解析によって常にデリファレンスされることが示されています。",
      "np_null_param_deref_all_targets_dangerous": "NP: メソッド呼び出しで非nullパラメータにnullが渡される\nおそらくnullの値が、すべてのターゲットメソッドで非nullを必要とする呼び出し元で渡されます。パラメータは常に非nullであるべきだと注釈されているか、解析によって常にデリファレンスされることが示されています。",
      "np_nonnull_param_violation": "NP: メソッド呼び出しで非nullパラメータにnullが渡される\nこのメソッドは、null値を非nullでなければならないメソッドのパラメータとして渡します。このパラメータは明示的に@Nonnullとしてマークされているか、解析によって常にデリファレンスされることが示されています。",
      "np_nonnull_return_violation": "NP: メソッドがnullを返す可能性があるが、@Nonnullと宣言されている\nこのメソッドはnull値を返す可能性がありますが、そのメソッド（またはそれがオーバーライドする親クラスのメソッド）は@Nonnullを返すと宣言されています。",
      "np_guaranteed_deref": "NP: null値がデリファレンスされることが保証されている\n実行されると、あるステートメントや分岐が、この時点で値がnullであることを保証し、その値がデリファレンスされることが保証されています（ランタイム例外を含む前進パスでは除外されます）。\n\nif (x == null) throw new NullPointerException();のようなチェックはxのデリファレンスとして扱われます。",
      "np_guaranteed_deref_on_exception_path": "NP: 値がnullで、例外パスでデリファレンスされることが保証されている\n例外パスで、実行されると、この時点で値がnullであることを保証し、その値がデリファレンスされることが保証されているステートメントや分岐があります（ランタイム例外を含む前進パスでは除外されます）。",
      "dmi_arguments_wrong_order": "DMI: メソッド引数の順序が逆転している\nこのメソッド呼び出しの引数は順番が逆になっているようです。例えば、Preconditions.checkNotNull('message', message)という呼び出しでは、最初の引数がチェックされるべき値であるべきです。\n\nSee CWE-683: Function Call With Incorrect Order of Arguments.",
      "rcn_redundant_nullcheck_would_have_been_a_npe": "RCN: 以前にデリファレンスされた値のヌルチェック\nここで値がnullかどうかチェックされていますが、この値は以前にデリファレンスされているためnullにはなりません。もしnullだった場合、以前のデリファレンスでヌルポインタ例外が発生していたはずです。実際、このコードと以前のデリファレンスは、この値がnullであることを許可するかどうかについて矛盾しています。チェックが冗長であるか、以前のデリファレンスが誤りである可能性があります。",
      "rc_ref_comparison": "RC: 疑わしい参照比較\nこのメソッドは、==または!=演算子を使用して2つの参照値を比較しますが、通常このタイプのインスタンスを比較する正しい方法はequals()メソッドを使うことです。異なるオブジェクトであっても、==では比較できないが等しいインスタンスを作成することが可能です。参照で比較すべきではないクラスの例として、java.lang.Integer、java.lang.Floatなどがあります。RC_REF_COMPARISONはプリミティブ型のラッパータイプのみをカバーします。疑わしいタイプのリストは、frc.suspiciousシステムプロパティにカンマ区切りでクラスを追加することで拡張できます。\n\n\n              java.time.LocalDate,java.util.List\n           \nSee CWE-595: Comparison of Object References Instead of Object Contents.",
      "va_primitive_array_passed_to_object_vararg": "VA: 変数長のオブジェクト引数を期待する関数にプリミティブ配列が渡される\nこのコードは、プリミティブ配列をオブジェクト引数を受け取る変数長の引数を持つ関数に渡します。これにより、プリミティブ配列を保持する長さ1の配列が作成され、関数に渡されます。",
      "ec_unrelated_types_using_pointer_equality": "EC: 異なる型を比較するためにポインタ等価性を使用\nこのメソッドは、異なる型と思われる2つの参照を比較するためにポインタ等価性を使用します。この比較の結果は実行時に常にfalseになります。\n\nSee CWE-570: Expression is Always False.",
      "ec_unrelated_types": "EC: 異なる型を比較するequals()の呼び出し\nこのメソッドは、異なるクラス型の2つの参照に対してequals(Object)を呼び出します。解析によると、実行時にこれらの参照は異なるクラスのオブジェクトであると予測されます。さらに、呼び出されるequalsメソッドの検討結果により、この呼び出しは常にfalseを返すか、equalsメソッドが対称でない（Objectクラスのequals契約で必要な特性）ことが示唆されます。\n\nSee CWE-570: Expression is Always False.",
      "ec_array_and_nonarray": "EC: 配列と非配列を比較するためにequals()を使用\nこのメソッドは、.equals(Object o)を呼び出して、配列と配列でない参照を比較します。比較対象が異なる型であれば、それらは必ず異なり、この比較はほぼ確実に誤りです。たとえ両方が配列であったとしても、配列のequals()メソッドは2つの配列が同じオブジェクトかどうかだけを判断します。配列の内容を比較するには、java.util.Arrays.equals(Object[], Object[])を使用してください。",
      "ec_null_arg": "EC: equals(null)の呼び出し\nこのメソッドは、null値を引数としてequals(Object)を呼び出します。equals()メソッドの契約によると、この呼び出しは常にfalseを返すべきです。\n\nSee CWE-570: Expression is Always False.",
      "ec_unrelated_interfaces": "EC: 異なるインターフェース型を比較するためのequals()の呼び出し\nこのメソッドは、関連しないインターフェース型の2つの参照に対してequals(Object)を呼び出します。どちらのインターフェースも他方のサブタイプではなく、両方のインターフェースを実装する非抽象クラスは存在しません。そのため、比較されるオブジェクトは実行時に同じクラスのメンバーである可能性は低いです（アプリケーションクラスが分析されていない場合や、動的なクラスロードが実行時に行われる場合を除く）。equals()の契約に従い、異なるクラスのオブジェクトは常に異なるものとして比較されるべきです。したがって、java.lang.Object.equals(Object)によって定義された契約に従って、この比較の結果は実行時に常にfalseになります。\n\nSee CWE-570: Expression is Always False.",
      "ec_unrelated_class_and_interface": "EC: 関連しないクラスとインターフェースを比較するためのequals()の呼び出し\nこのメソッドは、クラスとインターフェースの2つの参照に対してequals(Object)を呼び出しますが、クラスもその非抽象サブクラスもそのインターフェースを実装していません。したがって、比較されるオブジェクトは実行時に同じクラスのメンバーである可能性は低いです（アプリケーションクラスが分析されていない場合や、動的なクラスロードが実行時に行われる場合を除く）。equals()の契約に従い、異なるクラスのオブジェクトは常に異なるものとして比較されるべきです。したがって、java.lang.Object.equals(Object)によって定義された契約に従って、この比較の結果は実行時に常にfalseになります。\n\nSee CWE-570: Expression is Always False.",
      "sa_local_self_assignment_instead_of_field": "SA: ローカル変数に対する自己代入、フィールドへの代入ではない\nこのメソッドにはローカル変数への自己代入が含まれていますが、同名のフィールドがあります。例:\n\n    int foo;\n    public void setFoo(int foo) {\n        foo = foo;\n    }\n代入は無駄です。フィールドに代入するつもりでしたか？",
      "int_bad_comparison_with_int_value": "INT: int値とlong定数の不適切な比較\nこのコードは、int値で表現できる範囲外のlong定数とint値を比較しています。この比較は無意味であり、誤りの可能性があります。",
      "int_bad_comparison_with_signed_byte": "INT: 符号付きバイトの不適切な比較\n符号付きバイトは-128から127の範囲内の値しか持つことができません。符号付きバイトとその範囲外の値を比較することは無意味であり、誤りである可能性が高いです。符号付きバイトbを0..255の範囲の符号なし値に変換するには、0xff & bを使用します。",
      "int_bad_comparison_with_nonnegative_value": "INT: 非負値と負定数またはゼロの不適切な比較\nこのコードは、非負であることが保証されている値と負の定数またはゼロを比較しています。バイト値と8ビット以下がクリアされた値を加算します。バイト配列から読み込まれた値は、ビット演算を行う前に32ビットに符号拡張されます。したがって、もしb[0]に0xffが格納され、xが初期値0であれば、コード((x << 8) + b[0])は0xffを符号拡張して0xffffffffとなり、その結果0xffffffffが得られます。\n\n特に、バイト配列をintにパックする次のコードは誤りです:\n\nint result = 0;\nfor (int i = 0; i < 4; i++)\n    result = ((result << 8) + b[i]);\n次のイディオムは代わりに動作します:\n\nint result = 0;\nfor (int i = 0; i < 4; i++)\n    result = ((result << 8) + (b[i] & 0xff));",
      "bit_add_of_signed_byte": "バイト値と、下位8ビットがクリアされているとわかっている値を加算します。バイト配列から読み込まれた値は、ビット演算を実行する前に32ビットに符号拡張されます。したがって、b[0] に値 0xff が含まれ、x が初期値 0 の場合、コード ((x << 8) + b[0]) は 0xff を符号拡張して 0xffffffff を取得し、結果として値 0xffffffff を返します。\n\n特に、バイト配列を int にパックする次のコードは大きく間違っています:\n\nint result = 0;\nfor (int i = 0; i < 4; i++)\n result = ((result << 8) + b[i]);\n代わりに次の慣用句が機能します:\n\nint result = 0;\nfor (int i = 0; i < 4; i++)\n result = ((result << 8) + (b[i] & 0xff));",
      "bit_ior_of_signed_byte": "BIT: 符号付きバイト値のビット論理和\nバイト値（例：バイト配列からロードされた値、または戻り値型がバイトのメソッドによって返された値）を読み込み、その値とビット論理和を実行します。バイト値は、ビット演算を実行する前に32ビットに符号拡張されます。したがって、b[0] に値 0xff が含まれ、x が初期値 0 の場合、コード ((x << 8) | b[0]) は 0xff を符号拡張して 0xffffffff を取得し、結果として値 0xffffffff を返します。\n\n特に、バイト配列を int にパックする次のコードは大きく間違っています:\n\nint result = 0;\nfor (int i = 0; i < 4; i++) {\n result = ((result << 8) | b[i]);\n}\n代わりに次のイディオムが機能します:\n\nint result = 0;\nfor (int i = 0; i < 4; i++) {\n result = ((result << 8) | (b[i] & 0xff));\n}",
      "bit_signed_check_high_bit": "BIT: 負の数を含むビット演算の符号をチェックします\nこのメソッドは、((val & CONSTANT) > 0) です。ここで、CONSTANT は負の数です。ビット演算を使用した後、大なり演算子で比較すると、予期しない結果が生じる可能性があります。この比較は期待どおりに動作しない可能性があります。「> 0」ではなく「!= 0」を使用することをお勧めします。",
      "bit_and": "BIT: 互換性のないビットマスク\nこのメソッドは、(e & C) という形式の式を D と比較しますが、定数 C と D の特定の値のため、常に不等値になります。これは論理エラーまたはタイプミスを示している可能性があります。",
      "bit_and_zz": "BIT: ((…) & 0) == 0 かどうかを確認してください\nこのメソッドは、(e & 0) という形式の式を 0 と比較しますが、常に等値になります。これは論理エラーまたはタイプミスを示している可能性があります。",
      "bit_ior": "BIT: 互換性のないビット マスク\nこのメソッドは、(e | C) 形式の式を D と比較します。定数 C と D の特定の値により、常に不等として比較されます。これは、論理エラーまたはタイプミスを示している可能性があります。\n\n通常、このバグは、コードがビット セットでメンバーシップ テストを実行しようとしているのに、ビット単位の AND ('&') ではなくビット単位の OR 演算子 ('|') を使用しているために発生します。\n\nまた、このようなバグは、(e & A | B) == C のような式で発生する可能性があります。これは、(e & (A | B)) == C が意図されていたのに、((e & A) | B) == C のように解析されます。",
      "sa_field_self_assignment": "SA: フィールドの自己代入\nこのメソッドは、フィールドの自己代入を含んでいます。例えば、\n\nint x;\npublic void foo() {\n    x = x;\n}\nこのような代入は無駄であり、論理エラーやタイプミスを示している可能性があります。",
      "sa_field_self_computation": "SA: フィールドに関する無意味な自己計算（例：x & x）\nこのメソッドは、フィールドを同じフィールドへの別の参照と無意味な計算を行います（例：x&xやx-x）。計算の性質から、この操作は意味がないように見え、タイプミスや論理エラーを示している可能性があります。計算を再確認してください。",
      "sa_local_self_computation": "SA: 変数に関する無意味な自己計算（例：x & x）\nこのメソッドは、ローカル変数を同じ変数への別の参照と無意味な計算を行います（例：x&xやx-x）。計算の性質から、この操作は意味がないように見え、タイプミスや論理エラーを示している可能性があります。計算を再確認してください。",
      "sa_field_self_comparison": "SA: フィールドの自己比較\nこのメソッドは、フィールドをその自身と比較しており、タイプミスや論理エラーを示している可能性があります。比較する対象が正しいか確認してください。",
      "sa_local_self_comparison": "SA: 値の自己比較\nこのメソッドは、ローカル変数をその自身と比較しており、タイプミスや論理エラーを示している可能性があります。比較する対象が正しいか確認してください。",
      "umac_uncallable_method_of_anonymous_class": "UMAC: 匿名クラスで定義された呼び出せないメソッド\nこの匿名クラスは、直接呼び出されず、スーパークラスのメソッドをオーバーライドしないメソッドを定義しています。他のクラスのメソッドが匿名クラスで定義されたメソッドを直接呼び出すことができないため、このメソッドは呼び出し不可能であるようです。このメソッドは単に不要なコードかもしれませんが、スーパークラスで定義されたメソッドをオーバーライドすることを意図していて、タイプミスや他のエラーのために実際にはオーバーライドしていない可能性もあります。\n\nCWE-561: 不要なコードを参照してください。",
      "iju_assert_method_invoked_from_run_method": "IJU: runメソッドでのJUnitアサーションはJUnitに認識されません\nJUnitアサーションがrunメソッドで実行されます。失敗したJUnitアサーションは例外がスローされるだけです。したがって、この例外がテストメソッドを呼び出すスレッド以外のスレッドで発生した場合、そのスレッドは終了しますが、テストは失敗しません。",
      "iju_bad_suite_method": "IJU: TestCaseが不正なsuiteメソッドを宣言\nクラスはJUnit TestCaseであり、suite()メソッドを定義しています。ただし、suiteメソッドは次のいずれかとして宣言する必要があります：\n\npublic static junit.framework.Test suite()\nまたは\n\npublic static junit.framework.TestSuite suite()",
      "iju_setup_no_super": "IJU: TestCaseがsuper.setUp()を呼び出さないsetUpを定義\nクラスはJUnit TestCaseであり、setUpメソッドを実装しています。setUpメソッドはsuper.setUp()を呼び出すべきですが、呼び出していません。",
      "iju_teardown_no_super": "IJU: TestCaseがsuper.tearDown()を呼び出さないtearDownを定義\nクラスはJUnit TestCaseであり、tearDownメソッドを実装しています。tearDownメソッドはsuper.tearDown()を呼び出すべきですが、呼び出していません。",
      "iju_suite_not_static": "IJU: TestCaseが非静的なsuiteメソッドを実装\nクラスはJUnit TestCaseであり、suite()メソッドを実装しています。suiteメソッドは静的であるべきですが、静的ではありません。",
      "iju_no_tests": "IJU: TestCaseにテストがありません\nクラスはJUnit TestCaseですが、テストメソッドを実装していません。",
      "boa_badly_overridden_adapter": "BOA: クラスが親クラスAdapterで実装されたメソッドを誤ってオーバーライド\nこのメソッドは、親クラスのAdapterで実装されたメソッドをオーバーライドしますが、そのクラスはjava.awt.eventやjavax.swing.eventパッケージで定義されたリスナーを実装しています。そのため、このメソッドはイベントが発生しても呼び出されません。",
      "sql_bad_resultset_access": "SQL: メソッドがインデックス0で結果セットのフィールドにアクセスしようとしています\n結果セットのgetXXXまたはupdateXXXメソッドが、フィールドインデックスが0で呼び出されました。ResultSetのフィールドはインデックス1から始まるため、これは常に誤りです。",
      "sql_bad_prepared_statement_access": "SQL: メソッドがインデックス0で準備済みステートメントのパラメータにアクセスしようとしています\n準備済みステートメントのsetXXXメソッドが、パラメータインデックスが0で呼び出されました。パラメータインデックスはインデックス1から始まるため、これは常に誤りです。",
      "sio_superfluous_instanceof": "SIO: 不要な型チェックがinstanceof演算子を使用して行われています\ninstanceof演算子を使用して型チェックが行われていますが、オブジェクトが要求された型であるかどうかは静的に決定できます。",
      "bac_bad_applet_constructor": "BAC: 初期化されていないAppletStubに依存する不正なAppletコンストラクタ\nこのコンストラクタは、親のAppletでAppletStubに依存するメソッドを呼び出します。AppletStubはinit()メソッドが呼ばれるまで初期化されないため、これらのメソッドは正しく動作しません。",
      "ec_incompatible_array_compare": "EC: 不適切な配列を比較するためにequals(...)が使用されています\nこのメソッドは、異なる型の配列（例：String[]とStringBuffer[]、またはString[]とint[]）を比較するために.equals(Object o)を呼び出します。これらは決して等しくなりません。さらに、equals(...)が配列を比較する際、配列が同じかどうかを確認するだけで、配列の内容は無視します。\n\nCWE-570: 式は常に偽であるを参照してください。",
      "ec_bad_array_compare": "EC: 配列でequals()を呼び出すことは、==と同じです\nこのメソッドは、配列で.equals(Object o)メソッドを呼び出します。配列はObjectのequalsメソッドをオーバーライドしないため、配列でequalsを呼び出すことは、アドレスを比較することと同じです。配列の内容を比較するには、java.util.Arrays.equals(Object[], Object[])を使用してください。配列のアドレスを比較するには、==を使用して明示的にポインタの等価性を確認する方が混乱が少なくなります。",
      "sti_interrupted_on_currentthread": "STI: interrupted()を呼び出すためにcurrentThread()の呼び出しが不要\nこのメソッドは、Thread.currentThread()を呼び出して、interrupted()メソッドを呼び出します。interrupted()は静的メソッドであるため、Thread.interrupted()を使用する方が簡単で明確です。",
      "sti_interrupted_on_unknownthread": "STI: Threadインスタンスで静的なThread.interrupted()メソッドを呼び出しています\nこのメソッドは、現在のスレッドでないように見えるThreadオブジェクトでThread.interrupted()メソッドを呼び出します。interrupted()メソッドは静的メソッドであるため、意図したオブジェクトとは異なるオブジェクトで呼び出されます。",
      "dls_dead_local_increment_in_return": "DLS: 戻り値のステートメントで無駄なインクリメント\nこのステートメントにはreturn x++; / return x--;のような記述があります。後置インクリメント/デクリメントは式の値に影響を与えないため、このインクリメント/デクリメントは効果がありません。このステートメントが正しいことを確認してください。\n\nCWE-563: 使用されない変数への代入を参照してください。",
      "dls_dead_store_of_class_literal": "DLS: クラスリテラルの死んだストア\nこの命令は、クラスリテラルを変数に代入し、その後それを使用しません。この動作はJava 1.4とJava 5で異なります。Java 1.4以前では、Foo.classへの参照はFooの静的初期化子を実行させますが、Java 5以降では実行されません。\n\n詳細と例については、OracleのJava SE互換性に関する記事を参照してください。また、Java 5以降でクラス初期化を強制する方法についても参照してください。\n\nCWE-563: 使用されない変数への代入を参照してください。",
      "ip_parameter_is_dead_but_overwritten": "IP: メソッドに入るときにパラメータが無効であるが上書きされる\nこのパラメータの初期値は無視され、ここでパラメータが上書きされます。これは、パラメータへの書き込みが呼び出し元に戻されるという誤解を示すことがよくあります。\n\nCWE-563: 使用されない変数への代入を参照してください。",
      "mf_method_masks_field": "MF: メソッドがフィールドを隠す変数を定義している\nこのメソッドは、クラスまたはスーパークラス内のフィールドと同じ名前のローカル変数を定義しています。これにより、メソッドがフィールドから初期化されていない値を読み取ったり、フィールドが初期化されていないままだったりする可能性があります。",
      "mf_class_masks_field": "MF: クラスがスーパークラスのフィールドを隠すフィールドを定義している\nこのクラスは、スーパークラスの可視インスタンスフィールドと同じ名前のフィールドを定義しています。これにより混乱が生じ、メソッドが1つのフィールドを更新またはアクセスする際に他のフィールドを対象としている場合、エラーを示すことがあります。",
      "fe_test_if_equal_to_not_a_number": "FE: NaNとの等価性を確認する無駄なテスト\nこのコードは、浮動小数点値が特別なNot A Number値（例：if (x == Double.NaN)）と等しいかどうかを確認します。しかし、NaNの特別な意味により、どの値もNaNと等しくなく、NaNも含まれます。したがって、x == Double.NaNは常にfalseに評価されます。xに含まれる値が特別なNot A Number値であるかどうかを確認するには、Double.isNaN(x)（またはxが浮動小数点精度の場合、Float.isNaN(x)）を使用してください。\n\nCWE-570: 式は常に偽であるを参照してください。",
      "icast_int_2_long_as_instant": "ICAST: int値をlongに変換して絶対時間として使用\nこのコードは、32ビットのint値を64ビットのlong値に変換し、その値を絶対時間値を必要とするメソッドのパラメータとして渡します。絶対時間値は、基準時刻である「エポック」からのミリ秒数、すなわち1970年1月1日00:00:00 GMTからの時間です。例えば、次のメソッドは、エポックからの秒数をDateに変換することを目的としていますが、誤っています：\n\nDate getDate(int seconds) { return new Date(seconds * 1000); }\n乗算は32ビット算術を使用して行われ、その後64ビット値に変換されます。32ビットの値が64ビットに変換されて絶対時間値を表現する場合、1969年12月と1970年1月の日付のみが表現できます。\n\n上記メソッドの正しい実装は次の通りです：\n\n// 2037年以降の日付には失敗\nDate getDate(int seconds) { return new Date(seconds * 1000L); }\n\n// より良い、すべての日付で動作\nDate getDate(long seconds) { return new Date(seconds * 1000); }\nCWE-192: 整数強制エラーを参照してください。",
      "icast_int_cast_to_double_passed_to_ceil": "ICAST: 整数値をdoubleにキャストしてからMath.ceilに渡す\nこのコードは、整数値（例：intまたはlong）を倍精度浮動小数点数に変換し、その結果をMath.ceil()関数に渡します。Math.ceil()はdoubleを次の整数に切り上げる関数です。この操作は常に無操作（no-op）であるべきです。整数をdoubleに変換すると小数部分がない数値になるためです。この値をMath.ceilに渡すために生成された操作は、倍精度浮動小数点算術を使用して実行されることを意図していた可能性があります。\n\nCWE-192: 整数強制エラーを参照してください。",
      "icast_int_cast_to_float_passed_to_round": "ICAST: int値をfloatにキャストしてからMath.roundに渡す\nこのコードは、int値をfloat精度の浮動小数点数に変換し、その結果をMath.round()関数に渡します。この関数は引数に最も近いint/longを返します。この操作は常に無操作（no-op）であるべきです。整数をfloatに変換すると小数部分がない数値になるためです。値をMath.roundに渡すために生成された操作は、浮動小数点算術を使用して実行されることを意図していた可能性があります。\n\nCWE-192: 整数強制エラーを参照してください。",
      "np_null_instanceof": "NP: 知っているnull値が型のインスタンスかどうかがチェックされる\nこのinstanceofテストは常にfalseを返します。なぜなら、チェックされる値がnullであることが保証されているからです。これは安全ですが、何か誤解や他の論理エラーの兆候でないことを確認してください。",
      "dmi_long_bits_to_double_invoked_on_int": "DMI: Double.longBitsToDoubleがintに対して呼び出される\nDouble.longBitsToDoubleメソッドが呼び出されていますが、32ビットのint値が引数として渡されています。これはほぼ確実に意図されたものではなく、意図した結果を得ることはないでしょう。",
      "bc_impossible_cast": "BC: 不可能なキャスト\nこのキャストは常にClassCastExceptionをスローします。SpotBugsはinstanceofチェックから型情報を追跡し、メソッドから返される値やフィールドから読み込まれる値の型に関するより正確な情報も使用します。したがって、変数の宣言された型だけでなく、より正確な情報を持っており、この情報を使用してキャストが実行時に常に例外をスローすることを判断できます。\n\nCWE-704: 不正確な型変換またはキャストを参照してください。",
      "bc_impossible_downcast": "BC: 不可能なダウンキャスト\nこのキャストは常にClassCastExceptionをスローします。解析はキャストされる値の正確な型を知っており、サブタイプにダウンキャストしようとすると常にClassCastExceptionをスローします。\n\nCWE-704: 不正確な型変換またはキャストを参照してください。",
      "bc_impossible_downcast_of_toarray": "BC: toArray()結果の不可能なダウンキャスト\nこのコードは、コレクションのtoArray()を呼び出した結果をObject[]よりも具体的な型にキャストしています。例えば：\n\nString[] getAsArray(Collection c) {\n    return (String[]) c.toArray();\n}\nこれは通常、ClassCastExceptionをスローして失敗します。ほとんどすべてのコレクションのtoArray()はObject[]を返します。それ以外のことはできません。なぜなら、Collectionオブジェクトにはコレクションの宣言されたジェネリック型への参照がないからです。\n\nコレクションから特定の型の配列を取得する正しい方法は、c.toArray(new String[0]); または c.toArray(new String[c.size()]); を使用することです（前者はJava 6以降の更新でわずかに効率的です）。\n\nこの点についてよく知られた例外があります。Arrays.asList(...)によって返されるリストのtoArray()メソッドは、共変的な型の配列を返します。例えば、Arrays.asList(new String[] { 'a' }).toArray()はString[]を返します。SpotBugsはこのようなケースを検出して抑制しようとしますが、いくつかを見逃す場合があります。\n\nCWE-704: 不正確な型変換またはキャストを参照してください。",
      "bc_impossible_instanceof": "BC: instanceofは常にfalseを返す\nこのinstanceofテストは常にfalseを返します。これは安全ですが、何か誤解や他の論理エラーの兆候でないことを確認してください。",
      "re_possible_unintended_pattern": "RE: “.” または “",
      "re_bad_syntax_for_regular_expression": "RE: 正規表現の構文エラー\nこのコードは、正規表現の構文に従っていない正規表現を使用しています。この文は、実行時に PatternSyntaxException をスローします。\n\nCWE-185: 不正確な正規表現を参照してください。",
      "re_cant_use_file_separator_as_regular_expression": "RE: 正規表現に File.separator が使用されている\nこのコードは、正規表現が必要な箇所で File.separator を使用しています。Windowsプラットフォームでは、File.separator がバックスラッシュであり、これは正規表現ではエスケープ文字として解釈されるため、失敗します。代わりに、File.separatorChar=='\\' ? '\\' : File.separator を使用することを検討してください。\n\nCWE-185: 不正確な正規表現を参照してください。",
      "dls_overwritten_increment": "DLS: 上書きされたインクリメント\nこのコードはインクリメント/デクリメント操作（例: i++ / i--）を実行し、その後すぐに上書きします。例えば、i = i++ / i = i-- は、インクリメント/デクリメントされた値を元の値で上書きします。\n\nCWE-563: 変数への割り当て（未使用）を参照してください。",
      "icast_bad_shift_amount": "BSHIFT: -31..31 の範囲外でシフトされた32ビットのint\nこのコードは、32ビットのintを-31..31の範囲外で定数の量だけシフトします。これにより、整数値の下位5ビットがどれだけシフトするかを決定することになります（例えば、40ビットシフトは8ビットシフトと同じ、32ビットシフトはゼロビットシフトと同じ）。これはおそらく予期しない結果であり、少なくとも混乱を招く可能性があります。",
      "bshift_wrong_add_priority": "BSHIFT: シフト操作の誤った解析の可能性\nこのコードは (x << 8 + y) のような操作を行います。これが正しい場合もありますが、実際には (x << 8) + y を行いたかった可能性があります。しかし、シフト操作は優先順位が低いため、実際には x << (8 + y) と解析されます。",
      "im_multiplying_result_of_irem": "IM: 整数の余りの結果を整数定数で乗算\nこのコードは、整数の余りの結果を整数定数で乗算します。演算子の優先順位に混乱しないようにしてください。例えば、i % 60 * 1000 は (i % 60) * 1000 であり、i % (60 * 1000) ではありません。",
      "dmi_invoking_hashcode_on_array": "DMI: 配列に対する hashCode の呼び出し\nこのコードは、配列に対して hashCode を呼び出しています。配列に対して hashCode を呼び出すと、System.identityHashCode と同じ値が返され、配列の内容や長さは無視されます。配列の内容に依存する hashCode が必要な場合は、java.util.Arrays.hashCode(a) を使用してください。",
      "dmi_invoking_tostring_on_array": "USELESS_STRING: 配列に対する toString の呼び出し\nこのコードは、配列に対して toString を呼び出しており、[C@16f0472 のようなあまり有用でない結果が生成されます。配列を読みやすい文字列に変換するためには、Arrays.toString を使用することを検討してください。Programming Puzzlers、第3章、パズル12を参照してください。",
      "dmi_invoking_tostring_on_anonymous_array": "USELESS_STRING: 名前のない配列に対する toString の呼び出し\nこのコードは、（匿名の）配列に対して toString を呼び出しています。配列に対して toString を呼び出すと、[C@16f0472 のようなあまり有用でない結果が生成されます。配列を読みやすい文字列に変換するためには、Arrays.toString を使用することを検討してください。Programming Puzzlers、第3章、パズル12を参照してください。",
      "dmi_bad_month": "DMI: 月に対する不正な定数値\nこのコードは、期待される0..11の範囲外の定数の月値をメソッドに渡しています。",
      "dmi_calling_next_from_hasnext": "DMI: hasNext メソッドが next を呼び出す\nhasNext() メソッドが next() メソッドを呼び出します。これはほぼ間違いであり、hasNext() メソッドはイテレータの状態を変更するべきではなく、next メソッドがイテレータの状態を変更するべきです。",
      "qba_questionable_boolean_assignment": "QBA: メソッドがブール式内でブールリテラルを代入する\nこのメソッドは、if や while の式内でブール変数にブールリテラル（true または false）を代入します。おそらく、これは比較演算子 == を使ってブール値を比較する意図であり、代入演算子 = を使って代入するべきではありません。\n\nCWE-481: 比較ではなく代入を参照してください。",
      "gc_unrelated_types": "GC: ジェネリックパラメータとメソッド引数との間に関係がない\nこのジェネリックコレクションメソッドの呼び出しは、コレクションのパラメータのクラスと互換性のない引数を含んでいます（つまり、引数の型は対応するジェネリック型引数のスーパークラスでもサブクラスでもありません）。そのため、コレクションがここで使用されているメソッド引数と等しいオブジェクトを含んでいる可能性は低いです。おそらく、誤った値がメソッドに渡されています。\n\n一般的に、関係のない2つのクラスのインスタンスは等しくありません。例えば、FooクラスとBarクラスがサブタイプでない場合、FooのインスタンスはBarのインスタンスと等しくないべきです。他の問題として、これを行うとequalsメソッドが非対称になる可能性があります。例えば、Fooクラスを定義してFooがStringと等しい場合、equalsメソッドは対称でなくなります。なぜなら、StringはStringとしか等しくないからです。\n\n稀に、非対称なequalsメソッドを定義し、コードがうまく動作する場合もあります。ほとんどのAPIはそれを文書化したり保証したりしませんが、通常、コレクションにFooが含まれているかどうかを確認する場合、引数（例えば、Fooクラスのequalsメソッド）を使用して等価性チェックが行われます。",
      "dmi_vacuous_self_collection_call": "DMI: 無意味なコレクションの呼び出し\nこの呼び出しは意味がありません。任意のコレクション c に対して、c.containsAll(c) は常に true であり、c.retainAll(c) は何の効果もありません。",
      "dmi_doh": "DMI: ばか！意味のないメソッド呼び出し\nこの特定のメソッド呼び出しは、検査すれば明らかに意味がありません。",
      "dmi_collections_should_not_contain_themselves": "DMI: コレクションは自分自身を含んではいけません\nこのジェネリックコレクションのメソッドの呼び出しは、コレクションが自分自身を含む場合（例えば、s.contains(s) が true であれば）にのみ意味があります。これは真である可能性は低く、もし真であれば問題が発生する可能性があります（例えば、ハッシュコードの計算が無限再帰に陥るなど）。おそらく、誤った値がパラメータとして渡されています。",
      "tq_unknown_value_used_where_always_strictly_required": "TQ: 型修飾子が必要な場所で型修飾子なしの値が使用されています\n値が型修飾子で注釈を付ける必要がある方法で使用されています。型修飾子は厳格であるため、ツールは適切な注釈がない値を拒否します。\n\n値に厳格な注釈を強制するには、戻り値が厳格な注釈で注釈付けされた恒等関数を定義してください。これは、非注釈付きの値を厳格な型修飾子の注釈を持つ値に変換する唯一の方法です。",
      "tq_comparing_values_with_incompatible_type_qualifiers": "TQ: 互換性のない型修飾子を持つ値を比較しています\n型修飾子の注釈が付けられた値が、決してその修飾子を持たない値と比較されています。\n\nより正確には、when=ALWAYS を指定する型修飾子で注釈付けされた値が、when=NEVER を指定する同じ型修飾子を持つ値と比較されます。\n\n例えば、@NonNegative が型修飾子注釈 @Negative(when=When.NEVER) のニックネームだとしましょう。次のコードは警告を生成します。なぜなら、戻り値には @NonNegative 値が必要で、実際には @Negative としてマークされた値を受け取っているからです。\n\npublic boolean example(@Negative Integer value1, @NonNegative Integer value2) {\n    return value1.equals(value2);\n}",
      "tq_always_value_used_where_never_required": "TQ: 型修飾子を持つと注釈された値が、型修飾子を持たない値を必要とする場所で使用されています\n型修飾子の注釈を持つ値が、注釈がないことが要求される場所で消費されています。\n\nより正確には、when=ALWAYS を指定する型修飾子で注釈付けされた値が、同じ型修飾子が when=NEVER を指定する使い方に必ず到達します。\n\n例えば、@NonNegative が型修飾子注釈 @Negative(when=When.NEVER) のニックネームだとしましょう。次のコードは警告を生成します。なぜなら、戻り値には @NonNegative 値が必要で、実際には @Negative としてマークされた値を受け取っているからです。\n\npublic @NonNegative Integer example(@Negative Integer value) {\n    return value;\n}",
      "tq_never_value_used_where_always_required": "TQ: 型修飾子を決して持たないと注釈された値が、型修飾子を持つ値を必要とする場所で使用されています\n型修飾子を持たないと指定された値が、型修飾子を持つ値が必要とされる場所で消費されることが保証されています。\n\nより正確には、when=NEVER を指定する型修飾子で注釈付けされた値が、同じ型修飾子が when=ALWAYS を指定する使い方に必ず到達します。\n\nTODO: 例",
      "tq_maybe_source_value_reaches_always_sink": "TQ: 型修飾子を持たない可能性がある値が常にその型修飾子を必要とする方法で使用されています\n型修飾子で示される値のインスタンスでない可能性がある値が、その型修飾子で示される値を必要とする方法で常に使用されています。",
      "tq_maybe_source_value_reaches_never_sink": "TQ: 型修飾子を持つ可能性がある値が、常にその型修飾子を持つことを禁止する方法で使用されています\n型修飾子で示される値のインスタンスである可能性がある値が、その型修飾子で示される値を持つことを禁止する方法で常に使用されています。",
      "fb_unexpected_warning": "FB: SpotBugs から予期しない/望ましくない警告\nSpotBugs は、@NoWarning 注釈に従って、予期しないまたは望ましくない警告を生成しました。",
      "fb_missing_expected_warning": "FB: SpotBugs から予期されたまたは望ましい警告が欠落しています\nSpotBugs は、@ExpectedWarning 注釈に従って、予期されたまたは望ましい警告を生成しませんでした。",
      "eos_bad_end_of_stream_check": "EOS: 比較の前に読み取ったデータが-1に変換されています\njava.io.FileInputStream.read() メソッドは int を返します。この int が byte に変換されると、-1（EOFを示す）とバイト 0xFF が区別できなくなり、-1 と比較すると、0xFF の文字が出現した場合、読み取りが早期に終了してしまいます。同様に、java.io.FileReader.read() メソッドも int を返します。これが char に変換されると、-1 は 0xFFFF になり、Character.MAX_VALUE となります。結果を -1 と比較するのは無意味です。なぜなら、Java では文字が符号なしだからです。もし EOF のチェックがループの条件であれば、そのループは無限ループになります。\n\nSEI CERT ルール FIO08-J を参照してください。ストリームから読み取った文字またはバイトと -1 を区別してください。",
      "fl_floats_as_loop_counters": "FL: ループカウンターとして浮動小数点変数を使用しない\n浮動小数点変数は精度が低いため、ループカウンターとして使用するべきではありません。これにより誤ったループが発生する可能性があります。ループカウンターは各反復で変更され、ループが終了すべきタイミングを制御します。反復ごとに固定の量だけ増減します。\n\nルール NUM09-J と CWE-1339: 実数の精度または精密度が不足しているを参照してください。",
      "sing_singleton_implements_cloneable": "SING: シングルトンデザインパターンを使用しているクラスが Cloneable インターフェースを直接実装しています\nシングルトンデザインパターンを使用しているクラスが Cloneable インターフェースを直接実装している場合、オブジェクトのコピーを作成することが可能になり、シングルトンパターンが破られることになります。\nしたがって、Cloneable インターフェースの実装は避けるべきです。\n\n詳細については、SEI CERT MSC07-J、および CWE-543: マルチスレッド環境でのシングルトンパターンの同期なしの使用を参照してください。",
      "sing_singleton_indirectly_implements_cloneable": "SING: シングルトンデザインパターンを使用しているクラスが Cloneable インターフェースを間接的に実装しています\nシングルトンデザインパターンを使用しているクラスが Cloneable インターフェースを間接的に実装している場合、オブジェクトのコピーを作成することが可能になり、シングルトンパターンが破られることになります。\nしたがって、Cloneable インターフェースの実装は避けるべきです。もし、拡張されたスーパークラスのためにそれが不可能であれば、解決策は clone メソッドをオーバーライドして CloneNotSupportedException を無条件にスローさせることです。\n\n詳細については、SEI CERT MSC07-J、および CWE-543: マルチスレッド環境でのシングルトンパターンの同期なしの使用を参照してください。",
      "sing_singleton_implements_clone_method": "SING: シングルトンデザインパターンを使用しているクラスが clone() メソッドを実装しており、無条件で CloneNotSupportedException をスローしていません\nこのクラスはシングルトンデザインパターンを使用しており、Cloneable インターフェースは実装していませんが、clone() メソッドを実装しています。ただし、このメソッドは無条件で CloneNotSupportedException をスローしません。これにより、オブジェクトのコピーを作成することが可能になり、シングルトンパターンが破られることになります。\nしたがって、clone メソッドの実装は避けるべきです。そうでない場合は、clone メソッドをオーバーライドして無条件に CloneNotSupportedException をスローさせることが解決策となります。\n\n詳細については、SEI CERT MSC07-J、および CWE-543: マルチスレッド環境でのシングルトンパターンの同期なしの使用を参照してください。",
      "sing_singleton_has_nonprivate_constructor": "SING: シングルトンデザインパターンを使用しているクラスに非プライベートコンストラクタがあります。\nこのクラスはシングルトンデザインパターンを使用しており、非プライベートコンストラクタを持っています（デフォルトコンストラクタが存在する場合でも、それがプライベートでないことに注意してください）。このため、オブジェクトのコピーを作成することが可能になり、シングルトンパターンが破られます。\n解決策としては、コンストラクタをプライベートにすることが簡単です。\n\n詳細については、SEI CERT MSC07-J および CWE-543: マルチスレッド環境でのシングルトンパターンの同期なしの使用を参照してください。",
      "sing_singleton_implements_serializable": "SING: シングルトンデザインパターンを使用しているクラスが直接的または間接的に Serializable インターフェースを実装しています。\nこのクラス（シングルトンデザインパターンを使用している）は、Serializable インターフェースを直接的または間接的に実装しており、これによりクラスはシリアライズ可能になります。\nデシリアライズによりシングルトンクラスの複数インスタンス化が可能となるため、これを避けるべきです。\n\n詳細については、SEI CERT MSC07-J および CWE-543: マルチスレッド環境でのシングルトンパターンの同期なしの使用を参照してください。",
      "sing_singleton_getter_not_synchronized": "SING: シングルトンデザインパターンを使用しているクラスのインスタンス取得メソッドが同期されていません。\nシングルトンデザインパターンを使用しているクラスのインスタンス取得メソッドが同期されていないため、複数のスレッドが同時にこのメソッドを呼び出すと、シングルトンクラスが複数インスタンス化される可能性があります。\n\n詳細については、SEI CERT MSC07-J および CWE-543: マルチスレッド環境でのシングルトンパターンの同期なしの使用を参照してください。",
      "hsm_hiding_method": "HSM: メソッド隠蔽は避けるべきです。\nメソッド隠蔽は、サブクラスが親クラスのいずれかと同じヘッダー（署名および戻り値の型）を持つ静的メソッドを定義する場合に発生します。メソッド隠蔽が発生した場合、呼び出し元で使用された特定の修飾名またはメソッド呼び出し式に基づいて呼び出されるメソッドが決まります。結果は予期しないことが多いですが、Java 言語はメソッド隠蔽に対する明確なルールを提供しています。さらに、メソッド隠蔽とメソッドオーバーライドはしばしば混同されます。したがって、プログラマーはメソッド隠蔽を避けるべきです。該当するメソッドを非静的として宣言するか、プライベートとして制限することで問題を解決できます。\nSEI CERT ルール MET07-J を参照してください。スーパークラスまたはスーパインターフェースで宣言されたメソッドを隠蔽するクラスメソッドを宣言してはなりません。",
      "skipped_class_too_big": "SKIPPED: 分析するにはクラスが大きすぎます\nこのクラスは効果的に処理できるサイズを超えており、エラーの完全な分析は行われていません。",
      "unknown": "TEST: 不明なバグパターン\n警告が記録されましたが、SpotBugs はこのバグパターンの説明を見つけられないため、説明できません。これは、SpotBugs またはその設定にバグがある場合、またはプラグインを使用して分析が生成されたが、そのプラグインが現在読み込まれていない場合にのみ発生するはずです。",
      "testing": "TEST: テスト\nこのバグパターンは新しい、未実装のバグ検出ツールによってのみ生成されます。",
      "testing1": "TEST: テスト 1\nこのバグパターンは新しい、未実装のバグ検出ツールによってのみ生成されます。",
      "testing2": "TEST: テスト 2\nこのバグパターンは新しい、未実装のバグ検出ツールによってのみ生成されます。",
      "testing3": "TEST: テスト 3\nこのバグパターンは新しい、未実装のバグ検出ツールによってのみ生成されます。",
      "obl_unsatisfied_obligation": "OBL: メソッドがストリームやリソースのクリーンアップに失敗する可能性がある\nこのメソッドは、ストリーム、データベースオブジェクト、または明示的なクリーンアップ操作が必要な他のリソースをクリーンアップ（閉じる、処理する）できない可能性があります。\n\n一般的に、メソッドがストリームや他のリソースを開く場合、そのメソッドはtry/finallyブロックを使用して、メソッドが返される前にストリームやリソースがクリーンアップされることを確実にすべきです。\n\nこのバグパターンは、OS_OPEN_STREAMおよびODR_OPEN_DATABASE_RESOURCEのバグパターンと実質的に同じですが、異なる（そしておそらくより良い）静的解析技法に基づいています。このバグパターンの有用性に関するフィードバックを受け取りたいと考えています。フィードバックを送信するには、次を確認してください：\n\n貢献ガイドライン\nメーリングリスト\n特に、このバグパターンの偽陽性抑制ヒューリスティックは十分に調整されていないため、偽陽性に関する報告は非常に役立ちます。\n\nWeimerとNeculaによる「実行時エラーハンドリングミスの発見と防止」（PDF）を参照して、解析技法の説明を確認してください。",
      "obl_unsatisfied_obligation_exception_edge": "OBL: チェック例外でストリームやリソースのクリーンアップに失敗する可能性があるメソッド\nこのメソッドは、チェック例外が発生した場合に、ストリーム、データベースオブジェクト、または明示的なクリーンアップ操作が必要な他のリソースをクリーンアップ（閉じる、処理する）できない可能性があります。\n\n一般的に、メソッドがストリームや他のリソースを開く場合、そのメソッドはtry/finallyブロックを使用して、メソッドが返される前にストリームやリソースがクリーンアップされることを確実にすべきです。\n\nこのバグパターンは、OS_OPEN_STREAMおよびODR_OPEN_DATABASE_RESOURCEのバグパターンと実質的に同じですが、異なる（そしておそらくより良い）静的解析技法に基づいています。このバグパターンの有用性に関するフィードバックを受け取りたいと考えています。フィードバックを送信するには、次を確認してください：\n\n貢献ガイドライン\nメーリングリスト\n特に、このバグパターンの偽陽性抑制ヒューリスティックは十分に調整されていないため、偽陽性に関する報告は非常に役立ちます。\n\nWeimerとNeculaによる「実行時エラーハンドリングミスの発見と防止」（PDF）を参照して、解析技法の説明を確認してください。",
      "lg_lost_logger_due_to_weak_reference": "LG: OpenJDKによる弱い参照によるロガー変更の損失の可能性\nOpenJDKは潜在的な互換性の問題を導入します。特に、java.util.logging.Loggerの挙動が変更されました。強い参照を使用する代わりに、内部で弱い参照を使用するようになりました。この変更は合理的ですが、残念ながら、古い挙動に依存しているコードもあります。ロガー設定を変更すると、単にロガー参照が破棄されるため、ガベージコレクタがそのメモリを解放でき、ロガー設定が失われます。例えば、以下のコードを考えてみましょう：\n\npublic static void initLogging() throws Exception {\n    Logger logger = Logger.getLogger('edu.umd.cs');\n    logger.addHandler(new FileHandler()); // ロガー設定の変更を呼び出す\n    logger.setUseParentHandlers(false); // もう一つのロガー設定の変更を呼び出す\n}\nメソッドの最後でロガー参照が失われる（メソッドを抜けないため）、initLogging呼び出し直後にガベージコレクションが発生すると、ロガー設定が失われます（Loggerは弱い参照しか保持していないため）。\n\npublic static void main(String[] args) throws Exception {\n    initLogging(); // ロガーにファイルハンドラを追加\n    System.gc(); // ロガー設定が失われる\n    Logger.getLogger('edu.umd.cs').info('Some message'); // 期待通り、ファイルにはログされません\n}\nUlf Ochsenfahrt と Eric Fellheimerによる",
      "dm_convert_case": "Dm: 呼び出されたメソッドのロケールパラメータを使用することを検討してください\n文字列がプラットフォームのデフォルトエンコーディングを使用して大文字または小文字に変換されています。これにより、国際文字を使用した場合に不適切な変換が発生する可能性があります。代わりに次のメソッドを使用してください：\n\nString.toUpperCase( Locale l )\nString.toLowerCase( Locale l )",
      "dm_default_encoding": "Dm: デフォルトエンコーディングに依存\nデフォルトプラットフォームエンコーディングが適切であると仮定して、バイトから文字列（または文字列からバイト）への変換を実行するメソッドの呼び出しが見つかりました。これにより、プラットフォーム間でアプリケーションの動作が異なる可能性があります。代わりに別のAPIを使用し、文字セット名またはCharsetオブジェクトを明示的に指定してください。\n\nCWE-173: 不適切な代替エンコーディングの処理を参照。",
      "dp_do_inside_do_privileged": "DP: doPrivilegedブロック内でのみ呼び出されるべきメソッドを呼び出しました\nこのコードは、セキュリティ権限チェックを必要とするメソッドを呼び出します。このコードにセキュリティ権限が付与されている場合でも、セキュリティ権限がないコードによって呼び出される可能性がある場合は、呼び出しはdoPrivilegedブロック内で行う必要があります。\n\njava.security.AccessControllerクラスは、Java 17で非推奨（JEP 411）となり、Java 24で削除されました（JEP 486を参照）。そのため、このバグはJava 17以降のターゲットクラスでは報告されません。\nCWE-266: 不正な特権の割り当てを参照。",
      "dp_create_classloader_inside_do_privileged": "DP: クラスローダーはdoPrivilegedブロック内でのみ作成されるべきです\nこのコードは、セキュリティマネージャーがインストールされている場合に権限が必要なクラスローダーを作成します。このコードがセキュリティ権限を持たないコードによって呼び出される可能性がある場合、クラスローダーの作成はdoPrivilegedブロック内で行う必要があります。\n\njava.security.AccessControllerクラスは、Java 17で非推奨（JEP 411）となり、Java 24で削除されました（JEP 486を参照）。そのため、このバグはJava 17以降のターゲットクラスでは報告されません。\nCWE-266: 不正な特権の割り当てを参照。",
      "fi_public_should_be_protected": "FI: ファイナライザーはpublicではなくprotectedであるべきです\nクラスのfinalize()メソッドはpublicではなくprotectedであるべきです。\n\nCWE-583: finalize()メソッドがpublicとして宣言されているを参照。",
      "ms_expose_rep": "MS: パブリックな静的メソッドが変更可能なオブジェクトや配列を返すことによって内部表現を公開する可能性がある\nパブリックな静的メソッドが、クラスの静的状態の一部である変更可能なオブジェクトや配列への参照を返します。このメソッドを呼び出すコードは、自由に基盤となる配列を変更できます。修正方法としては、配列のコピーを返すことです。",
      "ms_expose_buf": "MS: 非公開データを共有するバッファを返すことによって内部表現を公開する可能性がある\nパブリックな静的メソッドが、クラスの静的状態の一部である配列を保持するバッファ（java.nio.*Buffer）を返すか、静的状態の一部であり、元のバッファと参照を共有するバッファの浅いコピーを返します。このメソッドを呼び出すコードは、自由に基盤となる配列を変更できます。修正方法としては、読み取り専用バッファまたは配列のコピーを持つ新しいバッファを返すことです。",
      "ei_expose_rep": "EI: 変更可能なオブジェクトへの参照を返すことによって内部表現を公開する可能性がある\nオブジェクトのフィールドに保存されている変更可能なオブジェクトの参照を返すことは、オブジェクトの内部表現を公開します。信頼できないコードがインスタンスにアクセスし、変更可能なオブジェクトへの未確認の変更がセキュリティや他の重要な特性を危険にさらす場合は、別の方法を取る必要があります。オブジェクトの新しいコピーを返すことが、状況によってはより良いアプローチです。\n\nCWE-374: 信頼できないメソッドに変更可能なオブジェクトを渡すを参照。",
      "ei_expose_buf": "EI: 非公開データを共有するバッファを返すことによって内部表現を公開する可能性がある\nオブジェクトのフィールドに保存されている配列をラップするバッファ（java.nio.*Buffer）の参照を返すことは、配列要素の内部表現を公開します。これは、バッファが配列をコピーするのではなく、配列への参照のみを保持するためです。同様に、そのようなバッファの浅いコピー（duplicate()メソッドを使用）を返すことも、バッファの内部表現を公開します。信頼できないコードがインスタンスにアクセスし、配列への未確認の変更がセキュリティや他の重要な特性を危険にさらす場合は、別の方法を取る必要があります。読み取り専用バッファ（asReadOnly()メソッドを使用）を返すか、配列を新しいバッファにコピーする（put()メソッドを使用）ことが、状況によってはより良いアプローチです。\n\nCWE-374: 信頼できないメソッドに変更可能なオブジェクトを渡すを参照。",
      "ei_expose_rep2": "EI2: 変更可能なオブジェクトの参照を取り込むことによって内部表現を公開する可能性がある\nこのコードは、外部の変更可能なオブジェクトへの参照をオブジェクトの内部表現に保存します。信頼できないコードがインスタンスにアクセスし、変更可能なオブジェクトへの未確認の変更がセキュリティや他の重要な特性を危険にさらす場合は、別の方法を取る必要があります。オブジェクトのコピーを保存することが、状況によってはより良いアプローチです。\n\nCWE-374: 信頼できないメソッドに変更可能なオブジェクトを渡すを参照。",
      "ei_expose_static_rep2": "MS: 変更可能なオブジェクトを静的フィールドに保存することによって内部静的状態を公開する可能性がある\nこのコードは、外部の変更可能なオブジェクトへの参照を静的フィールドに保存します。変更可能なオブジェクトへの未確認の変更がセキュリティや他の重要な特性を危険にさらす場合は、別の方法を取る必要があります。オブジェクトのコピーを保存することが、状況によってはより良いアプローチです。",
      "ei_expose_buf2": "EI2: 配列への参照を取り込んだバッファを作成することによって内部表現を公開する可能性がある\nこのコードは、外部配列または外部バッファの配列への参照をオブジェクトの内部表現に保存するバッファを作成します。信頼できないコードがインスタンスにアクセスし、配列への未確認の変更がセキュリティや他の重要な特性を危険にさらす場合は、別の方法を取る必要があります。配列のコピーを保存することが、状況によってはより良いアプローチです。\n\nCWE-374: 信頼できないメソッドに変更可能なオブジェクトを渡すを参照。",
      "ei_expose_static_buf2": "MS: 配列を静的フィールドに保存するバッファを作成することによって内部静的状態を公開する可能性がある\nこのコードは、外部配列または外部バッファの配列への参照を静的フィールドに保存するバッファを作成します。配列への未確認の変更がセキュリティや他の重要な特性を危険にさらす場合は、別の方法を取る必要があります。配列のコピーを保存することが、状況によってはより良いアプローチです。",
      "ms_ooi_pkgprotect": "MS: フィールドはインターフェースから移動し、パッケージ保護されるべき\nインターフェースで定義されたfinal staticフィールドが、配列やハッシュテーブルなどの変更可能なオブジェクトを参照しています。この変更可能なオブジェクトは、悪意のあるコードや他のパッケージからの偶発的な変更によって変更される可能性があります。この問題を解決するためには、フィールドをクラスに移動し、パッケージ保護にする必要があります。",
      "ms_final_pkgprotect": "MS: フィールドはfinalかつパッケージ保護されるべき\n変更可能なstaticフィールドは、悪意のあるコードや他のパッケージからの偶発的な変更によって変更される可能性があります。フィールドはパッケージ保護にするか、finalにすることでこの脆弱性を避けることができます。",
      "ms_should_be_final": "MS: フィールドはfinalであるべきだが、現在はfinalではない\nこのpublic staticまたはprotected staticフィールドはfinalではなく、悪意のあるコードや他のパッケージからの偶発的な変更によって変更される可能性があります。フィールドをfinalにすることでこの脆弱性を避けることができます。\n\nCWE-500: Public Static Field Not Marked Finalを参照。",
      "ms_should_be_refactored_to_be_final": "MS: フィールドはfinalではないが、finalにするようリファクタリングすべき\nこのpublic staticまたはprotected staticフィールドはfinalではなく、悪意のあるコードや他のパッケージからの偶発的な変更によって変更される可能性があります。フィールドをfinalにすることでこの脆弱性を避けることができます。しかし、staticイニシャライザにフィールドへの複数の書き込みが含まれているため、これを行うにはリファクタリングが必要です。\n\nCWE-500: Public Static Field Not Marked Finalを参照。",
      "ms_pkgprotect": "MS: フィールドはパッケージ保護されるべき\n変更可能なstaticフィールドは、悪意のあるコードや偶発的に変更される可能性があります。フィールドをパッケージ保護にすることでこの脆弱性を避けることができます。\n\nCWE-607: Public Static Final Field References Mutable Objectを参照。",
      "ms_mutable_hashtable": "MS: フィールドは変更可能なハッシュテーブル\nfinal staticフィールドはハッシュテーブルを参照しており、悪意のあるコードや他のパッケージからアクセスされる可能性があります。このコードはハッシュテーブルの内容を自由に変更できます。",
      "ms_mutable_array": "MS: フィールドは変更可能な配列\nfinal staticフィールドは配列を参照しており、悪意のあるコードや他のパッケージからアクセスされる可能性があります。このコードは配列の内容を自由に変更できます。",
      "ms_mutable_collection": "MS: フィールドは変更可能なコレクション\n変更可能なコレクションインスタンスがfinal staticフィールドに割り当てられており、悪意のあるコードや他のパッケージから変更される可能性があります。この脆弱性を避けるために、このフィールドをCollections.unmodifiableSet/List/Map/etc.でラップすることを検討してください。",
      "ms_mutable_collection_pkgprotect": "MS: フィールドは変更可能なコレクションであり、パッケージ保護されるべき\n変更可能なコレクションインスタンスがfinal staticフィールドに割り当てられており、悪意のあるコードや他のパッケージから変更される可能性があります。フィールドはパッケージ保護にすることができます。または、このフィールドをCollections.unmodifiableSet/List/Map/etc.でラップして、この脆弱性を避けることもできます。",
      "ms_cannot_be_final": "MS: フィールドはfinalではなく、悪意のあるコードから保護できない\n変更可能なstaticフィールドは、悪意のあるコードや他のパッケージからの偶発的な変更によって変更される可能性があります。残念ながら、このフィールドの使用方法では、この問題を簡単に修正することはできません。",
      "reflc_reflection_may_increase_accessibility_of_class": "REFLC: パブリックメソッドがパラメータで受け取ったクラスを作成するためにリフレクションを使用し、任意のクラスのアクセス可能性を高める可能性がある\nSEI CERT SEC05-Jルールは、リフレクションを使用してクラス、メソッド、またはフィールドのアクセス可能性を高めることを禁じています。パッケージ内のクラスがjava.lang.Classのインスタンスをパラメータとして受け取り、そのnewInstance()メソッドを呼び出すパブリックメソッドを提供する場合、パブリックコンストラクタを持たないクラスのアクセス可能性が高まります。攻撃者のコードはこのメソッドを呼び出し、そのクラスを渡してインスタンスを作成する可能性があります。この問題は、メソッドを非公開にするか、パッケージへのアクセス許可を確認することによって回避するべきです。別の方法として、java.lang.Class.newInstance()の代わりに、受け取ったClassオブジェクトにパブリックコンストラクタがあるかどうかをチェックするjava.beans.Beans.instantiate()メソッドを使用することが考えられます。\n\nCWE-470: 外部制御された入力を使用してクラスまたはコードを選択する（「危険なリフレクション」）を参照。",
      "reflf_reflection_may_increase_accessibility_of_field": "REFLF: パブリックメソッドがパラメータで受け取ったフィールドを変更するためにリフレクションを使用し、任意のクラスのアクセス可能性を高める可能性がある\nSEI CERT SEC05-Jルールは、リフレクションを使用してクラス、メソッド、またはフィールドのアクセス可能性を高めることを禁じています。パッケージ内のクラスがjava.lang.reflect.Fieldのインスタンスをパラメータとして受け取り、setterメソッド（またはsetAccessible()）を呼び出すパブリックメソッドを提供する場合、private、protected、またはパッケージプライベートなフィールドのアクセス可能性が高まります。攻撃者のコードはこのメソッドを呼び出し、そのフィールドを渡して変更する可能性があります。この問題は、メソッドを非公開にするか、パッケージへのアクセス許可を確認することによって回避するべきです。\n\nCWE-470: 外部制御された入力を使用してクラスまたはコードを選択する（「危険なリフレクション」）を参照。",
      "mc_overridable_method_call_in_constructor": "MC: コンストラクタからオーバーライド可能なメソッドが呼び出されている\nコンストラクタ内でオーバーライド可能なメソッドを呼び出すと、初期化されていないデータが使用される可能性があります。また、部分的に構築されたオブジェクトのthis参照が漏洩する可能性もあります。コンストラクタからは、static、final、またはprivateメソッドのみを呼び出すべきです。\n\nSEI CERTルールMET05-Jを参照。コンストラクタがオーバーライド可能なメソッドを呼び出さないことを確認してください。",
      "mc_overridable_method_call_in_clone": "MC: clone()メソッドからオーバーライド可能なメソッドが呼び出されている\nclone()メソッドからオーバーライド可能なメソッドを呼び出すのは安全ではありません。なぜなら、サブクラスがそのメソッドをオーバーライドする可能性があり、clone()の動作に影響を与えるからです。また、部分的に初期化された状態でcloneオブジェクトを観察または変更する可能性もあります。clone()メソッドからは、static、final、またはprivateメソッドのみを呼び出すべきです。\n\nSEI CERTルールMET06-Jを参照。clone()内でオーバーライド可能なメソッドを呼び出さないこと。",
      "mc_overridable_method_call_in_read_object": "MC: readObjectメソッドからオーバーライド可能なメソッドが呼び出されている\nreadObject()メソッドはオーバーライド可能なメソッドを呼び出してはいけません。readObject()メソッドからオーバーライド可能なメソッドを呼び出すと、オーバーライドされたメソッドがオブジェクトの状態にアクセスできるようになり、オブジェクトが完全に初期化される前にアクセスされてしまう可能性があります。この早期アクセスは、デシリアライズ中にreadObjectがオブジェクトのコンストラクタの役割を果たすため、readObjectが終了するまでオブジェクトの初期化が完了しないため可能です。\n\nSEI CERTルールSER09-Jを参照。readObject()メソッドからオーバーライド可能なメソッドを呼び出さないこと。",
      "perm_super_not_called_in_getpermissions": "PERM: カスタムクラスローダーがその親クラスのgetPermissions()を呼び出さない\nSEI CERTルールSEC07-Jは、カスタムクラスローダーは必ずそのgetPermissions()メソッド内で親クラスのgetPermissions()メソッドを呼び出し、最終的に返すオブジェクトを初期化することを要求しています。それを省略すると、このカスタムクラスローダーを使用して定義されたクラスは、システム全体のポリシーファイルに指定された権限とは完全に独立した権限を持つことになります。実際、このクラスの権限はそれらを上書きします。",
      "usc_potential_security_check_based_on_untrusted_source": "USC: 信頼できないソースに基づく潜在的なセキュリティチェック\nパブリッククラスのパブリックメソッドはパッケージ外から呼び出される可能性があり、それによって信頼できないデータが渡される可能性があります。doPrivilegedの前にメソッドを呼び出してその戻り値をチェックし、その後で同じメソッドをクラス内で呼び出すことは、メソッドまたはその囲むクラスがfinalでない場合に危険です。攻撃者は、期待されるインスタンスの代わりに、悪意のあるクラスのインスタンスを渡し、そのメソッドをオーバーライドして異なる呼び出しで異なる値を返すようにする可能性があります。例えば、ファイルパスを返すメソッドが、doPrivilegedブロックに入る前に無害なパスを返し、doPrivilegedブロック内で呼び出すときに機密ファイルを返す場合です。このようなシナリオを回避するために、受け取ったオブジェクトを防御的にコピーする、例えばパラメータとして使用されるクラスのコピーコンストラクタを使用することで、メソッドが正確に予期通りに動作することを確保できます。\n\nSEI CERTルールSEC02-Jを参照。信頼できないソースに基づいたセキュリティチェックを行わないこと、CWE-302: 不正アクセスバイパスによる認証の回避、CWE-470: 外部制御された入力を使用してクラスまたはコードを選択する（「危険なリフレクション」）を参照。\n\njava.security.AccessControllerクラス（doPrivilegedメソッドを含む）はJava 17で非推奨となり（JEP 411参照）、Java 24で削除されました（JEP 486参照）。そのため、このバグはJava 17以上を対象としたクラスでは報告されません。",
      "vsc_vulnerable_security_check_methods": "VSC: 非プライベートおよび非finalのセキュリティチェックメソッドは脆弱\nセキュリティチェックを行うメソッドはオーバーライドされないようにする必要があるため、privateまたはfinalとして宣言するべきです。さもなければ、これらのメソッドは悪意のあるサブクラスがオーバーライドしてチェックを省略することで危険にさらされる可能性があります。\n\nSEI CERTルールMET03-Jを参照。セキュリティチェックを行うメソッドはprivateまたはfinalとして宣言すること。",
      "at_operation_sequence_on_concurrent_abstraction": "AT: 同時実行抽象化の呼び出しの順序はアトミックでない可能性がある\nこのコードには、同時実行抽象化（例えば、並列ハッシュマップ）に対する呼び出しの順序が含まれています。これらの呼び出しはアトミックに実行されません。\n\n以下の参照を参照してください：CWE-362: 共有リソースを使用した不適切な同期による並行実行（レースコンディション）、CWE-366: スレッド内でのレースコンディション、CWE-662: 不適切な同期",
      "at_unsafe_resource_access_in_thread": "AT: リソースに対する操作がマルチスレッドコンテキストで安全でない\nこのコードには、マルチスレッドコンテキストで安全でないリソースに対する操作が含まれています。リソースは、適切な同期なしで複数のスレッドによって同時にアクセスされる可能性があります。これによりデータの破損が生じることがあります。同期や他の並行制御メカニズムを使用して、リソースが安全にアクセスされるようにしてください。\n\n関連するSEI CERTルールを参照してください。ただし、検出器はチェーンメソッドに限定されません: VNA04-J. チェーンメソッドの呼び出しがアトミックであることを確認してください。\n\n以下の参照を参照してください: CWE-362: 不適切な同期による共有リソースの並行実行（レースコンディション）、CWE-366: スレッド内のレースコンディション、CWE-662: 不適切な同期",
      "stcal_static_calendar_instance": "STCAL: 静的カレンダーフィールド\nJavaDocには明記されていませんが、カレンダーは本質的にマルチスレッド使用には安全でありません。適切な同期なしでスレッド間で単一のインスタンスを共有すると、アプリケーションの異常な動作が発生します。Java 5より前のバージョンでは、ランダムなArrayIndexOutOfBoundsExceptionやIndexOutOfBoundsExceptionがsun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()で発生することがあります。\n\nシリアライズの問題も発生する可能性があります。\n\nインスタンスフィールドの使用が推奨されます。\n\n詳細については、JDKバグ#6231579およびJDKバグ#6178997を参照してください。",
      "stcal_static_simple_date_format_instance": "STCAL: 静的DateFormat\nJavaDocに記載されているように、DateFormatは本質的にマルチスレッド使用には安全でありません。スレッド間で単一のインスタンスを共有すると、アプリケーションの異常な動作が発生します。\n\nシリアライズの問題も発生する可能性があります。\n\nインスタンスフィールドの使用が推奨されます。\n\n詳細については、JDKバグ#6231579およびJDKバグ#6178997を参照してください。",
      "stcal_invoke_on_static_calendar_instance": "STCAL: 静的カレンダーへの呼び出し\nJavaDocに明記されていませんが、カレンダーは本質的にマルチスレッド使用には安全でありません。検出器は静的フィールドを通じて取得されたカレンダーのインスタンスへの呼び出しを検出しました。これは疑わしいです。\n\n詳細については、JDKバグ#6231579およびJDKバグ#6178997を参照してください。",
      "stcal_invoke_on_static_date_format_instance": "STCAL: 静的DateFormatへの呼び出し\nJavaDocに記載されているように、DateFormatは本質的にマルチスレッド使用には安全でありません。検出器は静的フィールドを通じて取得されたDateFormatのインスタンスへの呼び出しを検出しました。これは疑わしいです。\n\n詳細については、JDKバグ#6231579およびJDKバグ#6178997を参照してください。",
      "np_sync_and_null_check_field": "NP: 同じフィールドでの同期とnullチェック\nフィールドが同期されているため、nullである可能性は低いように見えます。もしnullであり、その後に同期を行うと、NullPointerExceptionがスローされ、チェックは無意味になります。別のフィールドで同期を行う方が良いです。",
      "vo_volatile_reference_to_array": "VO: 配列へのvolatile参照が配列要素をvolatileとして扱わない\nこれは配列へのvolatile参照を宣言しますが、これは望ましくないかもしれません。配列へのvolatile参照では、配列の参照の読み書きはvolatileとして扱われますが、配列の要素は非volatileとして扱われます。配列要素をvolatileとして扱いたい場合は、java.util.concurrentの原子配列クラスを使用する必要があります（Java 5.0で提供されている）。",
      "vo_volatile_increment": "VO: volatileフィールドへのインクリメントはアトミックではない\nこのコードはvolatileフィールドをインクリメント/デクリメントします。volatileフィールドのインクリメント/デクリメントはアトミックではありません。複数のスレッドが同時にフィールドをインクリメント/デクリメントすると、インクリメント/デクリメントが失われる可能性があります。\n\nCWE-567: マルチスレッドコンテキストでの共有データへの非同期アクセスを参照してください。",
      "dm_monitor_wait_on_condition": "Dm: Conditionでのmonitor wait()呼び出し\nこのメソッドはjava.util.concurrent.locks.Conditionオブジェクトでwait()を呼び出します。Conditionでの待機は、Conditionインターフェースで定義されたawait()メソッドのいずれかを使用して行うべきです。",
      "dm_useless_thread": "Dm: デフォルトの空のrunメソッドでスレッドを作成\nこのメソッドは、Threadクラスから派生するか、Runnableオブジェクトを渡してrunメソッドを指定せずにスレッドを作成します。このスレッドはその後、何もせず時間を浪費します。",
      "dc_doublecheck": "DC: フィールドの二重チェックの可能性\nこのメソッドは二重チェックロッキングのインスタンスを含んでいる可能性があります。このイディオムはJavaメモリモデルのセマンティクスに従っていません。詳細については、ウェブページhttp://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.htmlとCWE-609: Double-Checked Lockingを参照してください。",
      "dc_partially_constructed": "DC: 部分的に初期化されたオブジェクトの露出の可能性\nこのメソッドは二重チェックロッキングを使用して遅延フィールド初期化を行っているようです。フィールドはvolatileとして正しく宣言されていますが、フィールドの割り当て後にオブジェクトの内部構造が変更される可能性があるため、別のスレッドが部分的に初期化されたオブジェクトを見ることがあります。\n\nこの問題を修正するために、オブジェクトをまずローカル変数に格納し、完全に構築された後にのみvolatileフィールドに保存することを検討してください。\n\nCWE-609: Double-Checked Lockingを参照してください。",
      "dl_synchronization_on_shared_constant": "DL: Stringリテラルでの同期\nコードはStringリテラルで同期しています。\n\nprivate static String LOCK = 'LOCK';\n...\nsynchronized(LOCK) {\n    ...\n}\n...\n定数Stringはインターンされ、JVMによって読み込まれるすべての他のクラスと共有されます。したがって、このコードは他のコードがロックしているかもしれないものにロックしています。これにより、非常に奇妙で診断が困難なブロッキングやデッドロックが発生する可能性があります。詳細については、http://www.javalobby.org/java/forums/t96352.htmlとhttp://jira.codehaus.org/browse/JETTY-352を参照してください。\n\nCERT LCK01-Jを参照してください。再利用される可能性のあるオブジェクトで同期しないでください。また、CWE-412: 外部からアクセス可能なロックの制限なしも参照してください。",
      "dl_synchronization_on_boolean": "DL: Booleanでの同期\nコードはボックス化されたプリミティブ定数、例えばBooleanで同期しています。\n\nprivate static Boolean inited = Boolean.FALSE;\n...\nsynchronized(inited) {\n    if (!inited) {\n        init();\n        inited = Boolean.TRUE;\n    }\n}\n...\n通常、Booleanオブジェクトは2つだけ存在するため、このコードは他の無関係なコードと同じオブジェクトで同期している可能性があり、その結果、応答しなくなったりデッドロックが発生する可能性があります。\n\nCERT LCK01-Jを参照してください。再利用される可能性のあるオブジェクトで同期しないでください。また、CWE-412: 外部からアクセス可能なロックの制限なしも参照してください。",
      "dl_synchronization_on_boxed_primitive": "DL: ボックス化されたプリミティブでの同期\nコードはボックス化されたプリミティブ定数、例えばIntegerで同期しています。\n\nprivate static Integer count = 0;\n...\nsynchronized(count) {\n    count++;\n}\n...\nIntegerオブジェクトはキャッシュされて共有されるため、このコードは他の無関係なコードと同じオブジェクトで同期している可能性があり、その結果、応答しなくなったりデッドロックが発生する可能性があります。\n\nCERT LCK01-Jを参照してください。再利用される可能性のあるオブジェクトで同期しないでください。また、CWE-412: 外部からアクセス可能なロックの制限なしも参照してください。",
      "dl_synchronization_on_unshared_boxed_primitive": "DL: ボックス化されたプリミティブ値での同期\nコードは明らかに共有されていないボックス化されたプリミティブ、例えばIntegerで同期しています。\n\nprivate static final Integer fileLock = new Integer(1);\n...\nsynchronized(fileLock) {\n    .. do something ..\n}\n...\nこのコードでは、fileLockを次のように再宣言する方がはるかに良いです。\n\nprivate static final Object fileLock = new Object();\n既存のコードは問題ないかもしれませんが、混乱を招き、IntelliJの「Remove Boxing」リファクタリングのような将来のリファクタリングによって、JVM全体で共有されるインターンされたIntegerオブジェクトに置き換えられる可能性があり、その結果、非常に混乱を招く動作やデッドロックを引き起こす可能性があります。\n\nCERT LCK01-Jを参照してください。再利用される可能性のあるオブジェクトで同期しないでください。また、CWE-412: 外部からアクセス可能なロックの制限なしも参照してください。",
      "dl_synchronization_on_interned_string": "DL: インターンされたStringでの同期\nコードはインターンされたStringで同期しています。\n\nprivate static String LOCK = new String('LOCK').intern();\n...\nsynchronized(LOCK) {\n    ...\n}\n...\n定数Stringはインターンされ、JVMによって読み込まれるすべての他のクラスと共有されます。したがって、このコードは他のコードがロックしているかもしれないものにロックしています。これにより、非常に奇妙で診断が困難なブロッキングやデッドロックが発生する可能性があります。詳細については、http://www.javalobby.org/java/forums/t96352.htmlとhttp://jira.codehaus.org/browse/JETTY-352を参照してください。\n\nCERT LCK01-Jを参照してください。再利用される可能性のあるオブジェクトで同期しないでください。また、CWE-412: 外部からアクセス可能なロックの制限なしも参照してください。",
      "wl_using_getclass_rather_than_class_literal": "WL: classリテラルではなくgetClassで同期\nこのインスタンスメソッドはthis.getClass()で同期しています。このクラスがサブクラス化されると、サブクラスはサブクラスのクラスオブジェクトで同期し、これは意図された動作ではない可能性があります。例えば、次のコードを考えてみてください。\n\nprivate static final String base = 'label';\nprivate static int nameCounter = 0;\n\nString constructComponentName() {\n    synchronized (getClass()) {\n        return base + nameCounter++;\n    }\n}\nLabelのサブクラスは同じサブクラスで同期せず、データレースが発生します。代わりに、このコードはLabel.classで同期するべきです。\n\nprivate static final String base = 'label';\nprivate static int nameCounter = 0;\n\nString constructComponentName() {\n    synchronized (Label.class) {\n        return base + nameCounter++;\n    }\n}\nバグパターンはJason Mehrensによって提供されました。\n\nCWE-821: 不正な同期を参照してください。",
      "e_sync_empty_sync": "ESync: 空の同期ブロック\nコードには空の同期ブロックが含まれています。\n\nsynchronized() {\n}\n空の同期ブロックは、ほとんどの人が認識しているよりも微妙で、正しく使用するのが難しいものであり、空の同期ブロックは、ほとんどの場合、より簡潔な解決策よりも優れた解決策ではありません。\n\nCWE-585: 空の同期ブロックを参照してください。",
      "msf_mutable_servlet_field": "MSF: 可変なサーブレットフィールド\nウェブサーバーは一般的にサーブレットまたはJSPクラスのインスタンスを1つだけ作成します（つまり、そのクラスをSingletonとして扱います）。そして、そのインスタンスに複数のスレッドがメソッドを呼び出して、複数の同時リクエストに対応します。したがって、可変なインスタンスフィールドを持つことは、一般的にレースコンディションを引き起こします。",
      "is2_inconsistent_sync": "IS: 一貫性のない同期\nこのクラスのフィールドは、同期に関して一貫性がないようにアクセスされているようです。このバグレポートは、バグパターン検出ツールが次のことを判断したことを示しています：\n\n- クラスにはロックされたアクセスとロックされていないアクセスが混在している\n- クラスはjavax.annotation.concurrent.NotThreadSafeとして注釈が付けられていない\n- 少なくとも1つのロックされたアクセスはクラスのメソッドの1つによって実行された\n- 同期されていないフィールドアクセス（読み取りと書き込み）の数は、すべてのアクセスのうち3分の1を超えない、書き込みは読み取りより2倍重要\n\nこのバグパターンに一致する典型的なバグは、スレッドセーフであることを意図したクラスのメソッドを同期し忘れることです。\n\n「同期されていないアクセス」とラベル付けされたノードを選択すると、検出ツールがフィールドへのアクセスが同期なしで行われたと判断したコードの場所が表示されます。\n\nこの検出ツールには不正確な箇所がいくつかあることに注意してください。例えば、ロックが保持されている状況を静的に検出することはできません。また、検出ツールがロックされたアクセスとロックされていないアクセスを正確に区別できても、問題のコードが依然として正しい可能性もあります。\n\nCWE-366: スレッド内での競合状態を参照してください。",
      "nn_naked_notify": "NN: Naked notify\nnotify()またはnotifyAll()が、変更されていない可変オブジェクトの状態に対して呼び出されました。一般に、モニタ上でnotifyメソッドを呼び出すのは、他のスレッドが待機している条件が真になったときです。しかし、その条件が意味を持つためには、両方のスレッドに見えるヒープオブジェクトが関与していなければなりません。\n\nこのバグは必ずしもエラーを示すものではありません。可変オブジェクトの状態の変更は、通知を含むメソッドを呼び出した別のメソッドで行われているかもしれません。",
      "ru_invoke_run": "Ru: スレッドでrunを呼び出し（開始すべきでは？）\nこのメソッドは、オブジェクトでrun()を明示的に呼び出します。一般的に、クラスはRunnableインターフェースを実装します。なぜなら、run()メソッドが新しいスレッドで呼び出されるからです。この場合、Thread.start()が正しいメソッドです。\n\nCWE-572: Threadのrun()ではなくstart()を呼び出すことを参照してください。",
      "sp_spin_on_field": "SP: メソッドがフィールドでスピンする\nこのメソッドは、フィールドを読み取るループでスピンします。コンパイラは合法的にその読み取りをループの外に持ち上げ、コードが無限ループに変わる可能性があります。クラスは適切な同期（waitおよびnotify呼び出しを含む）を使用するように変更するべきです。\n\nCWE-662: 不適切な同期を参照してください。",
      "tlw_two_lock_wait": "TLW: 2つのロックを保持した状態での待機\n2つのロックを保持した状態でモニタ上で待機することは、デッドロックを引き起こす可能性があります。待機は、待機対象のオブジェクトのロックのみを解放し、他のロックは解放しません。これは必ずしもバグではありませんが、慎重に検討する価値があります。\n\nCWE-833: デッドロックを参照してください。",
      "uw_uncond_wait": "UW: 無条件の待機\nこのメソッドには、条件付きの制御フローによって保護されていないjava.lang.Object.wait()への呼び出しが含まれています。コードは、待機する条件がすでに満たされていないかを確認してからwaitを呼び出すべきです。以前の通知は無視されます。",
      "ug_sync_set_unsync_get": "UG: 同期されていないgetメソッド、同期されたsetメソッド\nこのクラスには、名前が似ているgetおよびsetメソッドが含まれており、setメソッドは同期されているのに対し、getメソッドは同期されていません。これにより、ランタイムで不正な動作が発生する可能性があります。getメソッドを同期化すべきです。\n\nCWE-820: 同期の欠如を参照してください。",
      "is_field_not_guarded": "IS: 同時アクセスに対して保護されていないフィールド\nこのフィールドはnet.jcip.annotations.GuardedByまたはjavax.annotation.concurrent.GuardedByで注釈が付けられていますが、その注釈に違反する方法でアクセスされているようです。\n\nCWE-366: スレッド内での競合状態を参照してください。",
      "ml_sync_on_field_to_guard_changing_that_field": "ML: フィールドを保護しようとする無駄な試みでの同期\nこのメソッドはフィールドに対して同期を行い、同時更新からそのフィールドを保護しようとしています。しかし、フィールドを保護することは、参照されたオブジェクトにロックをかけることであって、フィールド自体にはロックをかけません。これでは必要な排他制御を提供できない可能性があり、他のスレッドが参照されたオブジェクトにロックを取得しているかもしれません（他の目的で）。このパターンの一例は以下のようになります：\n\nprivate Long myNtfSeqNbrCounter = new Long(0);\nprivate Long getNotificationSequenceNumber() {\n     Long result = null;\n     synchronized(myNtfSeqNbrCounter) {\n         result = new Long(myNtfSeqNbrCounter.longValue() + 1);\n         myNtfSeqNbrCounter = new Long(result.longValue());\n     }\n     return result;\n}\n\nCWE-821: 不正確な同期を参照してください。",
      "ml_sync_on_updated_field": "ML: メソッドが更新されたフィールドで同期\nこのメソッドは可変フィールドから参照されるオブジェクトで同期を行っています。異なるスレッドが異なるオブジェクトで同期を行う可能性があるため、これは有用な意味を持たない可能性が高いです。\n\nCWE-821: 不正確な同期を参照してください。",
      "ws_writeobject_sync": "WS: クラスのwriteObject()メソッドが同期されているが、他のメソッドは同期されていない\nこのクラスにはwriteObject()メソッドが同期されているものの、クラスの他のメソッドは同期されていません。\n\nCWE-820: 同期の欠如を参照してください。",
      "rs_readobject_sync": "RS: クラスのreadObject()メソッドが同期されている\nこのシリアライズ可能なクラスは同期されたreadObject()を定義しています。定義上、デシリアライズによって作成されたオブジェクトは1つのスレッドからしかアクセスされないため、readObject()が同期される必要はありません。もしreadObject()メソッドがオブジェクトを別のスレッドに対して可視化させる場合、それは非常に疑わしいコーディングスタイルの一例です。\n\nCWE-820: 同期の欠如を参照してください。",
      "sc_start_in_ctor": "SC: コンストラクタがThread.start()を呼び出す\nコンストラクタがスレッドを開始します。クラスが拡張/サブクラス化された場合、スレッドはサブクラスのコンストラクタが開始される前に開始されるため、これが誤りである可能性が高いです。",
      "wa_not_in_loop": "Wa: ループ内でない待機\nこのメソッドにはjava.lang.Object.wait()への呼び出しが含まれており、ループ内ではありません。モニタが複数の条件に使用されている場合、呼び出し元が待機しようとしていた条件が実際に発生した条件と一致しない可能性があります。",
      "wa_await_not_in_loop": "Wa: Condition.await()がループ内でない\nこのメソッドにはjava.util.concurrent.await()（またはそのバリアント）への呼び出しが含まれており、ループ内ではありません。オブジェクトが複数の条件に使用されている場合、呼び出し元が待機しようとしていた条件が実際に発生した条件と一致しない可能性があります。",
      "no_notify_not_notifyall": "No: notify()ではなくnotifyAll()を使用\nこのメソッドはnotify()を呼び出しており、notifyAll()ではありません。Javaのモニタは複数の条件で使用されることが多いです。notify()を呼び出すと、1つのスレッドのみが起床します。起床したスレッドが、呼び出し元が満たした条件を待っているスレッドでない可能性があります。",
      "ul_unreleased_lock": "UL: メソッドがすべてのパスでロックを解放しない\nこのメソッドはJSR-166（java.util.concurrent）ロックを取得しますが、メソッドのすべてのパスでロックを解放しません。一般に、JSR-166ロックを使用する際の正しい書き方は次の通りです：\n\nLock l = ...;\nl.lock();\ntry {\n    // 何かをする\n} finally {\n    l.unlock();\n}\n\nCWE-413: 不正なリソースロックおよびCWE-459: 不完全なクリーンアップを参照してください。",
      "ul_unreleased_lock_exception_path": "UL: メソッドがすべての例外パスでロックを解放しない\nこのメソッドはJSR-166（java.util.concurrent）ロックを取得しますが、メソッドのすべての例外パスでロックを解放しません。一般に、JSR-166ロックを使用する際の正しい書き方は次の通りです：\n\nLock l = ...;\nl.lock();\ntry {\n    // 何かをする\n} finally {\n    l.unlock();\n}\n\nCWE-413: 不正なリソースロックおよびCWE-459: 不完全なクリーンアップを参照してください。",
      "mwn_mismatched_wait": "MWN: 不一致なwait()\nこのメソッドは、オブジェクトにロックを保持していることが明示的に示されていない状態でObject.wait()を呼び出します。ロックを保持せずにwait()を呼び出すと、IllegalMonitorStateExceptionがスローされます。",
      "mwn_mismatched_notify": "MWN: 不一致なnotify()\nこのメソッドは、オブジェクトにロックを保持していることが明示的に示されていない状態でObject.notify()またはObject.notifyAll()を呼び出します。ロックを保持せずにnotify()またはnotifyAll()を呼び出すと、IllegalMonitorStateExceptionがスローされます。",
      "li_lazy_init_static": "LI: 静的フィールドの不正な遅延初期化\nこのメソッドは、非volatileの静的フィールドを同期なしで遅延初期化しています。コンパイラやプロセッサが命令を並べ替える可能性があるため、複数のスレッドから呼び出される場合、スレッドは完全に初期化されたオブジェクトを確認できません。問題を解決するには、フィールドをvolatileとして修正できます。詳細については、Javaメモリモデルのウェブサイトを参照してください。\n\nCWE-543: 複数スレッドのコンテキストで同期なしのシングルトンパターンの使用を参照してください。",
      "li_lazy_init_update_static": "LI: 静的フィールドの不正な遅延初期化と更新\nこのメソッドは、静的フィールドの同期なしの遅延初期化を行います。フィールドが設定された後、その場所に格納されたオブジェクトがさらに更新またはアクセスされます。フィールドの設定は、設定されるとすぐに他のスレッドに可視化されます。もし、フィールドを設定するメソッド内でそのオブジェクトの初期化が行われている場合、他のスレッドが格納されたオブジェクトにアクセスするのを防ぐものがなければ、非常に深刻なマルチスレッドのバグとなります。\n\nもし、メソッドが複数のスレッドから呼ばれることがないと自信があっても、静的フィールドを設定する前に設定する値が完全に初期化されていることを確認する方が良いかもしれません。\n\nCWE-543: 複数スレッドのコンテキストで同期なしのシングルトンパターンの使用を参照してください。",
      "jlm_jsr166_utilconcurrent_monitorenter": "JLM: util.concurrentインスタンスでの同期\nこのメソッドは、java.util.concurrentパッケージ（またはそのサブクラス）のクラスのインスタンスに対して同期を行います。これらのクラスのインスタンスは、Javaキーワードsynchronizedによって提供される同期とは異なる独自の並行制御メカニズムを持っています。たとえば、AtomicBooleanで同期を取っても、他のスレッドがAtomicBooleanを変更することを防ぐことはできません。\n\nこのコードは正しい可能性もありますが、慎重にレビューし、文書化する必要があり、後でコードをメンテナンスする人々を混乱させる可能性があります。",
      "jml_jsr166_calling_wait_rather_than_await": "JLM: util.concurrent抽象化でモニタースタイルの待機メソッドを使用\nこのメソッドは、await()、signal()、signalAll()メソッド（例えば、java.util.concurrentのConditionオブジェクト）を提供するオブジェクトでwait()、notify()、notifyAll()を呼び出します。これは望ましくない可能性があり、仮に望む場合でも、他の開発者が非常に混乱するため、設計を変更することを検討するべきです。",
      "jlm_jsr166_lock_monitorenter": "JLM: Lockで同期が実行される\nこのメソッドは、java.util.concurrent.locks.Lockを実装したオブジェクトで同期を実行します。このようなオブジェクトは、synchronized (...) 構文を使用するのではなく、acquire()/release()を使用してロック/ロック解除されます。",
      "swl_sleep_with_lock_held": "SWL: メソッドがロックを保持したままThread.sleep()を呼び出す\nこのメソッドはロックを保持したままThread.sleep()を呼び出します。これにより、非常に悪いパフォーマンスとスケーラビリティ、またはデッドロックが発生する可能性があります。なぜなら、他のスレッドがロックの取得を待機している可能性があるからです。ロックを解放して他のスレッドを実行できるようにするため、lockでwait()を呼び出す方がはるかに良いアイデアです。\n\nCWE-667: 不適切なロッキングを参照してください。",
      "rv_return_value_of_putifabsent_ignored": "RV: putIfAbsentの戻り値が無視され、putIfAbsentに渡された値が再利用される\nputIfAbsentメソッドは、通常、指定されたキーに対して単一の値が関連付けられていることを保証するために使用されます（putIfAbsentが成功する最初の値）。戻り値を無視して、渡された値への参照を保持すると、マップ内でキーに関連付けられた値とは異なる値を保持するリスクがあります。どちらを使用するかが重要であり、マップに格納されていない方を使用すると、プログラムが誤動作します。\nCWE-252: チェックされていない戻り値を参照してください。",
      "ssd_do_not_use_instance_lock_on_shared_static_data": "SSD: 共有静的データにインスタンスレベルのロックが使用されている\nロックまたは同期メソッドが静的でない場合、静的フィールドを修正することで、共有静的データが並行アクセスから保護されなくなる可能性があります。これが発生する方法としては、非静的なロックオブジェクトを使用する同期メソッド、または非静的として宣言された同期メソッドが考えられます。どちらの場合も無効です。最良の解決策は、共有静的データを保護するために、プライベートの静的最終ロックオブジェクトを使用することです。\n\nSEI CERT規則LCK06-Jを参照してください。インスタンスロックを使用して共有静的データを保護しないこと、およびCWE-667: 不適切なロッキングを参照してください。",
      "at_nonatomic_64_bit_primitive": "AT: この64ビットのプリミティブ変数の書き込みはアトミックでない可能性がある\nlongとdoubleは64ビットのプリミティブ型であり、Java仮想マシンの実装によっては、それに値を割り当てることが2つの別々の32ビットの書き込みとして処理され、アトミックでない可能性があります。詳細はJSL 17.7. doubleとlongの非アトミック処理を参照してください。また、SEI CERT規則VNA05-Jを参照して、64ビットの値の読み書きのアトミック性を確保し、CWE-667: 不適切なロッキングの詳細を参照してください。このバグは、64ビットのlongおよびdouble型の読み書き操作がアトミックであることを保証するプラットフォームでは無視してもかまいません。\n\nこれを修正するには、変数をvolatileとして宣言するか、フィールドの型をjava.lang.concurrent.atomicの対応するアトミック型に変更するか、コードを適切に同期化してください。volatileとして宣言するだけでは不十分な場合があります。例えば、変数に現在の値または非アトミックな複合操作の結果に依存する値を割り当てる場合などです。",
      "at_stale_thread_write_of_primitive": "AT: この共有プリミティブ変数の書き込みは他のスレッドから見えない場合がある\nSEI CERT規則VNA00-Jは、1つのスレッドで共有プリミティブ変数を読み取ると、別のスレッドからの最新の書き込み値が得られない可能性があることを示しています。その結果、スレッドは共有変数の古い値を観察する可能性があります。\n\nこれを修正するには、変数をvolatileとして宣言するか、フィールドの型をjava.lang.concurrent.atomicの対応するアトミック型に変更するか、コードを適切に同期化してください。volatileとして宣言するだけでは不十分な場合があります。例えば、変数に現在の値または非アトミックな複合操作の結果に依存する値が割り当てられる場合などです。これにより、64ビットのプリミティブ型longおよびdouble変数がアトミックにアクセスされることが保証されます。\n\nまた、CWE-413: 不適切なリソースロッキング、CWE-567: マルチスレッド環境における共有データへの未同期アクセス、CWE-667: 不適切なロッキングも参照してください。",
      "at_nonatomic_operations_on_shared_variable": "AT: 共有変数への操作はアトミックでない\n関数間で共有される変数の書き込みは、その変数の現在の値に依存します（複合操作であるため - 例: +=, ++ - または単に現在の値に依存するため）、そのため、複数の独立した操作に分かれています。これらの操作はそれ自体ではアトミックではなく、さらなる同期化が必要です。SEI CERT規則VNA02-J、CWE-366: スレッド内でのレースコンディション、CWE-413: 不適切なリソースロッキング、CWE-567: マルチスレッド環境における共有データへの未同期アクセス、CWE-667: 不適切なロッキングを参照してください。\n\n変数をvolatileとして宣言するだけでは、変数に対する複合操作のアトミック性を保証できませんが、変数をvolatileとして宣言した上で書き込みを同期することで十分です。\nこの問題を解決するには、複合操作や他の書き込み操作を同期するか、読み書きロックを使用するか、共有変数をアトミック型で宣言してください。",
      "noise_null_dereference": "NOISE: nullポインターデリファレンスに関する誤った警告\n誤った警告。",
      "noise_method_call": "NOISE: メソッド呼び出しに関する誤った警告\n誤った警告。",
      "noise_field_reference": "NOISE: フィールド参照に関する誤った警告\n誤った警告。",
      "noise_operation": "NOISE: 操作に関する誤った警告\n誤った警告。",
      "hsc_huge_shared_string_constant": "HSC: 巨大な文字列定数が複数のクラスファイルに重複している\n大きな文字列定数が複数のクラスファイルに重複しています。これは、finalフィールドが文字列定数に初期化され、Java言語が他のクラスからfinalフィールドへのすべての参照をそのクラスファイルにインライン化することを義務付けているためです。このバグがJDKで発生し、その解決によりJDKのサイズが1メガバイト削減された詳細については、JDKのバグ6447475を参照してください。",
      "dmi_blocking_methods_on_url": "Dm: URLのequalsおよびhashCodeメソッドはブロッキング\nURLのequalsおよびhashCodeメソッドはドメイン名解決を行うため、大きなパフォーマンスの低下を引き起こす可能性があります。詳細については、こちらを参照してください。java.net.URIの使用を検討してください。",
      "dmi_collection_of_urls": "Dm: URLのマップおよびセットはパフォーマンスに問題がある可能性がある\nこのメソッドまたはフィールドは、URLのマップまたはセットを使用しています。URLのequalsおよびhashCodeメソッドはドメイン名解決を行うため、大きなパフォーマンスの低下を引き起こす可能性があります。詳細については、こちらを参照してください。java.net.URIの使用を検討してください。",
      "dm_string_ctor": "Dm: メソッドが非効率的な new String(String) コンストラクタを呼び出す\njava.lang.String(String) コンストラクタを使用すると、メモリが無駄になります。なぜなら、作成されたオブジェクトは、引数として渡された String と機能的に区別がつかないからです。引数の String を直接使用するだけで十分です。",
      "dm_string_void_ctor": "Dm: メソッドが非効率的な new String() コンストラクタを呼び出す\n引数なしのコンストラクタを使用して新しい java.lang.String オブジェクトを作成すると、メモリが無駄になります。作成されたオブジェクトは、空文字列定数 '' と機能的に区別がつかないからです。Java は、同一の文字列定数が同じ String オブジェクトで表されることを保証しています。したがって、空文字列定数を直接使用するべきです。",
      "dm_string_tostring": "Dm: メソッドが String に対して toString() メソッドを呼び出す\nString.toString() を呼び出すのは冗長な操作です。String をそのまま使用するだけで十分です。",
      "dm_gc": "Dm: 明示的なガーベジコレクション; ベンチマークコード以外では非常に疑わしい\nコードが明示的にガーベジコレクションを呼び出します。ベンチマークで特定の用途を除いて、これは非常に疑わしいです。\n\n過去に、close や finalize メソッドなどでガーベジコレクタを明示的に呼び出すことは、パフォーマンスの大きな問題を引き起こしました。ガーベジコレクションはコストが高い場合があります。数百回または数千回のガーベジコレクションを強制するような状況は、マシンを非常に遅くします。",
      "dm_boolean_ctor": "Dm: メソッドが非効率的な Boolean コンストラクタを呼び出す; 代わりに Boolean.valueOf(…) を使用\n新しい java.lang.Boolean インスタンスを作成することはメモリを無駄にします。なぜなら、Boolean オブジェクトは不変であり、この型には有用な値が2つしかないからです。Boolean オブジェクトを作成するには、Boolean.valueOf() メソッド（または Java 5 のオートボクシング）を使用してください。",
      "dm_number_ctor": "Bx: メソッドが非効率的な Number コンストラクタを呼び出す; 代わりに静的 valueOf を使用\nnew Integer(int) を使用すると常に新しいオブジェクトが作成されるのに対し、Integer.valueOf(int) はコンパイラ、クラスライブラリ、または JVM によって値のキャッシュを行います。キャッシュされた値を使用することで、オブジェクトの割り当てを避け、コードはより高速になります。\n\n-128 と 127 の間の値はキャッシュされたインスタンスを持つことが保証されており、valueOf を使用することで、コンストラクタを使用する場合より約 3.5 倍速くなります。定数範囲外の値の場合、両方のスタイルのパフォーマンスは同じです。\n\nJava 5 より前の JVM と互換性が必要でない限り、Long、Integer、Short、Character、Byte のインスタンスを作成する際には、オートボクシングまたは valueOf() メソッドを使用してください。",
      "dm_fp_number_ctor": "Bx: メソッドが非効率的な浮動小数点型 Number コンストラクタを呼び出す; 代わりに静的 valueOf を使用\nnew Double(double) を使用すると常に新しいオブジェクトが作成されるのに対し、Double.valueOf(double) はコンパイラ、クラスライブラリ、または JVM によって値のキャッシュを行います。キャッシュされた値を使用することで、オブジェクトの割り当てを避け、コードはより高速になります。\n\nJava 5 より前の JVM と互換性が必要でない限り、Double や Float のインスタンスを作成する際には、オートボクシングまたは valueOf() メソッドを使用してください。",
      "dm_boxed_primitive_tostring": "Bx: メソッドが toString を呼び出すためだけにボックス化されたプリミティブ型を割り当てる\ntoString() を呼び出すためだけにボックス化されたプリミティブ型が割り当てられています。プリミティブ値を取る静的な toString の形式を直接使用する方が効果的です。\n\n例:\nnew Integer(1).toString() → Integer.toString(1)\nnew Long(1).toString() → Long.toString(1)\nnew Float(1.0).toString() → Float.toString(1.0)\nnew Double(1.0).toString() → Double.toString(1.0)\nnew Byte(1).toString() → Byte.toString(1)\nnew Short(1).toString() → Short.toString(1)\nnew Boolean(true).toString() → Boolean.toString(true)",
      "dm_boxed_primitive_for_parsing": "Bx: プリミティブ型を解析するためのボクシング/アンボクシング\n文字列からボックス化されたプリミティブ型を作成し、そのアンボクシングされたプリミティブ値を抽出します。静的な parseXXX メソッドを呼び出す方が効率的です。",
      "dm_boxed_primitive_for_compare": "Bx: 比較のためにプリミティブ型をボックス化する\ncompareTo() メソッドを呼び出すためにボックス化されたプリミティブ型が作成されます。プリミティブ型で直接動作する静的 compare メソッド（Java 1.4 以降の double と float、Java 7 以降の他のプリミティブ型）を使用する方が効率的です。",
      "bx_unboxed_and_coerced_for_ternary_operator": "Bx: 三項演算子のためにプリミティブ型の値がアンボクシングされ、強制変換される\nラップされたプリミティブ型の値がアンボクシングされ、三項演算子（b ? e1 : e2）の評価の一環として他のプリミティブ型に変換/強制されます。Java のセマンティクスでは、e1 と e2 がラップされた数値型の値である場合、値はアンボクシングされ、共通の型に変換され/強制されます（例: e1 が Integer 型で、e2 が Float 型の場合、e1 はアンボクシングされ、浮動小数点値に変換され、再ボックス化されます）。JLS セクション 15.25 を参照してください。",
      "bx_unboxing_immediately_reboxed": "Bx: ボックス化された値がアンボクシングされ、その後すぐに再ボックス化される\nボックス化された値がアンボクシングされ、その後すぐに再ボックス化されます。",
      "bx_boxing_immediately_unboxed": "Bx: プリミティブ型の値がボックス化され、その後すぐにアンボクシングされる\nプリミティブ型がボックス化され、その後すぐにアンボクシングされます。これは、おそらくボックス化が必要な場所で手動でボックス化され、その後アンボクシングが強制されるため、コンパイラがボックス化の作業をすぐに元に戻すことになります。",
      "bx_boxing_immediately_unboxed_to_perform_coercion": "Bx: プリミティブ型の値がボックス化され、強制変換を行うためにアンボクシングされる\nボックス化されたプリミティブ型の値が作成され、その後すぐに異なるプリミティブ型に変換されます（例: new Double(d).intValue()）。直接的なプリミティブ型の強制変換を行うだけで十分です（例: (int) d）。\n\nCWE-192: 整数型強制変換エラーを参照してください。",
      "dm_new_for_getclass": "Dm: メソッドがオブジェクトを割り当て、クラスオブジェクトを取得するためだけに使用される\nこのメソッドは、getClass() を呼び出してクラスオブジェクトを取得するためだけにオブジェクトを割り当てます。クラスの .class プロパティを直接アクセスする方が簡単です。",
      "dm_nextint_via_nextdouble": "Dm: ランダム整数を生成するために nextDouble より nextInt メソッドを使用\nr が java.util.Random の場合、r.nextInt(n) を使用して、0 から n-1 のランダムな数値を生成できます。r.nextDouble() * n を使用するのではなく、\n\nnextInt の引数は正でなければなりません。例えば、-99 から 0 のランダム値を生成したい場合は、-r.nextInt(100) を使用してください。",
      "ss_should_be_static": "SS: 読み取られていないフィールド: このフィールドは static であるべきか？\nこのクラスは、コンパイル時に静的な値で初期化されたインスタンスの final フィールドを含んでいます。フィールドを static にすることを検討してください。",
      "uuf_unused_field": "UuF: 未使用のフィールド\nこのフィールドは使用されていません。クラスから削除することを検討してください。\n\nCWE-563: 使用されていない変数への代入を参照してください。",
      "urf_unread_field": "UrF: 読まれていないフィールド\nこのフィールドは読まれていません。クラスから削除することを検討してください。\n\nCWE-563: 使用されていない変数への代入を参照してください。",
      "sic_inner_should_be_static": "SIC: 静的な内部クラスであるべき\nこのクラスは内部クラスですが、クラスを作成したオブジェクトへの埋め込まれた参照を使用していません。この参照により、クラスのインスタンスは大きくなり、作成者オブジェクトへの参照が必要以上に長く保持される可能性があります。可能であれば、クラスは静的にすべきです。",
      "sic_inner_should_be_static_needs_this": "SIC: 静的内部クラスにリファクタリングすることができる\nこのクラスは内部クラスですが、その作成元のオブジェクトへの埋め込まれた参照を、内部オブジェクトの作成時以外で使用していません。この参照により、クラスのインスタンスが大きくなり、作成者オブジェクトへの参照が必要以上に長く保持される可能性があります。可能であれば、このクラスは静的内部クラスにすべきです。内部インスタンスの作成時に外部オブジェクトへの参照が必要なので、内部クラスは外部インスタンスへの参照をコンストラクタに渡すようにリファクタリングする必要があります。",
      "sic_inner_should_be_static_anon": "SIC: 名前付き静的内部クラスにリファクタリングすることができる\nこのクラスは内部クラスですが、その作成元のオブジェクトへの埋め込まれた参照を使用していません。この参照により、クラスのインスタンスが大きくなり、作成者オブジェクトへの参照が必要以上に長く保持される可能性があります。可能であれば、このクラスは静的内部クラスにすべきです。匿名内部クラスは静的としてマークできないため、この場合、内部クラスは名前付き内部クラスにリファクタリングする必要があります。",
      "upm_uncalled_private_method": "UPM: プライベートメソッドは決して呼ばれない\nこのプライベートメソッドは決して呼ばれません。このメソッドがリフレクションを通じて呼ばれる可能性はありますが、実際にはメソッドが使用されることはなく、削除すべきです。\n\nCWE-561: デッドコードを参照してください。",
      "sbsc_use_stringbuffer_concatenation": "SBSC: メソッドがループ内で + を使用して文字列を連結\nこのメソッドはループ内で文字列の連結を行っているようです。各反復で文字列が StringBuffer/StringBuilder に変換され、連結され、再び文字列に戻されます。これにより、反復回数が増えるとコストが二次的に増加します。\n\nより良いパフォーマンスを得るためには、StringBuffer（または Java 5 以降は StringBuilder）を明示的に使用することをお勧めします。\n\n例えば：\n\n// これは悪い例\nString s = '';\nfor (int i = 0; i < field.length; ++i) {\n    s = s + field[i];\n}\n\n// これは良い例\nStringBuffer buf = new StringBuffer();\nfor (int i = 0; i < field.length; ++i) {\n    buf.append(field[i]);\n}\nString s = buf.toString();",
      "iil_elements_get_length_in_loop": "IIL: ループ内で NodeList.getLength() を呼び出す\nメソッドはループ内で NodeList.getLength() を呼び出し、NodeList は getElementsByTagName 呼び出しによって生成されました。この NodeList は長さを格納せず、毎回計算しますが、最適でない方法で計算されます。ループ前に長さを変数に格納することを検討してください。",
      "iil_prepare_statement_in_loop": "IIL: ループ内で prepareStatement メソッドを呼び出す\nメソッドはループ内で Connection.prepareStatement を呼び出し、定数の引数を渡します。PreparedStatement を何度も実行する場合、毎回再作成する理由はありません。この呼び出しをループ外に移動してください。",
      "iil_pattern_compile_in_loop": "IIL: ループ内で Pattern.compile メソッドを呼び出す\nメソッドはループ内で Pattern.compile を呼び出し、定数の引数を渡します。Pattern を何度も使用する場合、毎回コンパイルする必要はありません。この呼び出しをループ外に移動するか、静的 final フィールドに入れることを検討してください。",
      "iil_pattern_compile_in_loop_indirect": "IIL: ループ内で正規表現をコンパイルする\nメソッドはループ内で同じ正規表現を作成し、毎回コンパイルされます。この正規表現をループ外で Pattern.compile を使って事前にコンパイルする方が最適です。",
      "iio_inefficient_index_of": "IIO: String.indexOf(String) の非効率的な使用\nこのコードは長さ1の定数文字列を String.indexOf() に渡しています。整数実装の String.indexOf() を使用する方が効率的です。例えば、myString.indexOf('.') を myString.indexOf('.') の代わりに呼び出します。",
      "iio_inefficient_last_index_of": "IIO: String.lastIndexOf(String) の非効率的な使用\nこのコードは長さ1の定数文字列を String.lastIndexOf() に渡しています。整数実装の String.lastIndexOf() を使用する方が効率的です。例えば、myString.lastIndexOf('.') を myString.lastIndexOf('.') の代わりに呼び出します。",
      "ita_inefficient_to_array": "ITA: メソッドがゼロ長の配列引数で toArray() を使用\nこのメソッドは、コレクション派生クラスの toArray() メソッドを使用し、ゼロ長のプロトタイプ配列引数を渡します。myCollection.toArray(new Foo[myCollection.size()]) を使用する方が効率的です。渡された配列がコレクションのすべての要素を格納するのに十分大きい場合、それを直接返します。これにより、結果として返すために第二の配列を作成する必要がなくなります（リフレクションによる）。",
      "wmi_wrong_map_iterator": "WMI: keySet イテレータの代わりに entrySet イテレータを使用する非効率的な方法\nこのメソッドは、keySet イテレータから取得したキーを使用して Map エントリの値にアクセスします。Map.get(key) の検索を避けるために、Map の entrySet に対してイテレータを使用する方が効率的です。",
      "um_unnecessary_math": "UM: メソッドが定数値に対して static Math クラスメソッドを呼び出す\nこのメソッドは定数値に対して java.lang.Math の静的メソッドを使用します。このメソッドの結果は、場合によっては静的に決定でき、定数を直接使用する方が高速で、時にはより正確です。検出されたメソッドは以下の通りです：\n\nMethod\tParameter\nabs\t-any-\nacos\t0.0 または 1.0\nasin\t0.0 または 1.0\natan\t0.0 または 1.0\natan2\t0.0\ncbrt\t0.0 または 1.0\nceil\t-any-\ncos\t0.0\ncosh\t0.0\nexp\t0.0 または 1.0\nexpm1\t0.0\nfloor\t-any-\nlog\t0.0 または 1.0\nlog10\t0.0 または 1.0\nrint\t-any-\nround\t-any-\nsin\t0.0\nsinh\t0.0\nsqrt\t0.0 または 1.0\ntan\t0.0\ntanh\t0.0\ntoDegrees\t0.0 または 1.0\ntoRadians\t0.0",
      "ima_inefficient_member_access": "IMA: メソッドが所有クラスのプライベートメンバ変数にアクセス\nこのメソッドは内部クラスで、所有クラスのプライベートメンバ変数を読み書きするか、所有クラスのプライベートメソッドを呼び出します。コンパイラはこのプライベートメンバにアクセスするために特別なメソッドを生成し、これにより効率が低下します。メンバ変数またはメソッドの保護を緩和すれば、コンパイラは通常のアクセスとして扱います。",
      "xss_request_parameter_to_send_error": "XSS: エラーページにおけるサーブレット反射型クロスサイトスクリプティングの脆弱性\nこのコードは直接 HTTP パラメータをサーバーエラーページに書き込んでいます（HttpServletResponse.sendError を使用）。この信頼できない入力をエコーすることで反射型クロスサイトスクリプティングの脆弱性を引き起こします。詳細については、クロスサイトスクリプティングのWikipedia を参照してください。\n\nSpotBugsは、クロスサイトスクリプティングの最も明白な事例のみを検出します。SpotBugsが発見した場合、ほぼ確実に他にもクロスサイトスクリプティングの脆弱性が存在しますが、それはSpotBugsでは報告されません。クロスサイトスクリプティングに懸念がある場合、商用の静的解析ツールやペンテストツールを使用することを真剣に検討すべきです。\n\nCWE-81: エラーメッセージWebページでのスクリプトの不適切な無効化、CWE-79: Webページ生成中の入力の不適切な無効化（「クロスサイトスクリプティング」）を参照してください。",
      "xss_request_parameter_to_servlet_writer": "XSS: サーブレット反射型クロスサイトスクリプティングの脆弱性\nこのコードはHTTPパラメータをサーブレット出力に直接書き込むことで、反射型クロスサイトスクリプティングの脆弱性を引き起こします。詳細については、クロスサイトスクリプティングのWikipedia を参照してください。\n\nSpotBugsは、クロスサイトスクリプティングの最も明白な事例のみを検出します。SpotBugsが発見した場合、ほぼ確実に他にもクロスサイトスクリプティングの脆弱性が存在しますが、それはSpotBugsでは報告されません。クロスサイトスクリプティングに懸念がある場合、商用の静的解析ツールやペンテストツールを使用することを真剣に検討すべきです。\n\nCWE-79: Webページ生成中の入力の不適切な無効化（「クロスサイトスクリプティング」）を参照してください。",
      "xss_request_parameter_to_jsp_writer": "XSS: JSP反射型クロスサイトスクリプティングの脆弱性\nこのコードはHTTPパラメータをJSP出力に直接書き込むことで、クロスサイトスクリプティングの脆弱性を引き起こします。詳細については、クロスサイトスクリプティングのWikipedia を参照してください。\n\nSpotBugsは、クロスサイトスクリプティングの最も明白な事例のみを検出します。SpotBugsが発見した場合、ほぼ確実に他にもクロスサイトスクリプティングの脆弱性が存在しますが、それはSpotBugsでは報告されません。クロスサイトスクリプティングに懸念がある場合、商用の静的解析ツールやペンテストツールを使用することを真剣に検討すべきです。\n\nCWE-79: Webページ生成中の入力の不適切な無効化（「クロスサイトスクリプティング」）を参照してください。",
      "hrs_request_parameter_to_http_header": "HRS: HTTPレスポンス分割の脆弱性\nこのコードはHTTPパラメータをHTTPヘッダに直接書き込むことで、HTTPレスポンス分割の脆弱性を引き起こします。詳細については、HTTPレスポンス分割のWikipedia を参照してください。\n\nSpotBugsは、HTTPレスポンス分割の最も明白な事例のみを検出します。SpotBugsが発見した場合、ほぼ確実に他にも脆弱性が存在しますが、それはSpotBugsでは報告されません。HTTPレスポンス分割に懸念がある場合、商用の静的解析ツールやペンテストツールを使用することを真剣に検討すべきです。\n\nCWE-113: HTTPヘッダのCRLFシーケンスの不適切な無効化（「HTTPリクエスト/レスポンス分割」）を参照してください。",
      "hrs_request_parameter_to_cookie": "HRS: 信頼できない入力から構成されたHTTPクッキー\nこのコードは信頼できないHTTPパラメータを使用してHTTPクッキーを構成します。このクッキーがHTTPレスポンスに追加されると、HTTPレスポンス分割の脆弱性を引き起こす可能性があります。詳細については、HTTPレスポンス分割のWikipedia を参照してください。\n\nSpotBugsは、HTTPレスポンス分割の最も明白な事例のみを検出します。SpotBugsが発見した場合、ほぼ確実に他にも脆弱性が存在しますが、それはSpotBugsでは報告されません。HTTPレスポンス分割に懸念がある場合、商用の静的解析ツールやペンテストツールを使用することを真剣に検討すべきです。\n\nCWE-113: HTTPヘッダのCRLFシーケンスの不適切な無効化（「HTTPリクエスト/レスポンス分割」）を参照してください。",
      "pt_absolute_path_traversal": "PT: サーブレットでの絶対パストラバーサル\nこのソフトウェアはHTTPリクエストパラメータを使用して、制限されたディレクトリ内にあるべきパス名を構築しますが、'/abs/path' のような絶対パスシーケンスを適切に無効化しておらず、そのシーケンスがそのディレクトリ外の場所に解決される可能性があります。詳細については、CWE-36 を参照してください。\n\nSpotBugsは、絶対パストラバーサルの最も明白な事例のみを検出します。SpotBugsが発見した場合、ほぼ確実に他にも脆弱性が存在しますが、それはSpotBugsでは報告されません。絶対パストラバーサルに懸念がある場合、商用の静的解析ツールやペンテストツールを使用することを真剣に検討すべきです。\n\nCWE-36: 絶対パストラバーサルを参照してください。",
      "pt_relative_path_traversal": "PT: サーブレットでの相対パストラバーサル\nこのソフトウェアはHTTPリクエストパラメータを使用して、制限されたディレクトリ内にあるべきパス名を構築しますが、'..' のようなシーケンスを適切に無効化しておらず、そのシーケンスがそのディレクトリ外の場所に解決される可能性があります。詳細については、CWE-23 を参照してください。\n\nSpotBugsは、相対パストラバーサルの最も明白な事例のみを検出します。SpotBugsが発見した場合、ほぼ確実に他にも脆弱性が存在しますが、それはSpotBugsでは報告されません。相対パストラバーサルに懸念がある場合、商用の静的解析ツールやペンテストツールを使用することを真剣に検討すべきです。\n\nCWE-23: 相対パストラバーサルを参照してください。",
      "dmi_constant_db_password": "Dm: ハードコードされたデータベースのパスワード\nこのコードはハードコードされた定数のパスワードを使用してデータベース接続を作成します。ソースコードまたはコンパイル済みコードにアクセスできる誰でもこのパスワードを簡単に学ぶことができます。\n\nCWE-259: ハードコードされたパスワードの使用を参照してください。",
      "dmi_empty_db_password": "Dm: 空のデータベースパスワード\nこのコードは空のパスワードまたはブランクのパスワードを使用してデータベース接続を作成します。これは、データベースがパスワードで保護されていないことを示しています。\n\nCWE-259: ハードコードされたパスワードの使用を参照してください。",
      "sql_nonconstant_string_passed_to_execute": "SQL: SQLステートメントのexecuteまたはaddBatchメソッドに非定数文字列が渡される\nこのメソッドは、動的に生成されたと思われるStringを使用して、SQLステートメントのexecuteまたはaddBatchメソッドを呼び出します。代わりに準備されたステートメントを使用することを検討してください。これにより、効率が向上し、SQLインジェクション攻撃に対する脆弱性が減少します。\n\nCWE-89: SQLコマンドで使用される特殊な要素の不適切な無効化（「SQLインジェクション」）を参照してください。",
      "sql_prepared_statement_generated_from_nonconstant_string": "SQL: 非定数文字列から準備されたSQLステートメントが生成される\nこのコードは非定数のStringからSQL準備されたステートメントを作成します。チェックされていない場合、ユーザーからの汚染されたデータがこのStringを構築するために使用され、SQLインジェクションを介して準備されたステートメントが予期しない、望ましくない動作を引き起こす可能性があります。\n\nCWE-89: SQLコマンドで使用される特殊な要素の不適切な無効化（「SQLインジェクション」）を参照してください。",
      "ase_assertion_with_side_effect": "ASE: アサーション内の式が副作用を生じる可能性\nアサーションで使用される式は、副作用を生じるべきではありません。\n\n詳細については、SEI CERT Rule EXP06を参照してください。",
      "ase_assertion_with_side_effect_method": "ASE: アサーションで呼び出されるメソッドが副作用を生じる可能性\nアサーションで使用される式は、副作用を生じるべきではありません。\n\n詳細については、SEI CERT Rule EXP06を参照してください。",
      "caa_covariant_array_field": "CAA: フィールドへの共変配列の代入\n共変型の配列がフィールドに代入されます。これは混乱を招き、実行時に異なる型の参照がこの配列に格納されると、ArrayStoreExceptionが発生する可能性があります。例えば以下のコードのように:\n\nNumber[] arr = new Integer[10];\narr[0] = 1.0;\n作成する配列の型またはフィールド型を変更することを検討してください。",
      "caa_covariant_array_return": "CAA: 共変配列がメソッドから返される\n共変型の配列がメソッドから返されます。これは混乱を招き、呼び出し元のコードが返された配列に他の型の参照を格納しようとすると、実行時にArrayStoreExceptionが発生する可能性があります。\n\n作成した配列の型またはメソッドの戻り値の型を変更することを検討してください。",
      "caa_covariant_array_local": "CAA: 共変配列がローカル変数に代入される\n共変型の配列がローカル変数に代入されます。これは混乱を招き、後でこの配列に他の型の参照が格納されると、実行時にArrayStoreExceptionが発生する可能性があります。例えば、以下のコードのように:\n\nNumber[] arr = new Integer[10];\narr[0] = 1.0;\n作成した配列の型またはローカル変数の型を変更することを検討してください。",
      "dmi_unsupported_method": "Dm: サポートされていないメソッドの呼び出し\nこのメソッド呼び出しのすべてのターゲットはUnsupportedOperationExceptionをスローします。",
      "dmi_thread_passed_where_runnable_expected": "Dm: Runnableが期待される場所にThreadが渡される\nThreadオブジェクトがRunnableが期待されるメソッドのパラメータとして渡されます。これはかなり異常であり、ロジックエラーを示しているか、予期しない動作を引き起こす可能性があります。",
      "np_dereference_of_readline_value": "NP: readLine()の結果をnullチェックなしで逆参照する\nreadLine()を呼び出した結果をnullかどうかを確認せずに逆参照しています。もし読み取るべき行がもうない場合、readLine()はnullを返し、それを逆参照するとnullポインタ例外が発生します。",
      "np_immediate_dereference_of_readline": "NP: readLine()の結果を即座に逆参照する\nreadLine()を呼び出した結果を即座に逆参照しています。もし読み取るべき行がもうない場合、readLine()はnullを返し、それを逆参照するとnullポインタ例外が発生します。",
      "rv_rem_of_random_int": "RV: 32ビット符号付きランダム整数の余り\nこのコードはランダムな符号付き整数を生成し、その値を別の値で割った余りを計算します。ランダムな数が負の場合、余り演算の結果も負になる可能性があります。これが意図したものであることを確認し、代わりにRandom.nextInt(int)メソッドを使用することを強く検討してください。",
      "rv_rem_of_hashcode": "RV: hashCodeの余りが負になる可能性がある\nこのコードはhashCodeを計算し、その値を別の値で割った余りを計算します。hashCodeが負である場合、余り演算の結果も負になる可能性があります。\n\n計算結果が非負であることを確保したい場合、コードを変更する必要があるかもしれません。除数が2のべき乗であることがわかっている場合は、ビット単位のAND演算子を使用することができます（例: x.hashCode()%nの代わりにx.hashCode()&(n-1)を使用）。これにより、余りを計算するよりも速くなる可能性があります。除数が2のべき乗でない場合は、余り演算の結果の絶対値を取ることを検討してください（例: Math.abs(x.hashCode()%n)）。",
      "eq_unusual": "Eq: 異常なequalsメソッド\nこのクラスは、引数の型がこのオブジェクトの型と互換性があるかどうかを確認するために認識されているパターンを使用していません。このコードに何も問題がないかもしれませんが、見直す価値があります。",
      "eq_doesnt_override_equals": "Eq: 親クラスでequalsをオーバーライドしないクラス\nこのクラスはequalsメソッドを定義したクラスを拡張し、フィールドを追加していますが、自身ではequalsメソッドを定義していません。したがって、このクラスのインスタンスの等価性は、サブクラスのアイデンティティと追加されたフィールドを無視します。これが意図したものであることを確認し、equalsメソッドをオーバーライドする必要がないかどうかを検討してください。もしオーバーライドする必要がない場合でも、サブクラスのequalsメソッドが単にsuper.equals(o)の結果を返すことを文書化するためにオーバーライドすることを検討してください。",
      "ns_non_short_circuit": "NS: 短絡論理ではない論理の疑わしい使用\nこのコードは短絡論理（&& または",
      "ns_dangerous_non_short_circuit": "NS: 短絡論理ではない論理の潜在的に危険な使用\nこのコードは短絡論理（&& または",
      "ic_init_circularity": "IC: 初期化の循環\nバグインスタンスで参照される2つのクラスの静的初期化子に循環が検出されました。このような循環からは、予期しない動作が多く発生する可能性があります。",
      "ia_ambiguous_invocation_of_inherited_or_outer_method": "IA: 継承または外部メソッドのどちらかが曖昧に呼び出される可能性\n内部クラスが、継承されたメソッドまたは外部クラスで定義されたメソッドのどちらかに解決される可能性のあるメソッドを呼び出しています。例えば、foo(17)を呼び出す場合、これは親クラスと外部メソッドの両方に定義されています。Javaの意味論において、これは継承されたメソッドを呼び出すことに解決されますが、これが意図されたものではない可能性があります。\n\nもし本当に継承されたメソッドを呼び出すつもりであれば、super.foo(17)を呼び出すことによってそれを行い、コードの他の読者やSpotBugsに対して、外部クラスのメソッドではなく、継承されたメソッドを呼び出す意図があることを明確にします。\n\nthis.foo(17)を呼び出すと、継承されたメソッドが呼び出されます。ただし、SpotBugsはクラスファイルのみを確認するため、this.foo(17)とfoo(17)の呼び出しの違いを区別できません。そのため、潜在的に曖昧な呼び出しについて警告します。",
      "se_private_read_resolve_not_inherited": "Se: プライベートなreadResolveメソッドがサブクラスに継承されていない\nこのクラスはプライベートなreadResolveメソッドを定義しています。プライベートであるため、サブクラスには継承されません。これは意図的で問題ない場合もありますが、それが意図通りであることを確認するために見直す必要があります。",
      "se_transient_field_of_nonserializable_class": "Se: Serializableでないクラスの一時的なフィールド\nフィールドは一時的（transient）としてマークされていますが、クラスはSerializableではないため、一時的としてマークしても全く効果がありません。これは、クラスが以前はSerializableだったときの残りのマークである可能性があります、またはシリアル化がどのように機能するかについての誤解を示している可能性があります。\n\nこのバグは、特別なオプションreportTransientFieldOfNonSerializableClassが設定されている場合のみ報告されます。\n\nCWE-1066: シリアル化制御要素の欠如を参照してください。",
      "sf_switch_fallthrough": "SF: switch文で1つのケースが次のケースにフォールスルーする\nこのメソッドにはswitch文が含まれており、1つのケースが次のケースにフォールスルーします。通常、このケースはbreakまたはreturnで終了する必要があります。\n\nCWE-484: switch文におけるbreak文の省略を参照してください。",
      "sf_switch_no_default": "SF: デフォルトケースが欠落しているswitch文\nこのメソッドには、デフォルトケースが欠落しているswitch文が含まれています。通常、デフォルトケースを提供する必要があります。\n\n解析は生成されたバイトコードのみを確認するため、デフォルトケースがswitch文の最後にあり、他のケースにはbreak文が含まれていない場合、この警告が誤って発生する可能性があります。\n\nCWE-478: 複数条件式のデフォルトケースが欠落しているを参照してください。",
      "uuf_unused_public_or_protected_field": "UuF: 使用されていないpublicまたはprotectedフィールド\nこのフィールドは決して使用されません。このフィールドはpublicまたはprotectedであり、分析の一部として見られないクラスで使用されることを意図している可能性があります。もしそうでなければ、クラスから削除することを検討してください。\n\nCWE-563: 使用されていない変数への代入を参照してください。",
      "urf_unread_public_or_protected_field": "UrF: 読まれていないpublic/protectedフィールド\nこのフィールドは決して読み取られません。このフィールドはpublicまたはprotectedであり、分析の一部として見られないクラスで使用されることを意図している可能性があります。もしそうでなければ、クラスから削除することを検討してください。\n\nCWE-563: 使用されていない変数への代入を参照してください。",
      "qf_questionable_for_loop": "QF: forループ内での複雑で微妙または誤ったインクリメント\nこのforループは正しい変数をインクリメント/デクリメントしていることを確認していますか？別の変数が初期化され、forループでチェックされているようです。",
      "np_unwritten_public_or_protected_field": "NP: 書き込まれていないpublicまたはprotectedフィールドの読み取り\nプログラムが、非null値が書き込まれることがないように見えるpublicまたはprotectedフィールドを逆参照しています。フィールドが解析で見えないメカニズムを介して初期化されない限り、この値を逆参照するとnullポインタ例外が発生します。\n\nCWE-457: 初期化されていない変数の使用を参照してください。",
      "uwf_field_not_initialized_in_constructor": "UwF: コンストラクタ内で初期化されていないフィールドがnullチェックなしで逆参照されている\nこのフィールドはコンストラクタ内で初期化されることがなく、したがってオブジェクトが構築された後でnullになる可能性があります。他の場所で、このフィールドはnullチェックなしで読み込まれ、逆参照されています。これはエラーまたは疑問のある設計かもしれません。なぜなら、このフィールドが初期化される前に逆参照されると、nullポインタ例外が発生するからです。\n\nCWE-457: 初期化されていない変数の使用を参照してください。",
      "uwf_unwritten_public_or_protected_field": "UwF: 書き込まれていないpublicまたはprotectedフィールド\nこのpublic/protectedフィールドには書き込みが見られません。すべての読み取りはデフォルト値を返します。エラーがないか確認してください（初期化されるべきではなかったか？）、または無駄であれば削除してください。\n\nCWE-457: 初期化されていない変数の使用を参照してください。",
      "uc_useless_void_method": "UC: 無駄な非空voidメソッド\n私たちの解析では、この非空voidメソッドは実際には何の有用な作業も行っていないことが示されています。コードに間違いがあるか、その本体を完全に削除することができるか、確認してください。\n\n私たちは誤検出を可能な限り減らそうとしていますが、いくつかのケースではこの警告が間違っている可能性もあります。一般的な誤検出ケースには以下が含まれます：\n\nこのメソッドは、副作用があるクラスのロードをトリガーすることを意図している。\nこのメソッドは、いくつかの難解な例外を暗黙的に投げることを意図している。",
      "uc_useless_condition": "UC: 条件が効果を持たない\nこの条件は、前に絞り込まれた変数の値と常に同じ結果を生成します。おそらく他の意図があったか、条件を削除することができます。\n\nCWE-570: 常に偽の式とCWE-571: 常に真の式を参照してください。",
      "uc_useless_condition_type": "UC: 変数タイプのために条件が効果を持たない\nこの条件は、関与する変数の型範囲により常に同じ結果を生成します。おそらく他の意図があったか、条件を削除することができます。\n\nCWE-570: 常に偽の式とCWE-571: 常に真の式を参照してください。",
      "uc_useless_object": "UC: 無駄に作成されたオブジェクト\n私たちの解析では、このオブジェクトは無駄であることが示されています。作成されて変更されますが、その値はメソッド外には出ませんし、副作用も生じません。何か間違いがあり、オブジェクトが使用されるべきだったか、または削除可能です。\n\nこの解析は誤検出をほとんど生じません。一般的な誤検出ケースには以下が含まれます：\n\n- このオブジェクトは暗黙的に難解な例外を投げるために使用されていました。\n\n- このオブジェクトはコードを一般化するためのスタブとして使用されていました。\n\n- このオブジェクトは弱参照またはソフト参照されたオブジェクトへの強い参照を保持するために使用されていました。",
      "uc_useless_object_stack": "UC: スタック上で作成された無駄なオブジェクト\nこのオブジェクトは副作用を伴わない修正を行うためだけに作成されました。おそらく他の意図があったか、オブジェクトは削除可能です。",
      "rv_return_value_ignored_inferred": "RV: メソッドの戻り値を無視する、これは問題ないのか？\nこのコードはメソッドを呼び出し、その戻り値を無視しています。戻り値はメソッドが呼ばれた型と同じ型であり、私たちの解析によると、戻り値は重要である可能性があるようです（例：String.toLowerCase()の戻り値を無視するような場合）。\n\n私たちは、メソッドの本体を単純に解析することによって、戻り値を無視するのは悪いアイデアかもしれないと推測しています。@CheckReturnValueアノテーションを使用して、SpotBugsにこのメソッドの戻り値を無視することが許容されることを指示できます。\n\n戻り値を無視することが許容されるかどうかを決定するために、慎重に調査してください。",
      "rv_return_value_ignored_no_side_effect": "RV: 副作用のないメソッドの戻り値が無視されている\nこのコードはメソッドを呼び出し、その戻り値を無視しています。しかし、私たちの解析によると、そのメソッド（サブクラス内での実装を含む）は戻り値以外の効果を生じません。したがって、この呼び出しは削除できます。\n\n私たちは誤検出を可能な限り減らそうとしていますが、いくつかのケースではこの警告が間違っている可能性があります。一般的な誤検出ケースには以下が含まれます：\n\n- メソッドはオーバーライドされるように設計されており、分析の範囲外の他のプロジェクトで副作用を生じます。\n\n- メソッドはクラスの読み込みをトリガーするために呼び出され、これが副作用を生じます。\n\n- メソッドは単に例外を取得するために呼び出されます。\n\n私たちの推測が間違っていると思われる場合、@CheckReturnValueアノテーションを使用して、SpotBugsにこのメソッドの戻り値を無視することが許容されることを指示できます。",
      "rv_check_for_positive_indexof": "RV: メソッドがString.indexOfの結果が正かどうかをチェックしている\nメソッドはString.indexOfを呼び出し、その結果が正か非正かをチェックします。結果が負か非負かをチェックする方が一般的です。結果が正であるのは、チェックした部分文字列がStringの先頭以外の位置に存在する場合のみです。",
      "rv_dont_just_null_check_readline": "RV: readLineの結果が非nullであるかをチェックした後、その結果を破棄している\nreadLineによって返された値は、戻り値が非nullであるかを確認した後、破棄されています。ほとんどの状況では、結果が非nullであれば、その非null値を使用するべきです。再度readLineを呼び出すと、別の行が返されます。",
      "np_parameter_must_be_nonnull_but_marked_as_nullable": "NP: パラメータはnullでない必要があるが、nullableとしてマークされている\nこのパラメータは常にnullでない必要がある方法で使用されますが、パラメータは明示的にNullableとして注釈されています。パラメータの使用または注釈が誤っている可能性があります。",
      "np_null_on_some_path_from_return_value": "NP: 呼び出したメソッドの戻り値による可能性のあるヌルポインタ参照\nメソッドの戻り値がヌルチェックなしで参照され、その戻り値は一般的にヌルかどうかをチェックすべきものです。コードが実行されると、NullPointerExceptionが発生する可能性があります。",
      "np_null_on_some_path_might_be_infeasible": "NP: 実行不可能な分岐での可能性のあるヌルポインタ参照\n実行されると、ヌル値が参照されることが保証される文の分岐があります。これにより、コード実行時にNullPointerExceptionが発生します。もちろん、この問題はその分岐や文が実行不可能であり、ヌルポインタ例外が実行されることはない可能性があるということかもしれません。その判断はSpotBugsではできません。以前にヌルチェックが行われていたため、この可能性は確実です。",
      "np_load_of_known_null_value": "NP: 既知のヌル値のロード\nこのポイントで参照されている変数は、以前のヌルチェックによりヌルであることが知られています。これは有効ですが、間違いの可能性もあります（おそらく異なる変数を参照する意図だったか、変数がヌルかどうかをチェックする前にその非ヌル性をチェックすべきだったかもしれません）。",
      "pzla_prefer_zero_length_arrays": "PZLA: ヌルではなく長さゼロの配列を返すことを検討\n結果がないことを示すために、ヌル参照を返す代わりに長さゼロの配列を返す方が一般的に良い設計です（つまり、結果の空のリスト）。このようにすると、メソッドのクライアントによるヌルの明示的なチェックが不要になります。\n\n一方で、ヌルを「この質問に対する答えはない」と示すために使用することは適切な場合もあります。例えば、File.listFiles()はファイルがないディレクトリが与えられた場合、空のリストを返し、ファイルがディレクトリでない場合はヌルを返します。",
      "ucf_useless_control_flow": "UCF: 無駄な制御フロー\nこのメソッドには、分岐を取ったかどうかに関係なく、制御フローが同じ場所に続く無駄な制御フローステートメントがあります。例えば、if文に空のステートメントブロックがあることが原因です：\n\nif (argv.length == 0) {\n    // TODO: このケースを処理\n}",
      "ucf_useless_control_flow_next_line": "UCF: 次の行への無駄な制御フロー\nこのメソッドには、分岐を取ったかどうかに関係なく、制御フローが同じ行または次の行に続く無駄な制御フローステートメントがあります。しばしば、if文の本体として空のステートメントを誤って使用したことが原因です。例えば：\n\nif (argv.length == 1);\n    System.out.println('Hello, ' + argv[0]);",
      "rcn_redundant_nullcheck_of_null_value": "RCN: 既知のヌル値に対する冗長なヌルチェック\nこのメソッドには、ヌルであることが既知の値に対する冗長なヌルチェックがあります。",
      "rcn_redundant_nullcheck_of_nonnull_value": "RCN: 既知の非ヌル値に対する冗長なヌルチェック\nこのメソッドには、非ヌルであることが既知の値に対する冗長なヌルチェックがあります。",
      "rcn_redundant_comparison_two_null_values": "RCN: 二つのヌル値に対する冗長な比較\nこのメソッドには、両方の参照が明確にヌルであることが既知の二つのヌル値に対する冗長な比較があります。",
      "rcn_redundant_comparison_of_null_and_nonnull_value": "RCN: 非ヌル値とヌルに対する冗長な比較\nこのメソッドには、非ヌルであることが既知の参照とヌルであることが既知の参照に対する冗長な比較があります。",
      "sa_local_self_assignment": "SA: ローカル変数の自己代入\nこのメソッドには、ローカル変数の自己代入があります。例：\n\npublic void foo() {\n    int x = 3;\n    x = x;\n}\nこのような代入は無駄であり、論理エラーやタイプミスを示す可能性があります。",
      "int_bad_rem_by_1": "INT: 1による整数の余剰\n( exp % 1 )という式は常にゼロを返すことが保証されています。( exp & 1 )または( exp % 2 )を意味していたのでしょうか？",
      "int_vacuous_comparison": "INT: 整数値の無意味な比較\n常に同じ値を返す整数比較があります（例：x <= Integer.MAX_VALUE）。",
      "int_vacuous_bit_operation": "INT: 整数値に対する無意味なビットマスク操作\nこれは有効な操作を行わない整数のビット操作（and、or、排他的or）です（例：v & 0xffffffff）。",
      "sa_local_double_assignment": "SA: ローカル変数の二重代入\nこのメソッドにはローカル変数の二重代入があります。例：\n\npublic void foo() {\n    int x, y;\n    x = x = 17;\n}\n変数に同じ値を2回代入するのは無駄であり、論理エラーやタイプミスを示す可能性があります。",
      "sa_field_double_assignment": "SA: フィールドの二重代入\nこのメソッドにはフィールドの二重代入があります。例：\n\nint x, y;\npublic void foo() {\n    x = x = 17;\n}\nフィールドに同じ値を2回代入するのは無駄であり、論理エラーやタイプミスを示す可能性があります。",
      "dls_dead_local_store_in_return": "DLS: return文での無駄な代入\nこの文はreturn文内でローカル変数に代入を行いますが、この代入は効果がありません。この文が正しいことを確認してください。\n\nCWE-563: 使用されない変数への代入を参照。",
      "dls_dead_local_store": "DLS: ローカル変数へのデッドストア\nこの命令はローカル変数に値を代入しますが、その値は後続の命令で読み取られたり使用されたりしません。多くの場合、計算された値が使用されていないことを示しているため、エラーを示す可能性があります。\n\nSunのjavacコンパイラは、finalローカル変数に対してデッドストアを生成することがよくあります。SpotBugsはバイトコードベースのツールであるため、これらの誤検出を排除する簡単な方法はありません。\n\nCWE-563: 使用されない変数への代入を参照。",
      "dls_dead_local_store_shadows_field": "DLS: フィールドを隠すローカル変数へのデッドストア\nこの命令はローカル変数に値を代入しますが、その値は後続の命令で読み取られたり使用されたりしません。多くの場合、計算された値が使用されていないことを示しているため、エラーを示す可能性があります。ローカル変数と同じ名前のフィールドがあります。そのフィールドに代入しようとしたのでしょうか？\n\nCWE-563: 使用されない変数への代入を参照。",
      "dls_dead_local_store_of_null": "DLS: ローカル変数へのnullのデッドストア\nコードはローカル変数にnullを格納しますが、格納された値は読み取られません。このストアはガーベジコレクターの支援のために導入された可能性がありますが、Java SE 6.0以降、これが必要なくなったり有用でなくなったりしています。\n\nCWE-563: 使用されない変数への代入を参照。",
      "rec_catch_exception": "REC: 例外がスローされていないのに例外がキャッチされる\nこのメソッドはtry-catchブロックを使用して例外オブジェクトをキャッチしますが、tryブロック内では例外がスローされず、RuntimeExceptionは明示的にキャッチされていません。多くの種類の例外をキャッチするための省略形としてtry { ... } catch (Exception e) { something }のように書くことは一般的なバグパターンですが、この構造はRuntimeExceptionも誤ってキャッチし、潜在的なバグを隠す可能性があります。\n\nより良いアプローチは、スローされる特定の例外を明示的にキャッチするか、RuntimeExceptionを明示的にキャッチして再スローし、その後すべての非Runtime例外をキャッチすることです。次のように記述できます：\n\ntry {\n    ...\n} catch (RuntimeException e) {\n    throw e;\n} catch (Exception e) {\n    ... 非Runtime例外を処理 ...\n}\nCWE-396: 汎用例外に対するキャッチの宣言を参照。",
      "dcn_nullpointer_exception": "DCN: NullPointerExceptionがキャッチされました\nSEI CertのルールERR08-Jによれば、NullPointerExceptionはキャッチすべきではありません。NullPointerExceptionの処理はnullチェックを行うより劣った選択肢と見なされます。\n\nこの非準拠コードは、NullPointerExceptionをキャッチして、渡されたパラメータがnullであるかどうかを確認しています：\n\n\nboolean hasSpace(String m) {\n  try {\n    String ms[] = m.split(' ');\n    return names.length != 1;\n  } catch (NullPointerException e) {\n    return false;\n  }\n}\n準拠した解決策は、以下の例のようにnullチェックを使用します：\n\n\nboolean hasSpace(String m) {\n    if (m == null) return false;\n    String ms[] = m.split(' ');\n    return names.length != 1;\n}\nCWE-395: NullPointerExceptionキャッチによるNULLポインターデリファレンスの検出の使用を参照。",
      "fe_floating_point_equality": "FE: 浮動小数点の等価性のテスト\nこの操作は、2つの浮動小数点値の等価性を比較します。浮動小数点計算は丸めを含む場合があり、計算されたfloatおよびdoubleの値は正確でない可能性があります。金銭的な値など、精度が必要な値にはBigDecimalなどの固定精度型の使用を検討してください。精度が必要でない値については、ある範囲内で等価性を比較することを検討してください。例えば：if ( Math.abs(x - y) < .0000001 )。Java言語仕様、セクション4.2.4を参照。",
      "cd_circular_dependency": "CD: クラス間の循環依存関係のテスト\nこのクラスには他のクラスとの循環依存関係があります。これにより、これらのクラスを構築することが難しくなります。各クラスは正しく構築するために他のクラスに依存しています。インターフェースを使用してハード依存関係を解消することを検討してください。",
      "ri_redundant_interfaces": "RI: クラスがスーパークラスと同じインターフェースを実装している\nこのクラスは、スーパークラスと同じインターフェースを実装していると宣言しています。これは冗長です。なぜなら、スーパークラスがインターフェースを実装すると、すべてのサブクラスはデフォルトでこのインターフェースも実装するためです。これは、このクラスが作成されたときに継承階層が変更されたことを示しているかもしれません。インターフェースの実装の所有権について再考する必要があります。",
      "mtia_suspect_struts_instance_field": "MTIA: クラスがStruts Actionクラスを拡張し、インスタンス変数を使用している\nこのクラスはStruts Actionクラスを拡張し、インスタンスメンバ変数を使用しています。StrutsフレームワークはStruts Actionクラスのインスタンスを1つのみ作成し、それをマルチスレッドで使用します。このパラダイムは非常に推奨されず、問題を引き起こす可能性があります。メソッドローカル変数のみを使用することを検討してください。インスタンスフィールドは、モニター外で書き込まれる場合にのみ報告されます。",
      "mtia_suspect_servlet_instance_field": "MTIA: クラスがServletクラスを拡張し、インスタンス変数を使用している\nこのクラスはServletクラスを拡張し、インスタンスメンバ変数を使用しています。J2EEフレームワークはServletクラスのインスタンスを1つのみ作成し、それをマルチスレッドで使用します。このパラダイムは非常に推奨されず、問題を引き起こす可能性があります。メソッドローカル変数のみを使用することを検討してください。",
      "ps_public_semaphores": "PS: クラスがその公開インターフェースで同期とセマフォを公開している\nこのクラスは同期を使用しており、wait()、notify()、またはnotifyAll()を自分自身（this参照）で呼び出しています。このクラスを使用するクライアントクラスは、このクラスのインスタンスを同期オブジェクトとして使用する場合があります。2つのクラスが同じオブジェクトを同期に使用しているため、マルチスレッドの整合性が疑わしいです。公開参照で同期を行ったり、セマフォメソッドを呼び出したりしないでください。同期を制御するために内部のプライベートメンバ変数を使用することを検討してください。",
      "icast_integer_multiply_cast_to_long": "ICAST: 整数乗算の結果をlongにキャスト\nこのコードは整数の乗算を行い、結果をlongに変換します。例えば:\n\nlong convertDaysToMilliseconds(int days) { return 1000360024days; }\n乗算がlong算術を使って行われる場合、結果がオーバーフローする可能性を避けることができます。例えば、上記のコードを以下のように修正できます：\n\nlong convertDaysToMilliseconds(int days) { return 1000L360024days; }\nまたは\n\nstatic final long MILLISECONDS_PER_DAY = 24L36001000;\nlong convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }\nCWE-192: 整数型の強制エラーを参照。",
      "icast_idiv_cast_to_double": "ICAST: 整数の除算結果をdoubleまたはfloatにキャスト\nこのコードは整数の除算結果（例えばintまたはlongの除算操作）をdoubleまたはfloatにキャストします。整数の除算では、結果がゼロに最も近い整数値に切り捨てられます。結果がdoubleにキャストされているということは、この精度を保持すべきだったことを示唆しています。おそらく意図されたのは、除算を行う前に、1つまたは両方のオペランドをdoubleにキャストすることです。以下の例を示します：\n\nint x = 2;\nint y = 5;\n// 誤り: 結果は0.0になる\ndouble value1 = x / y;\n\n// 正しい: 結果は0.4になる\ndouble value2 = x / (double) y;\nCWE-192: 整数型の強制エラーを参照。",
      "bc_bad_cast_to_concrete_collection": "BC: 具体的なコレクションへのキャストが疑わしい\nこのコードは抽象的なコレクション（例えば、Collection、List、Set）を特定の具体的な実装（例えば、ArrayListやHashSet）にキャストしています。これは正しくない場合があり、将来的に他の具体的な実装に切り替えることが難しくなるため、コードが脆弱になる可能性があります。特別な理由がない限り、抽象的なコレクションクラスを使用するだけでよいでしょう。",
      "bc_unconfirmed_cast": "BC: チェックされていない/確認されていないキャスト\nこのキャストはチェックされておらず、キャスト元の型のすべてのインスタンスがキャスト先の型にキャストできるわけではありません。プログラムのロジックがこのキャストが失敗しないことを保証することを確認してください。",
      "bc_unconfirmed_cast_of_return_value": "BC: メソッドの戻り値のチェックされていない/確認されていないキャスト\nこのコードはメソッドの戻り値に対してチェックされていないキャストを行っています。コードは、キャストが安全であることが保証されている方法でメソッドを呼び出しているかもしれませんが、SpotBugsはそのキャストが安全であることを確認できません。プログラムのロジックがこのキャストが失敗しないことを保証することを確認してください。",
      "bc_vacuous_instanceof": "BC: instanceofは常にtrueを返す\nこのinstanceofテストは常にtrueを返します（nullでない限り）。これは安全ですが、誤解や他のロジックエラーの兆候でないことを確認してください。もし本当に値がnullであるかどうかをテストしたいのであれば、instanceofテストよりもnullテストを行う方が明確であるかもしれません。\n\nCWE-571: 式が常にtrueを返すを参照。",
      "bc_bad_cast_to_abstract_collection": "BC: 抽象的なコレクションへのキャストが疑わしい\nこのコードはCollectionを抽象的なコレクション（例えば、List、Set、Map）にキャストしています。キャスト先の型であることが保証されていることを確認してください。コレクションを反復処理するだけが必要であれば、SetやListにキャストする必要はありません。\n\nCWE-704: 不正な型変換またはキャストを参照。",
      "im_bad_check_for_odd": "IM: 負の数に対して機能しない奇数チェック\nこのコードはx % 2 == 1を使用して値が奇数かどうかを確認していますが、これは負の数には機能しません（例えば、(-5) % 2 == -1）。もしこのコードが奇数をチェックすることを意図しているのであれば、(x & 1) == 1、またはx % 2 != 0を使用することを検討してください。",
      "im_average_computation_could_overflow": "IM: 平均の計算がオーバーフローする可能性がある\nこのコードは、2つの整数の平均を計算する際に除算または符号付き右シフトを使用し、その結果を配列のインデックスとして使用します。平均を取る値が非常に大きい場合、これがオーバーフローを引き起こし（負の平均値が計算される結果になります）、もし結果が非負であることを意図している場合、符号なし右シフトを使用することができます。つまり、(low+high)/2を使用する代わりに、(low+high) >>> 1を使用します。\n\nこのバグは、バイナリサーチやマージソートの多くの初期実装に存在します。Martin Buchholzはこれを発見し、JDKライブラリで修正しました。Joshua Blochはこのバグパターンを広く公表しました。",
      "icast_questionable_unsigned_right_shift": "BSHIFT: 符号なし右シフトをshort/byteにキャスト\nこのコードは符号なし右シフトを行い、その結果をshortまたはbyteにキャストしています。これにより、結果の上位ビットが破棄されます。上位ビットが破棄されるため、符号付きおよび符号なし右シフトに違いがない場合があります（シフト量による）。\n\nCWE-192: 整数型の強制エラーを参照。",
      "dmi_hardcoded_absolute_filename": "DMI: 絶対パス名へのハードコーディングされた参照\nこのコードは、絶対パス名へのハードコーディングされた参照を使用してFileオブジェクトを作成しています（例：new File('/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment');）。",
      "dmi_useless_substring": "DMI: substring(0)の呼び出し、元の値を返す\nこのコードは、Stringに対してsubstring(0)を呼び出していますが、これは元の値を返します。",
      "st_write_to_static_from_instance_method": "ST: インスタンスメソッドから静的フィールドに書き込み\nこのインスタンスメソッドは静的フィールドに書き込みを行います。複数のインスタンスが操作されている場合、この動作は正しく行うのが難しく、一般的に悪いプラクティスとされています。",
      "dmi_nonserializable_object_written": "DMI: 非シリアライズ可能なオブジェクトをObjectOutputに書き込む\nこのコードは、非シリアライズ可能なオブジェクトをObjectOutput.writeObjectメソッドに渡しているようです。もしオブジェクトが実際に非シリアライズ可能であれば、エラーが発生します。",
      "db_duplicate_branches": "DB: メソッドが2つの分岐に同じコードを使用\nこのメソッドは、条件分岐の2つのブランチに同じコードを使用しています。これがコーディングミスでないことを確認してください。\n\nCWE-1041: 冗長なコードの使用を参照。",
      "db_duplicate_switch_clauses": "DB: メソッドが2つのswitch文に同じコードを使用\nこのメソッドは、switch文の2つの節に同じコードを使用しています。これは重複したコードの可能性がありますが、コーディングミスである可能性もあります。\n\nCWE-1041: 冗長なコードの使用を参照。",
      "xfb_xml_factory_bypass": "XFB: メソッドがxmlインターフェイスの特定の実装を直接割り当て\nこのメソッドは、xmlインターフェイスの特定の実装を割り当てています。これらのオブジェクトを作成するために提供されたファクトリークラスを使用する方が好ましいです。これにより、実装をランタイムで変更できるようになります。\n\n詳細については以下を参照:\n\njavax.xml.parsers.DocumentBuilderFactory\njavax.xml.parsers.SAXParserFactory\njavax.xml.transform.TransformerFactory\norg.w3c.dom.Document.createXXXX",
      "usm_useless_subclass_method": "USM: メソッドが親クラスのメソッドを冗長に委譲\nこの派生メソッドは、受け取った正確なパラメータを渡して親クラスの同じメソッドを呼び出すだけです。このメソッドは、追加の価値を提供しないため削除できます。",
      "usm_useless_abstract_method": "USM: 抽象メソッドがすでに実装されたインターフェースに定義されている\nこの抽象メソッドは、この抽象クラスが実装したインターフェースにすでに定義されています。このメソッドは、追加の価値を提供しないため削除できます。",
      "ci_confused_inheritance": "CI: クラスがfinalであるが、保護されたフィールドを宣言している\nこのクラスはfinalとして宣言されていますが、フィールドが保護されているとして宣言されています。クラスがfinalであるため、継承できず、保護されたフィールドの使用は混乱を招きます。フィールドのアクセス修飾子は、フィールドの実際の使用を表すためにprivateまたはpublicに変更する必要があります。",
      "tq_explicit_unknown_source_value_reaches_never_sink": "TQ: 型修飾子を持たないことが求められている値が、未知としてマークされている\n値が、型修飾子で示されないことが求められる方法で使用されていますが、値にその型修飾子が付加されることが禁止されていることを示す明示的な注釈があります。使用法または注釈が誤っている可能性があります。",
      "tq_explicit_unknown_source_value_reaches_always_sink": "TQ: 型修飾子を持つことが求められている値が、未知としてマークされている\n値が、常に型修飾子で示されることが求められる方法で使用されていますが、値にその型修飾子を持つ必要があることを示す明示的な注釈があります。使用法または注釈が誤っている可能性があります。",
      "np_method_return_relaxing_annotation": "NP: メソッドが戻り値のnullness注釈を緩和している\nメソッドは、オーバーライドするメソッドの契約を常に実装すべきです。したがって、メソッドが@Nonnullとして戻り値が注釈付けされている場合、そのメソッドを@Nullableまたは@CheckForNullとして戻り値が注釈付けされたメソッドでオーバーライドしてはいけません。このようなことは、メソッドがnullを返してはならないという契約に違反します。",
      "np_method_parameter_tightens_annotation": "NP: メソッドがパラメータのnullness注釈を厳しくしている\nメソッドは、オーバーライドするメソッドの契約を常に実装すべきです。したがって、メソッドが@Nullableとしてマークされたパラメータを受け取る場合、そのメソッドを@Nonnullとしてパラメータが注釈付けされたメソッドでオーバーライドしてはいけません。このようなことは、メソッドがnullのパラメータを処理する必要があるという契約に違反します。",
      "us_useless_suppression_on_field": "US: フィールドに対する無駄な抑制\n@SuppressionFBWarningsの注釈は、もはや必要でない場合、ソースコードから削除すべきです。それを残しておくと、警告が偶発的に抑制される可能性があります。おそらく、この注釈はSpotBugsが報告した警告を抑制するために追加されたものであり、現在SpotBugsはそのバグを報告していません。バグは解決されたか、SpotBugsが更新されて、もうそのコードからそのバグは報告されていません。",
      "us_useless_suppression_on_class": "US: クラスに対する無駄な抑制\n@SuppressionFBWarningsの注釈は、もはや必要でない場合、ソースコードから削除すべきです。それを残しておくと、警告が偶発的に抑制される可能性があります。",
      "us_useless_suppression_on_method": "US: メソッドに対する無駄な抑制\n@SuppressionFBWarningsの注釈は、もはや必要でない場合、ソースコードから削除すべきです。それを残しておくと、警告が偶発的に抑制される可能性があります。おそらく、この注釈はSpotBugsが報告した警告を抑制するために追加されたものであり、現在SpotBugsはそのバグを報告していません。バグは解決されたか、SpotBugsが更新されて、もうそのコードからそのバグは報告されていません。",
      "us_useless_suppression_on_method_parameter": "US: メソッドパラメータに対する無駄な抑制\n@SuppressionFBWarningsの注釈は、もはや必要でない場合、ソースコードから削除すべきです。それを残しておくと、警告が偶発的に抑制される可能性があります。おそらく、この注釈はSpotBugsが報告した警告を抑制するために追加されたものであり、現在SpotBugsはそのバグを報告していません。バグは解決されたか、SpotBugsが更新されて、もうそのコードからそのバグは報告されていません。",
      "us_useless_suppression_on_package": "US: パッケージに対する無駄な抑制\n@SuppressFBWarningsの抑制注釈は、もはや必要でない場合、ソースコードから削除すべきです。それを残しておくと、警告が偶発的に抑制される可能性があります。この注釈は、おそらくSpotBugsが報告した警告を抑制するために追加されたものであり、現在SpotBugsはそのバグを報告していません。バグは解決されたか、SpotBugsが更新されて、もうそのコードからそのバグは報告されていません。"
    }
  }
}
