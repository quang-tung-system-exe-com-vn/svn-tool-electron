{
  "common": {
    "close": "Đóng",
    "cancel": "Hủy",
    "save": "Lưu",
    "add": "Thêm",
    "delete": "Xóa",
    "install": "Cài đặt",
    "update": "Cập nhật ngay",
    "refresh": "Làm mới",
    "reload": "Tải lại",
    "choose": "Chọn thư mục",
    "swap": "Đổi bên",
    "next": "Tiếp",
    "back": "Quay lại",
    "send": "Gửi",
    "sending": "Đang gửi...",
    "copy": "Sao chép",
    "generate": "Tạo thông điệp commit",
    "check": "Kiểm tra quy tắc mã hóa",
    "commit": "Commit mã",
    "noData": "Không có dữ liệu",
    "skip": "Bỏ qua",
    "finish": "Hoàn thành",
    "startTour": "Bắt đầu",
    "dontShowAgain": "Không hiển thị lại"
  },
  "message": {
    "commitMessageWarning": "Vui lòng nhập thông điệp commit!",
    "noFilesWarning": "Chưa có file nào được chọn!",
    "loading": "Đang tải...",
    "noIssues": "Không tìm thấy vấn đề",
    "selectIssue": "Chọn một vấn đề để xem chi tiết",
    "noFilesChanged": "Chưa có file nào được thay đổi hoặc thêm mới kể từ lần commit cuối.",
    "rowSelected": "{{0}} của {{1}} hàng được chọn.",
    "aiContentWarning": "Nội dung này được tạo bởi AI và có thể không hoàn toàn chính xác. Vui lòng kiểm tra kỹ lưỡng trước khi thực hiện commit."
  },
  "title": {
    "settings": "Cài đặt",
    "about": "Giới thiệu",
    "checkForUpdate": "Kiểm tra cập nhật",
    "checkForUpdate1": "Có bản cập nhật mới! ({{0}})",
    "contact": "Liên hệ",
    "updateSvn": "SVN (Phiên bản hiện tại: {{0}})",
    "updateSvn1": "Có bản SVN mới! ({{0}}) - (Hiện tại: {{1}})",
    "cleanSvn": "Dọn dẹp SVN",
    "showLogsSvn": "Hiển thị nhật ký SVN",
    "supportFeedback": "Hỗ trợ & Phản hồi",
    "historyCommitMessage": "Lịch sử thông điệp commit",
    "startTour": "Bắt đầu Hướng dẫn Ứng dụng"
  },
  "label": {
    "line": "Dòng",
    "column": "Cột"
  },
  "table": {
    "status": "Trạng thái",
    "filePath": "Đường dẫn",
    "extension": "Phần mở rộng",
    "severity": "Mức độ nghiêm trọng",
    "issue": "Vấn đề",
    "line": "Dòng",
    "type": "Loại",
    "message": "Thông báo",
    "category": "Danh mục",
    "priority": "Ưu tiên",
    "rank": "Xếp hạng",
    "location": "Vị trí",
    "file": "Tập tin",
    "class": "Lớp",
    "method": "Phương thức"
  },
  "placeholder": {
    "commitMessage": "Nhập thông điệp commit...",
    "referenceId": "Mã tham chiếu (ví dụ: No.344)",
    "search": "Tìm kiếm",
    "selectLanguage": "Chọn ngôn ngữ...",
    "noLanguage": "Không tìm thấy ngôn ngữ."
  },
  "toast": {
    "success": "Thành công",
    "error": "Lỗi",
    "info": "Thông tin",
    "warning": "Cảnh báo",
    "getListSuccess": "Lấy danh sách file thay đổi thành công",
    "commitSuccess": "Commit thành công",
    "commitError": "Lỗi commit",
    "checkSuccess": "Phân tích thành công",
    "checkError": "Lỗi phân tích",
    "generateSuccess": "Tạo thông điệp commit thành công",
    "generateError": "Lỗi tạo thông điệp commit",
    "updateAvailable": "Có bản cập nhật mới!",
    "isLatestVersion": "Mọi thứ đã được cập nhật.",
    "checkUpdates": "Kiểm tra cập nhật",
    "updatingMessage": "Đang cập nhật SVN...",
    "updateSuccess": "Cập nhật SVN thành công",
    "updateError": "Lỗi khi cập nhật SVN",
    "spotbugsError": "Lỗi khi chạy SpotBugs: {{0}}",
    "spotbugsSuccess": "Phân tích SpotBugs hoàn tất: {{0}} vấn đề được tìm thấy",
    "refreshingSpotbugs": "Đang làm mới phân tích SpotBugs...",
    "leastOneJavaFile": "Please select at least one Java file",
    "fileSaved": "File đã được lưu thành công.",
    "errorSavingFile": "Lỗi khi lưu file.",
    "fetchHistoryError": "Lỗi khi lấy lịch sử commit",
    "copied": "Đã sao chép vào clipboard!",
    "loadSuccess": "Tải thành công.",
    "configSaved": "Lưu thành công.",
    "configSaveFailed": "Lưu thất bại."
  },
  "joyride": {
    "titlebar": {
      "settings": "Mở hộp thoại cài đặt để cấu hình các tùy chọn ứng dụng như chủ đề, ngôn ngữ và khóa API.",
      "about": "Xem thông tin về ứng dụng, bao gồm phiên bản và chi tiết nhà phát triển.",
      "support": "Mở hộp thoại hỗ trợ và phản hồi để gửi yêu cầu hoặc đề xuất.",
      "history": "Xem lịch sử các thông điệp commit đã tạo.",
      "appUpdate": "Kiểm tra cập nhật ứng dụng. Dấu chấm đỏ cho biết phiên bản mới đã được tải xuống và sẵn sàng cài đặt.",
      "svnUpdate": "Kiểm tra cập nhật SVN trong bản sao làm việc của bạn. Dấu chấm đỏ cho biết có các phiên bản mới.",
      "svnClean": "Mở hộp thoại dọn dẹp SVN để quản lý bản sao làm việc của bạn.",
      "svnLog": "Hiển thị lịch sử nhật ký SVN cho bản sao làm việc hiện tại.",
      "startTour": "Hướng dẫn nhanh giúp bạn làm quen với các tính năng chính. Nhấn 'Bắt đầu' để bắt đầu sử dụng ứng dụng dễ dàng hơn!"
    },
    "main": {
      "step1": "Bảng này hiển thị các tệp đã bị thay đổi, thêm mới hoặc xóa trong bản sao làm việc SVN của bạn. Chọn các tệp bạn muốn đưa vào commit.",
      "referenceId": "Nhập mã tham chiếu cho commit của bạn. Mã này sẽ được thêm vào đầu thông điệp commit (ví dụ: No.344).",
      "step2": "Khu vực này dành cho thông điệp commit của bạn. Bạn có thể viết thủ công hoặc tạo tự động bằng AI.",
      "step3": "Nhấp vào nút này để tạo thông điệp commit dựa trên các thay đổi của tệp đã chọn bằng AI.",
      "step4": "Nhấp vào nút này để kiểm tra các tệp đã chọn theo các quy tắc mã hóa được định sẵn.",
      "step5": "Nhấp vào nút này để chạy phân tích SpotBugs trên các tệp Java đã chọn.",
      "step6": "Nhấp vào nút này để commit các tệp đã chọn cùng với thông điệp commit đã cung cấp vào kho lưu trữ SVN."
    },
    "settings": {
      "appearanceTab": "Tab Giao diện: Tùy chỉnh giao diện, bao gồm ngôn ngữ, chủ đề, chế độ tối, phông chữ và kiểu nút.",
      "language": "Ngôn ngữ: Chọn ngôn ngữ ưa thích cho giao diện ứng dụng.",
      "theme": "Chủ đề: Chọn chủ đề màu sắc cho ứng dụng.",
      "darkMode": "Chế độ tối: Chuyển đổi giữa chủ đề sáng và tối.",
      "fontFamily": "Phông chữ: Chọn kiểu phông chữ cho ứng dụng.",
      "fontSize": "Cỡ chữ: Điều chỉnh kích thước văn bản (Nhỏ, Trung bình, Lớn).",
      "buttonVariant": "Kiểu nút: Chọn kiểu cho các nút (Mặc định, Phá hủy, Viền, Phụ, Mờ, Liên kết).",
      "configurationTab": "Tab Cấu hình: Thiết lập các cài đặt cần thiết như khóa API, đường dẫn thư mục và tích hợp.",
      "openaiApiKey": "Khóa API OpenAI: Nhập khóa của bạn cho các tính năng AI như tạo thông điệp commit.",
      "svnFolder": "Thư mục SVN: Chỉ định đường dẫn đến bản sao làm việc SVN chính của bạn.",
      "sourceFolder": "Thư mục nguồn: Chỉ định đường dẫn đến thư mục mã nguồn của dự án (dùng cho các công cụ phân tích như SpotBugs).",
      "emailPL": "Email PL: Nhập địa chỉ email của Trưởng dự án để nhận thông báo.",
      "webhookMS": "Webhook MS: Chọn hoặc thêm URL webhook Microsoft Teams để gửi thông báo.",
      "mailserverTab": "Tab Máy chủ Mail: Cấu hình cài đặt SMTP để gửi thông báo qua email.",
      "smtpServer": "Máy chủ SMTP: Nhập địa chỉ máy chủ SMTP của bạn (ví dụ: smtp.example.com).",
      "port": "Cổng: Nhập số cổng cho máy chủ SMTP (ví dụ: 587).",
      "mailEmail": "Email: Nhập địa chỉ email để gửi thông báo từ đó.",
      "mailPassword": "Mật khẩu: Nhập mật khẩu cho tài khoản email.",
      "onedriveTab": "Tab OneDrive: Cấu hình thông tin đăng nhập Microsoft OneDrive để tải lên hình ảnh (ví dụ: cho tệp đính kèm phản hồi).",
      "onedriveClientId": "Client ID: Nhập Client ID ứng dụng Microsoft của bạn.",
      "onedriveClientSecret": "Client Secret: Nhập Client Secret ứng dụng Microsoft của bạn.",
      "onedriveRefreshToken": "Refresh Token: Nhập Refresh Token OneDrive của bạn (lấy riêng) để truy cập lâu dài.",
      "startOnLogin": "Tự động khởi động SVNTool: Bật tùy chọn này để tự động mở SVNTool khi máy tính khởi động.",
      "showNotifications": "Hiển thị thông báo cửa sổ: Bật tùy chọn này để nhận thông báo trực quan về hoạt động SVN và cập nhật ứng dụng trong cửa sổ."
    }
  },
  "svn": {
    "status": {
      "added": "Thêm",
      "modified": "Sửa",
      "deleted": "Xóa",
      "replaced": "Thay thế",
      "conflicted": "Xung đột",
      "external": "Bên ngoài",
      "ignored": "Bỏ qua",
      "unversioned": "Chưa quản lý",
      "missing": "Thiếu",
      "typeChanged": "Thay đổi kiểu"
    }
  },
  "settings": {
    "fontSize": {
      "title": "Cỡ chữ",
      "small": "Nhỏ",
      "medium": "Trung bình",
      "large": "Lớn"
    },
    "theme": "Chủ đề",
    "darkMode": "Chế độ tối",
    "language": "Ngôn ngữ",
    "buttonVariant": "Biến thể nút",
    "fontFamily": "Phông chữ",
    "description": "Cài đặt được lưu trong bộ nhớ cục bộ. Bạn có thể thay đổi cỡ chữ, chủ đề và ngôn ngữ của ứng dụng.",
    "tab": {
      "appearance": "Giao diện",
      "configuration": "Cấu hình",
      "mailserver": "Máy chủ gửi mail",
      "onedrive": "OneDrive"
    },
    "configuration": {
      "description": "Cấu hình cài đặt dự án của bạn.",
      "openaiApiKey": "Khóa API OpenAI",
      "openaiApiKeyPlaceholder": "Nhập khóa API OpenAI của bạn",
      "svnFolder": "Thư mục SVN",
      "svnFolderPlaceholder": "Chọn thư mục SVN",
      "chooseFolder": "Chọn thư mục",
      "sourceFolder": "Thư mục nguồn",
      "sourceFolderPlaceholder": "Chọn thư mục nguồn",
      "emailPL": "Email PL",
      "emailPlaceholder": "Nhập địa chỉ email",
      "webhookMS": "Webhook MS",
      "selectWebhook": "Chọn Webhook",
      "addNewWebhook": "Thêm Webhook mới",
      "startOnLogin": "Tự động mở app SVNTool",
      "showNotifications": "Hiển thị thông báo window"
    },
    "mailserver": {
      "description": "Cấu hình cài đặt máy chủ mail của bạn.",
      "smtpServer": "Máy chủ SMTP",
      "smtpServerPlaceholder": "Nhập máy chủ SMTP của bạn",
      "port": "Cổng",
      "portPlaceholder": "Nhập cổng SMTP",
      "email": "Email",
      "emailPlaceholder": "Nhập địa chỉ email của bạn",
      "password": "Mật khẩu",
      "passwordPlaceholder": "Nhập mật khẩu của bạn"
    },
    "onedrive": {
      "description": "Cấu hình Microsoft OneDrive để tải lên hình ảnh.",
      "clientId": "Client ID",
      "clientIdPlaceholder": "Nhập Client ID của ứng dụng Microsoft của bạn",
      "clientSecret": "Client Secret",
      "clientSecretPlaceholder": "Nhập Client Secret của ứng dụng Microsoft của bạn",
      "refreshToken": "Refresh Token (Tùy chọn)",
      "refreshTokenPlaceholder": "Nhập Refresh Token của bạn (nếu có)"
    }
  },
  "dialog": {
    "aboutDialog": {
      "title": "SVN Tool",
      "description": "Ứng dụng này được phát triển nhằm hỗ trợ sinh commit message từ SVN diff và kiểm tra tiêu chuẩn mã nguồn.",
      "developer": "Người phát triển",
      "version": "Phiên bản",
      "email": "Email",
      "thankYou": "Cảm ơn bạn đã sử dụng công cụ này!",
      "sourceCode": "Mã nguồn"
    },
    "codingRules": {
      "title": "Phân tích quy tắc mã nguồn",
      "refresh": "Làm mới",
      "noResults": "Chưa có kết quả phân tích."
    },
    "cleanSvn": {
      "title": "Tùy chọn dọn dẹp SVN",
      "description": "Chọn các tùy chọn dọn dẹp cho bản sao làm việc của bạn:",
      "options": {
        "externals": {
          "label": "Dọn dẹp các thành phần bên ngoài",
          "description": "Dọn dẹp cả các thành phần bên ngoài"
        },
        "unversioned": {
          "label": "Xoá tệp và thư mục chưa được quản lý",
          "description": "Xoá tất cả tệp và thư mục chưa được quản lý khỏi bản sao làm việc"
        },
        "ignored": {
          "label": "Xoá tệp và thư mục bị bỏ qua",
          "description": "Xoá tất cả tệp và thư mục bị bỏ qua khỏi bản sao làm việc"
        },
        "unused": {
          "label": "Xoá các bản sao pristine không sử dụng",
          "description": "Xoá tất cả các bản sao pristine không được tham chiếu trong bản sao làm việc"
        },
        "metadata": {
          "label": "Làm mới trạng thái bản sao làm việc",
          "description": "Làm mới trạng thái của bản sao làm việc"
        },
        "locks": {
          "label": "Phá khoá",
          "description": "Phá và chiếm các khoá trong bản sao làm việc"
        },
        "fixTimestamps": {
          "label": "Sửa dấu thời gian",
          "description": "Sửa dấu thời gian của các tệp trong bản sao làm việc"
        }
      },
      "clean": "Dọn dẹp",
      "cleanSuccess": "Dọn dẹp SVN thành công",
      "cleanError": "Lỗi trong quá trình dọn dẹp"
    },
    "statisticSvn": {
      "title": "Thống kê",
      "description": "Theo dõi các số liệu và biểu đồ thống kê hoạt động commit SVN theo thời gian, tác giả và tỷ lệ đóng góp, hỗ trợ quản lý và đánh giá tiến độ dự án dễ dàng hơn.",
      "tabs": {
        "commitByDate": "Commit theo ngày",
        "commitByAuthor": "Commit theo tác giả",
        "authorship": "Tỷ lệ tác giả",
        "summary": "Bảng tổng hợp"
      },
      "commitByDate": {
        "cardTitle": "Commits theo thời gian",
        "cardDescription": "Biểu đồ số lượng commit theo ngày",
        "selectChartType": "Chọn một loại biểu đồ",
        "chartTypes": {
          "barMultiple": "Biểu đồ cột - Nhiều cột",
          "barHorizontal": "Biểu đồ cột - Ngang",
          "barStacked": "Biểu đồ cột - Chồng",
          "lineMultiple": "Biểu đồ đường - Nhiều đường",
          "areaMultiple": "Biểu đồ vùng - Nhiều vùng"
        }
      },
      "commitByAuthor": {
        "cardTitle": "Commits theo tác giả",
        "cardDescription": "Biểu đồ số lượng commit theo tác giả",
        "chartTypes": {
          "barVertical": "Biểu đồ cột - Dọc",
          "barHorizontal": "Biểu đồ cột - Ngang"
        }
      },
      "authorship": {
        "title": "Tỷ lệ đóng góp theo tác giả",
        "cardTitle": "Tỷ lệ đóng góp theo tác giả",
        "cardDescription": "Tỷ lệ đóng góp của tác giả"
      },
      "summary": {
        "title": "Bảng tổng hợp",
        "author": "Người cập nhật",
        "commitCount": "Số lượng commit",
        "percentage": "Tỷ lệ",
        "total": "Tổng cộng"
      },
      "cardFooter": "Dữ liệu commit trong khoảng thời gian được chọn",
      "errorLoading": "Lỗi khi tải dữ liệu thống kê"
    },
    "spotbugs": {
      "title": "Phân tích SpotBugs",
      "filesAnalyzed": "Các tập tin đã phân tích",
      "totalIssues": "Tổng số vấn đề",
      "high": "Cao",
      "medium": "Trung bình",
      "low": "Thấp",
      "allIssues": "Tất cả vấn đề",
      "issues": "Vấn đề",
      "bugSummary": "Tổng quan lỗi",
      "bugDetails": "Chi tiết lỗi",
      "location": "Vị trí",
      "methodLocation": "Vị trí phương thức",
      "lines": "Dòng:",
      "localVariables": "Biến cục bộ",
      "properties": "Thuộc tính",
      "name": "Tên:",
      "value": "Giá trị",
      "notAvailable": "Không có",
      "static": "TĨNH",
      "primary": "CHÍNH",
      "fileList": "Danh sách file",
      "chart": "Biểu đồ",
      "bugCount": "Số lượng",
      "priorityChart": "Số lượng lỗi theo mức độ ưu tiên",
      "priorityChartDescription": "Hiển thị sự phân bố của các lỗi theo mức độ.",
      "fileStatsChart": "Số lượng lỗi theo file",
      "fileStatsChartDescription": "Hiển thị số lượng lỗi tìm thấy trong mỗi file của dự án.",
      "packageStatsChart": "Số lượng lỗi theo package",
      "packageStatsChartDescription": "Hiển thị sự phân bố của các lỗi trong các package khác nhau của dự án.",
      "aiAssistant": "Trợ lý AI",
      "ai": {
        "title": "Trợ lý AI",
        "description": "Giải thích lỗi trong tệp: {{file}}, dòng: {{line}}, loại: {{type}}.",
        "explainButton": "Giải thích lỗi này",
        "customQueryLabel": "Câu hỏi tùy chỉnh về lỗi này",
        "customQueryPlaceholder": "Ví dụ: Cách tốt nhất để khắc phục lỗi này?",
        "sendQueryButton": "Gửi câu hỏi",
        "responseTitle": "Phản hồi từ AI"
      }
    },
    "diffViewer": {
      "title": "Diff Viewer",
      "language": {
        "select": "Chọn ngôn ngữ...",
        "notFound": "Không tìm thấy ngôn ngữ."
      }
    },
    "showLogs": {
      "title": "Nhật ký SVN",
      "titleWithPath": "Nhật ký SVN: {{0}}",
      "commitMessage": "Tin nhắn commit",
      "changedFiles": "Tệp đã thay đổi",
      "revision": "Phiên bản",
      "date": "Ngày",
      "author": "Người cập nhật",
      "action": "Hành động",
      "message": "Thông điệp",
      "path": "Đường dẫn",
      "placeholderSearch": "Tìm kiếm phiên bản, tác giả, thông điệp...",
      "totalEntries": "{{0}} mục tổng cộng",
      "page": "Trang {{0}} của {{1}}"
    },
    "supportFeedback": {
      "title": "Hỗ trợ & Phản hồi",
      "description": "Gửi yêu cầu hỗ trợ hoặc cung cấp phản hồi.",
      "typeLabel": "Loại",
      "typePlaceholder": "Chọn loại",
      "typeSupport": "Yêu cầu Hỗ trợ",
      "typeFeedback": "Phản hồi",
      "emailLabel": "Email",
      "emailPlaceholder": "Nhập địa chỉ email của bạn",
      "messageLabel": "Nội dung",
      "messagePlaceholder": "Nhập nội dung tin nhắn",
      "validationWarning": "Vui lòng nhập email.",
      "sendSuccess": "Tin nhắn của bạn đã được gửi thành công!",
      "sendError": "Gửi tin nhắn thất bại. Vui lòng thử lại sau hoặc kiểm tra cấu hình webhook.",
      "basicInfoTitle": "Thông tin cơ bản",
      "messageTitle": "Nội dung tin nhắn",
      "imagesTitle": "Đính kèm hình ảnh",
      "dragImages": "Kéo và thả hình ảnh vào đây, hoặc nhấp để chọn tệp",
      "dropHere": "Thả hình ảnh vào đây...",
      "imageLimit": "Tối đa 5 hình ảnh, mỗi hình 5MB",
      "tooManyImages": "Bạn chỉ có thể tải lên tối đa 5 hình ảnh",
      "onlyImages": "Chỉ cho phép tệp hình ảnh"
    },
    "updateSvn": {
      "title": "Thông tin đã thay đổi gần đây",
      "author": "Người cập nhật: ",
      "revision": "Phiên bản: ",
      "curRevision": "Hiện tại: ",
      "date": "Thời gian: ",
      "changedFiles": "Tệp đã thay đổi",
      "action": "Hành động",
      "path": "Đường dẫn",
      "commitMessage": "Thông điệp commit",
      "description": "Một phiên bản SVN mới đã được phát hiện. Vui lòng cập nhật thư mục làm việc từ phiên bản {{1}} lên phiên bản mới nhất {{0}} để đảm bảo bạn có được tất cả thay đổi mới nhất."
    },
    "updateApp": {
      "title": "Có bản cập nhật mới",
      "appVersion": "Phiên bản SVNTool mới đã có sẵn: ",
      "message": "Ứng dụng sẽ khởi động lại sau khi cập nhật",
      "description": "Có bản cập nhật mới cho ứng dụng này. Vui lòng cập nhật ngay để nhận được những tính năng và sửa lỗi mới nhất."
    },
    "newWebhook": {
      "title": "Thêm Webhook Mới",
      "description": "Nhập tên và URL cho webhook bạn muốn thêm.",
      "msgRequiredName": "Tên webhook là bắt buộc.",
      "msgRequiredUrl": "URL của webhook là bắt buộc.",
      "placeholderName": "Nhập tên webhook",
      "placeholderUrl": "Nhập URL của webhook"
    },
    "commitMessageHistroy": {
      "title": "Lịch sử tin nhắn commit",
      "noResults": "Chưa có kết quả nào.",
      "date": "Thời gian",
      "commitMessage": "Thông điệp Commit"
    }
  },
  "welcome": {
    "title": "Chào mừng đến với SVN Tool!",
    "description": "Có vẻ đây là lần đầu bạn sử dụng ứng dụng. Bạn có muốn tham gia một chuyến tham quan nhanh để tìm hiểu về các tính năng chính không?"
  },
  "spotbugs": {
    "categoryDescriptions": {
      "badPractice": "Vi phạm các quy tắc lập trình khuyến nghị và thiết yếu. Ví dụ bao gồm vấn đề với hash code và equals, cloneable idiom, ngoại lệ bị bỏ qua, vấn đề với Serializable, và việc sử dụng sai finalize. Chúng tôi nỗ lực để phân tích này chính xác, mặc dù một số nhóm có thể không quan tâm đến các thực hành kém này.",
      "correctness": "Lỗi có khả năng cao - một lỗi lập trình rõ ràng dẫn đến mã nguồn có thể không phải là điều lập trình viên mong muốn. Chúng tôi cố gắng giữ tỷ lệ cảnh báo sai ở mức thấp.",
      "experimental": "Mẫu lỗi thử nghiệm và chưa được kiểm chứng đầy đủ",
      "i18N": "Lỗi liên quan đến quốc tế hóa và vùng miền",
      "maliciousCode": "Mã dễ bị tấn công từ mã không đáng tin cậy",
      "mtCorrectness": "Lỗi liên quan đến luồng, khóa, và biến volatile",
      "noise": "Nhiễu ngẫu nhiên giả: nhằm phục vụ cho việc kiểm soát trong các thí nghiệm khai phá dữ liệu, không nhằm tìm lỗi thực sự trong phần mềm",
      "performance": "Mã không nhất thiết là sai nhưng có thể không hiệu quả",
      "security": "Việc sử dụng dữ liệu không đáng tin cậy theo cách có thể tạo ra lỗ hổng bảo mật có thể khai thác từ xa.",
      "style": "Mã gây nhầm lẫn, bất thường, hoặc được viết theo cách dễ gây lỗi. Ví dụ bao gồm biến cục bộ không dùng đến, thiếu break trong switch, ép kiểu không xác nhận, và kiểm tra null dư thừa với giá trị đã biết là null. Chấp nhận tỷ lệ cảnh báo sai cao hơn. Trong các phiên bản trước của SpotBugs, danh mục này được gọi là Style."
    },
    "bugDescriptions": {
      "jua_dont_assert_instanceof_in_tests": "JUA: Việc sử dụng instanceof trong kiểm thử là không được khuyến khích. Việc kiểm tra kiểu trong kiểm thử là không được khuyến khích vì thông báo ngoại lệ ClassCast có thể cho biết nguyên nhân một cách rõ ràng hơn khi một thể hiện thuộc sai lớp được sử dụng so với việc dùng instanceof. Khi gỡ lỗi các bài kiểm thử thất bại do ép kiểu sai, việc quan sát đầu ra của ClassCastException có thể cung cấp thông tin về kiểu thực tế gặp phải. Việc kiểm tra kiểu trước khi ép kiểu sẽ chỉ dẫn đến thông báo không rõ ràng như 'false is not true'. Nếu sử dụng JUnit cùng với hamcrest, có thể dùng lớp IsInstanceOf từ hamcrest thay thế.",
      "aa_assertion_of_arguments": "AA: Assertion được sử dụng để xác thực tham số của phương thức public. Không được sử dụng assertion để xác thực các tham số của phương thức public vì các xác thực này sẽ không được thực thi nếu assertion bị vô hiệu hóa. Xem quy tắc SEI CERT MET01-J: Không bao giờ sử dụng assertion để xác thực tham số phương thức và CWE-617: Reachable Assertion để biết thêm chi tiết.",
      "ct_constructor_throw": "CT: Hãy cẩn trọng khi để constructor ném ngoại lệ. Các lớp ném ngoại lệ trong constructor dễ bị tấn công thông qua finalizer. Một cuộc tấn công finalizer có thể được ngăn chặn bằng cách khai báo lớp là final, sử dụng finalizer rỗng được khai báo là final, hoặc sử dụng constructor private một cách khéo léo. Xem SEI CERT Rule OBJ-11 để biết thêm thông tin.",
      "cnt_rough_constant_value": "CNT: Phát hiện giá trị xấp xỉ của một hằng số đã biết. Khuyến nghị nên sử dụng hằng số thư viện được định nghĩa sẵn để mã rõ ràng hơn và có độ chính xác tốt hơn. Xem CWE-1106: Insufficient Use of Symbolic Constants.",
      "np_boolean_return_null": "NP: Phương thức trả về Boolean trả về giá trị null rõ ràng. Một phương thức trả về Boolean.TRUE, Boolean.FALSE hoặc null là một tai nạn đang chờ xảy ra. Phương thức này có thể được gọi như thể nó trả về kiểu boolean, và trình biên dịch sẽ tự động thực hiện unboxing giá trị Boolean. Nếu giá trị null được trả về, điều này sẽ dẫn đến lỗi NullPointerException.",
      "sw_swing_methods_invoked_in_swing_thread": "SW: Một số phương thức swing cần được gọi trong thread Swing. (Theo JDC Tech Tip): Các phương thức show(), setVisible(), và pack() của Swing sẽ tạo ra đối tượng tương ứng cho khung hiển thị. Khi đối tượng tương ứng được tạo, hệ thống sẽ tạo thread xử lý sự kiện. Điều này gây vấn đề vì thread xử lý sự kiện có thể đang thông báo tới các listener trong khi pack và validate vẫn đang xử lý. Trạng thái này có thể dẫn đến hai thread cùng xử lý GUI dựa trên Swing — đây là một lỗi nghiêm trọng có thể gây deadlock hoặc các vấn đề liên quan đến luồng khác. Lệnh gọi pack khiến các thành phần được khởi tạo. Khi chúng đang được khởi tạo (nghĩa là chưa chắc đã hiển thị), chúng có thể kích hoạt thông báo tới listener trong thread xử lý sự kiện.",
      "fi_finalizer_only_nulls_fields": "FI: Finalizer chỉ làm rỗng các trường. Finalizer này không làm gì ngoài việc gán null cho các trường. Điều này hoàn toàn vô nghĩa và yêu cầu đối tượng phải được gom rác, gọi finalize, rồi lại được gom rác lần nữa. Bạn nên xóa phương thức finalize đi.",
      "fi_finalizer_nulls_fields": "FI: Finalizer làm rỗng các trường. Finalizer này làm rỗng các trường. Đây thường là lỗi, vì nó không giúp ích cho việc gom rác, và đối tượng sẽ bị gom rác dù có làm vậy hay không.",
      "ui_inheritance_unsafe_getresource": "UI: Việc sử dụng GetResource có thể không an toàn nếu lớp bị kế thừa. Việc gọi this.getClass().getResource(...) có thể cho kết quả không như mong đợi nếu lớp này bị kế thừa bởi một lớp thuộc package khác.",
      "am_creates_empty_zip_file_entry": "AM: Tạo một mục trống trong tệp zip. Mã gọi putNextEntry(), ngay sau đó là gọi closeEntry(). Điều này dẫn đến một mục rỗng trong tệp ZipFile. Nội dung của mục nên được ghi vào ZipFile giữa hai lệnh gọi putNextEntry() và closeEntry().",
      "am_creates_empty_jar_file_entry": "AM: Tạo một mục trống trong tệp jar. Mã gọi putNextEntry(), ngay sau đó là gọi closeEntry(). Điều này dẫn đến một mục rỗng trong tệp JarFile. Nội dung của mục nên được ghi vào JarFile giữa hai lệnh gọi putNextEntry() và closeEntry().",
      "imse_dont_catch_imse": "IMSE: Bắt IllegalMonitorStateException một cách đáng ngờ. IllegalMonitorStateException thường chỉ bị ném ra trong trường hợp có lỗi thiết kế trong mã của bạn (gọi wait hoặc notify trên một đối tượng mà bạn không giữ khóa).",
      "cn_implements_clone_but_not_cloneable": "CN: Lớp định nghĩa clone() nhưng không implements Cloneable. Lớp này định nghĩa một phương thức clone() nhưng không implements Cloneable. Trong một số trường hợp thì điều này chấp nhận được (ví dụ: bạn muốn kiểm soát cách các lớp con tự clone), nhưng hãy chắc chắn rằng đó là chủ đích của bạn.",
      "cn_idiom": "CN: Lớp implements Cloneable nhưng không định nghĩa hoặc sử dụng phương thức clone. Lớp implements Cloneable nhưng không định nghĩa hoặc sử dụng phương thức clone.",
      "cn_idiom_no_super_call": "CN: Phương thức clone không gọi super.clone(). Lớp không final này định nghĩa một phương thức clone() nhưng không gọi super.clone(). Nếu lớp này ('A') được kế thừa bởi một lớp con ('B'), và lớp B gọi super.clone(), thì rất có thể phương thức clone() của B sẽ trả về một đối tượng kiểu A, điều này vi phạm hợp đồng chuẩn của clone(). Nếu tất cả các phương thức clone() đều gọi super.clone(), thì đảm bảo rằng chúng sử dụng Object.clone(), vốn luôn trả về đối tượng có kiểu đúng. Xem CWE-580: clone() Method Without super.clone().",
      "de_might_drop": "DE: Phương thức có thể bỏ qua ngoại lệ. Phương thức này có thể bỏ qua một ngoại lệ. Thông thường, ngoại lệ nên được xử lý hoặc ghi nhận theo một cách nào đó, hoặc nên được ném ra khỏi phương thức. Xem CWE-754: Improper Check for Unusual or Exceptional Conditions.",
      "de_might_ignore": "DE: Phương thức có thể phớt lờ ngoại lệ. Phương thức này có thể phớt lờ một ngoại lệ. Thông thường, ngoại lệ nên được xử lý hoặc ghi nhận theo một cách nào đó, hoặc nên được ném ra khỏi phương thức. Xem CWE-754: Improper Check for Unusual or Exceptional Conditions.",
      "dm_exit": "Dm: Phương thức gọi System.exit(…). Việc gọi System.exit sẽ tắt toàn bộ Java Virtual Machine. Điều này chỉ nên được thực hiện khi thực sự phù hợp. Những lời gọi như vậy khiến mã của bạn khó hoặc không thể được gọi bởi mã khác. Hãy cân nhắc ném một RuntimeException thay thế. Xem CWE-382: J2EE Bad Practices: Use of System.exit().",
      "nm_future_keyword_used_as_identifier": "Nm: Sử dụng định danh là từ khóa trong các phiên bản Java mới hơn. Định danh này là một từ được dành riêng làm từ khóa trong các phiên bản Java mới hơn, và mã của bạn sẽ cần được thay đổi để biên dịch trong các phiên bản Java tương lai.",
      "nm_future_keyword_used_as_member_identifier": "Nm: Sử dụng định danh là từ khóa trong các phiên bản Java mới hơn. Định danh này được sử dụng như một từ khóa trong các phiên bản Java mới hơn. Mã này, cùng với bất kỳ mã nào tham chiếu đến API này, sẽ cần được thay đổi để biên dịch trong các phiên bản Java tương lai.",
      "jcip_field_isnt_final_in_immutable_class": "JCIP: Các trường của lớp bất biến nên được khai báo final. Lớp được chú thích với net.jcip.annotations.Immutable hoặc javax.annotation.concurrent.Immutable, và các quy tắc cho các chú thích đó yêu cầu rằng tất cả các trường phải được khai báo là final. Xem CWE-471: Modification of Assumed-Immutable Data (MAID).",
      "dm_run_finalizers_on_exit": "Dm: Phương thức gọi phương thức nguy hiểm runFinalizersOnExit. Tuyệt đối không được gọi System.runFinalizersOnExit hoặc Runtime.runFinalizersOnExit vì bất kỳ lý do gì: đây là một trong những phương thức nguy hiểm nhất trong thư viện Java. -- Joshua Bloch",
      "np_equals_should_handle_null_argument": "NP: Phương thức equals() không kiểm tra đối số null. Việc triển khai equals(Object) này vi phạm hợp đồng được định nghĩa bởi java.lang.Object.equals() vì nó không kiểm tra xem đối số được truyền vào có phải là null hay không. Tất cả các phương thức equals() nên trả về false nếu nhận vào giá trị null.",
      "fi_empty": "FI: Finalizer rỗng nên bị xóa. Các phương thức finalize() rỗng là vô dụng, vì vậy nên bị xóa. Xem CWE-568: finalize() Method Without super.finalize().",
      "fi_nullify_super": "FI: Finalizer vô hiệu hóa finalizer của lớp cha. Phương thức finalize() rỗng này rõ ràng đã vô hiệu hóa tác dụng của bất kỳ finalizer nào được định nghĩa trong lớp cha. Bất kỳ hành động finalizer nào được định nghĩa cho lớp cha sẽ không được thực hiện. Trừ khi đây là điều bạn cố ý, hãy xóa phương thức này. Xem CWE-568: finalize() Method Without super.finalize().",
      "fi_useless": "FI: Finalizer chỉ gọi finalizer của lớp cha. Điều duy nhất phương thức finalize() này làm là gọi phương thức finalize() của lớp cha, điều này khiến nó trở nên dư thừa. Hãy xóa nó.",
      "fi_missing_super_call": "FI: Finalizer không gọi finalizer của lớp cha. Phương thức finalize() này không gọi phương thức finalize() của lớp cha. Do đó, bất kỳ hành động finalizer nào được định nghĩa trong lớp cha sẽ không được thực hiện. Hãy thêm lời gọi đến super.finalize(). Xem CWE-568: finalize() Method Without super.finalize().",
      "fi_explicit_invocation": "FI: Gọi rõ ràng đến phương thức finalize. Phương thức này có chứa lời gọi rõ ràng đến phương thức finalize() trên một đối tượng. Vì các phương thức finalizer chỉ nên được thực thi một lần và chỉ do máy ảo Java thực hiện, việc gọi thủ công là một ý tưởng tồi. Nếu một tập hợp các đối tượng có thể được finalizable, thì VM sẽ gọi phương thức finalize() trên tất cả các đối tượng đó, có thể đồng thời trong các luồng khác nhau. Do đó, đặc biệt nguy hiểm nếu trong phương thức finalize của lớp X lại gọi finalize() trên các đối tượng được tham chiếu bởi X, vì chúng có thể đã đang được finalize trong một luồng khác. Xem CWE-586: Explicit Call to Finalize().",
      "eq_check_for_operand_not_compatible_with_this": "Eq: equals kiểm tra toán hạng không tương thích. Phương thức equals này đang kiểm tra xem đối số có phải là kiểu không tương thích (tức là một lớp không phải là siêu lớp hoặc lớp con của lớp định nghĩa phương thức equals). Ví dụ, lớp Foo có thể có một phương thức equals như sau: public boolean equals(Object o) { if (o instanceof Foo) return name.equals(((Foo)o).name); else if (o instanceof String) return name.equals(o); else return false; } Đây được coi là một thực hành tồi, vì nó khiến việc triển khai phương thức equals đảm bảo tính đối xứng và bắc cầu trở nên rất khó. Nếu không có những tính chất đó, hành vi rất bất ngờ có thể xảy ra.",
      "eq_getclass_and_class_constant": "Eq: equals bị lỗi với các lớp con. Lớp này có một phương thức equals sẽ bị lỗi nếu nó được kế thừa bởi các lớp con. Nó so sánh literal lớp với lớp của đối tượng đối số (ví dụ, trong lớp Foo, có thể kiểm tra bằng cách if (Foo.class == o.getClass())). Tốt hơn là nên kiểm tra bằng this.getClass() == o.getClass(). Xem CWE-486: Comparison of Classes by Name.",
      "eq_self_no_object": "Eq: Định nghĩa phương thức equals() dạng covariant. Lớp này định nghĩa một phiên bản equals() dạng covariant. Để ghi đè đúng phương thức equals() trong java.lang.Object, tham số của equals() bắt buộc phải có kiểu java.lang.Object.",
      "co_self_no_object": "Co: Định nghĩa phương thức compareTo() dạng covariant. Lớp này định nghĩa một phiên bản covariant của phương thức compareTo(). Để ghi đè đúng phương thức compareTo() trong interface Comparable, tham số của compareTo() bắt buộc phải có kiểu java.lang.Object.",
      "co_compareto_results_min_value": "Co: compareTo()/compare() trả về Integer.MIN_VALUE. Trong một số trường hợp, phương thức compareTo hoặc compare này trả về hằng số Integer.MIN_VALUE, đây là một thực hành cực kỳ tồi. Điều duy nhất quan trọng trong giá trị trả về của compareTo là dấu của kết quả. Tuy nhiên, đôi khi người ta sẽ phủ định giá trị trả về của compareTo với kỳ vọng rằng điều đó sẽ phủ định dấu. Và điều đó đúng, ngoại trừ khi giá trị trả về là Integer.MIN_VALUE. Vì vậy, chỉ nên trả về -1 thay vì Integer.MIN_VALUE.",
      "co_compareto_incorrect_floating": "Co: compareTo()/compare() xử lý sai giá trị float hoặc double. Phương thức này so sánh các giá trị double hoặc float bằng cách sử dụng mẫu như sau: val1 > val2 ? 1 : val1 < val2 ? -1 : 0. Mẫu này hoạt động không đúng đối với các giá trị -0.0 và NaN, điều này có thể dẫn đến kết quả sắp xếp sai hoặc làm hỏng các collection (nếu các giá trị so sánh được sử dụng làm khóa). Hãy cân nhắc sử dụng các phương thức tĩnh Double.compare hoặc Float.compare, vì chúng xử lý đúng tất cả các trường hợp đặc biệt.",
      "rv_negating_result_of_compareto": "RV: Phủ định kết quả của compareTo()/compare(). Đoạn mã này phủ định giá trị trả về của phương thức compareTo hoặc compare. Đây là một thực hành lập trình đáng nghi hoặc tệ, vì nếu giá trị trả về là Integer.MIN_VALUE, thì việc phủ định giá trị đó sẽ không phủ định dấu của kết quả. Bạn có thể đạt được kết quả mong muốn bằng cách đảo ngược thứ tự của các toán hạng thay vì phủ định kết quả.",
      "es_comparing_strings_with_eq": "ES: So sánh đối tượng String bằng cách dùng == hoặc !=. Đoạn mã này so sánh các đối tượng java.lang.String theo tham chiếu bằng cách sử dụng toán tử == hoặc !=. Trừ khi cả hai chuỗi đều là hằng trong file mã nguồn hoặc đã được intern bằng phương thức String.intern(), thì cùng một giá trị chuỗi có thể được biểu diễn bằng hai đối tượng String khác nhau. Hãy cân nhắc sử dụng phương thức equals(Object) thay thế. Xem CWE-595: So sánh tham chiếu đối tượng thay vì nội dung đối tượng.",
      "es_comparing_parameter_string_with_eq": "ES: So sánh tham số String bằng == hoặc !=. Đoạn mã này so sánh một tham số java.lang.String theo tham chiếu bằng cách sử dụng toán tử == hoặc !=. Việc yêu cầu caller chỉ truyền vào các hằng String hoặc chuỗi đã intern là điều không ổn định và hiếm khi mang lại lợi ích hiệu suất rõ ràng. Hãy cân nhắc sử dụng phương thức equals(Object) thay thế. Xem CWE-595: So sánh tham chiếu đối tượng thay vì nội dung đối tượng.",
      "eq_compareto_use_object_equals": "Eq: Lớp định nghĩa compareTo(…) nhưng sử dụng Object.equals(). Lớp này định nghĩa phương thức compareTo(...) nhưng lại kế thừa phương thức equals() từ java.lang.Object. Thông thường, giá trị trả về của compareTo nên là 0 nếu và chỉ nếu equals trả về true. Nếu vi phạm điều này, sẽ xảy ra những lỗi lạ và không thể dự đoán được trong các lớp như PriorityQueue. Trong Java 5, phương thức PriorityQueue.remove sử dụng compareTo, trong khi ở Java 6 thì sử dụng equals. Theo tài liệu JavaDoc của phương thức compareTo trong interface Comparable: Rất nên, dù không bắt buộc, rằng (x.compareTo(y)==0) == (x.equals(y)). Nói chung, bất kỳ lớp nào cài đặt interface Comparable mà vi phạm điều kiện này nên ghi rõ điều đó. Câu văn khuyến nghị là: 'Lưu ý: lớp này có thứ tự tự nhiên không tương thích với equals.'",
      "he_hashcode_use_object_equals": "HE: Lớp định nghĩa hashCode() nhưng sử dụng Object.equals(). Lớp này định nghĩa phương thức hashCode() nhưng kế thừa phương thức equals() từ java.lang.Object (so sánh dựa trên tham chiếu đối tượng). Mặc dù điều này có thể vẫn đảm bảo rằng các đối tượng bằng nhau sẽ có cùng mã băm, nhưng có lẽ đó không phải là ý định ban đầu khi ghi đè hashCode() (việc ghi đè hashCode() thường ngụ ý rằng định danh của đối tượng được xác định bằng tiêu chí phức tạp hơn so với so sánh tham chiếu). Nếu bạn nghĩ rằng các thể hiện của lớp này sẽ không bao giờ được đưa vào HashMap/HashTable, thì nên dùng cài đặt hashCode sau: public int hashCode() { assert false : 'hashCode not designed'; return 42; // bất kỳ hằng số tùy ý nào cũng được } Xem CWE-581: Vi phạm mô hình đối tượng: Chỉ định nghĩa equals hoặc hashCode.",
      "he_hashcode_no_equals": "HE: Lớp định nghĩa hashCode() nhưng không định nghĩa equals(). Lớp này định nghĩa phương thức hashCode() nhưng không có equals(). Do đó, lớp này có thể vi phạm nguyên lý rằng các đối tượng bằng nhau phải có cùng mã băm. Xem CWE-581: Vi phạm mô hình đối tượng: Chỉ định nghĩa equals hoặc hashCode.",
      "he_equals_use_hashcode": "HE: Lớp định nghĩa equals() nhưng sử dụng Object.hashCode(). Lớp này ghi đè phương thức equals(Object), nhưng không ghi đè hashCode(), và kế thừa cài đặt hashCode() từ java.lang.Object (trả về mã định danh của đối tượng, một giá trị tùy ý được VM gán). Do đó, lớp này rất có khả năng vi phạm nguyên lý rằng các đối tượng bằng nhau phải có cùng mã băm. Nếu bạn nghĩ rằng thể hiện của lớp này sẽ không bao giờ được đưa vào HashMap/HashTable, thì nên dùng cài đặt hashCode sau: public int hashCode() { assert false : 'hashCode not designed'; return 42; // bất kỳ hằng số tùy ý nào cũng được } Xem CWE-581: Vi phạm mô hình đối tượng: Chỉ định nghĩa equals hoặc hashCode.",
      "he_inherits_equals_use_hashcode": "HE: Lớp kế thừa equals() và sử dụng Object.hashCode(). Lớp này kế thừa equals(Object) từ lớp cha trừu tượng, và hashCode() từ java.lang.Object (trả về mã định danh của đối tượng, một giá trị tùy ý được VM gán). Do đó, lớp này rất có khả năng vi phạm nguyên lý rằng các đối tượng bằng nhau phải có cùng mã băm. Nếu bạn không muốn định nghĩa phương thức hashCode, và/hoặc không nghĩ đối tượng này sẽ được đưa vào HashMap/Hashtable, thì hãy định nghĩa hashCode() để ném ra UnsupportedOperationException. Xem CWE-581: Vi phạm mô hình đối tượng: Chỉ định nghĩa equals hoặc hashCode.",
      "he_equals_no_hashcode": "HE: Lớp định nghĩa equals() nhưng không định nghĩa hashCode(). Lớp này ghi đè phương thức equals(Object), nhưng không ghi đè hashCode(). Do đó, lớp này có thể vi phạm nguyên lý rằng các đối tượng bằng nhau phải có cùng mã băm. Xem CWE-581: Vi phạm mô hình đối tượng: Chỉ định nghĩa equals hoặc hashCode.",
      "eq_abstract_self": "Eq: Lớp trừu tượng định nghĩa phương thức equals() dạng covariant. Lớp này định nghĩa một phiên bản covariant của equals(). Để ghi đè đúng phương thức equals() trong java.lang.Object, tham số của equals() bắt buộc phải có kiểu java.lang.Object.",
      "co_abstract_self": "Co: Lớp trừu tượng định nghĩa phương thức compareTo() dạng covariant. Lớp này định nghĩa một phiên bản covariant của compareTo(). Để ghi đè đúng phương thức compareTo() trong interface Comparable, tham số của compareTo() bắt buộc phải có kiểu java.lang.Object.",
      "ic_superclass_uses_subclass_during_initialization": "IC: Lớp cha sử dụng lớp con trong quá trình khởi tạo. Trong quá trình khởi tạo một lớp, lớp này sử dụng một cách chủ động một lớp con. Tuy nhiên, lớp con chưa được khởi tạo vào thời điểm sử dụng. Ví dụ, trong đoạn mã sau, foo sẽ là null. public class CircularClassInitialization { static class InnerClassSingleton extends CircularClassInitialization { static InnerClassSingleton singleton = new InnerClassSingleton(); } static CircularClassInitialization foo = InnerClassSingleton.singleton; } Xem CWE-457: Sử dụng biến chưa được khởi tạo.",
      "si_instance_before_finals_assigned": "SI: Bộ khởi tạo tĩnh tạo thể hiện trước khi tất cả các trường static final được gán. Bộ khởi tạo tĩnh của lớp tạo một thể hiện của lớp trước khi tất cả các trường static final được gán.",
      "it_no_such_element": "It: Phương thức next() của Iterator không thể ném ra NoSuchElementException. Lớp này triển khai interface java.util.Iterator. Tuy nhiên, phương thức next() của nó không thể ném ra java.util.NoSuchElementException. Phương thức next() cần được thay đổi để ném ra NoSuchElementException nếu được gọi khi không còn phần tử nào để trả về.",
      "me_mutable_enum_field": "ME: Trường enum là public và có thể thay đổi. Một trường mutable công khai được định nghĩa trong một enum công khai, do đó có thể bị thay đổi bởi mã độc hoặc vô tình từ một package khác. Mặc dù các trường mutable trong enum có thể được sử dụng cho việc khởi tạo lười, nhưng việc để chúng công khai ra ngoài là một thói quen xấu. Hãy xem xét khai báo trường này là final và/hoặc package-private.",
      "me_enum_field_setter": "ME: Phương thức công khai trong enum thay đổi trường của nó mà không điều kiện. Phương thức công khai được khai báo trong enum công khai này thay đổi trường enum mà không có điều kiện, do đó trường này có thể bị thay đổi bởi mã độc hoặc vô tình từ một package khác. Mặc dù các trường mutable trong enum có thể được sử dụng cho việc khởi tạo lười, nhưng việc để chúng công khai ra ngoài là một thói quen xấu. Hãy xem xét loại bỏ phương thức này hoặc khai báo nó là package-private.",
      "nm_method_naming_convention": "Nm: Tên phương thức nên bắt đầu bằng chữ cái viết thường. Các phương thức nên là động từ, với chữ cái đầu tiên viết thường, và chữ cái đầu tiên của mỗi từ trong tên nội bộ viết hoa.",
      "nm_field_naming_convention": "Nm: Tên trường không phải final nên bắt đầu bằng chữ cái viết thường, trường final nên viết hoa và các từ được ngăn cách bằng dấu gạch dưới. Tên của các trường không phải final nên theo dạng viết hoa chữ cái đầu tiên của mỗi từ, bắt đầu bằng chữ cái viết thường. Tên của các trường final nên viết hoa tất cả và các từ ngăn cách bằng dấu gạch dưới ('_').",
      "nm_same_simple_name_as_interface": "Nm: Tên lớp không nên trùng với tên đơn giản của interface đã triển khai. Lớp/interface này có tên đơn giản trùng với tên của interface đã triển khai/mở rộng, ngoại trừ việc interface đó nằm trong một package khác (ví dụ, alpha.Foo extends beta.Foo). Điều này có thể gây nhầm lẫn cực kỳ, tạo ra nhiều tình huống bạn phải kiểm tra các câu lệnh import để giải quyết tham chiếu và tạo ra nhiều cơ hội để vô tình định nghĩa các phương thức không ghi đè được phương thức trong lớp cha của chúng.",
      "nm_same_simple_name_as_superclass": "Nm: Tên lớp không nên trùng với tên đơn giản của lớp cha. Lớp này có tên đơn giản trùng với tên của lớp cha, ngoại trừ việc lớp cha nằm trong một package khác (ví dụ, alpha.Foo extends beta.Foo). Điều này có thể gây nhầm lẫn cực kỳ, tạo ra nhiều tình huống bạn phải kiểm tra các câu lệnh import để giải quyết tham chiếu và tạo ra nhiều cơ hội để vô tình định nghĩa các phương thức không ghi đè được phương thức trong lớp cha của chúng.",
      "nm_class_naming_convention": "Nm: Tên lớp nên bắt đầu bằng chữ cái viết hoa. Tên lớp nên là danh từ, viết theo kiểu chữ cái đầu tiên của mỗi từ trong tên được viết hoa. Hãy cố gắng giữ cho tên lớp của bạn đơn giản và mô tả rõ ràng. Sử dụng từ đầy đủ tránh viết tắt và các từ viết tắt (trừ khi từ viết tắt đó được sử dụng rộng rãi hơn dạng đầy đủ, như URL hoặc HTML).",
      "nm_very_confusing_intentional": "Nm: Tên phương thức rất dễ gây nhầm lẫn (nhưng có thể là cố ý). Các phương thức tham chiếu có tên chỉ khác nhau bởi cách viết hoa. Điều này rất dễ gây nhầm lẫn vì nếu cách viết hoa giống nhau thì một trong các phương thức sẽ ghi đè phương thức kia. Từ sự tồn tại của các phương thức khác, có vẻ như việc tồn tại cả hai phương thức là cố ý, nhưng chắc chắn là gây nhầm lẫn. Bạn nên cố gắng loại bỏ một trong số chúng, trừ khi bạn buộc phải giữ cả hai vì các API cố định.",
      "nm_wrong_package_intentional": "Nm: Phương thức không ghi đè phương thức trong lớp cha vì tham số có package sai. Phương thức trong lớp con không ghi đè phương thức tương tự trong lớp cha vì kiểu tham số không khớp chính xác với kiểu tham số tương ứng trong lớp cha. Ví dụ, nếu bạn có: import alpha.Foo; public class A { public int f(Foo x) { return 17; } } ---- import beta.Foo; public class B extends A { public int f(Foo x) { return 42; } public int f(alpha.Foo x) { return 27; } } Phương thức f(Foo) trong lớp B không ghi đè phương thức f(Foo) trong lớp A, vì các kiểu tham số Foo từ các package khác nhau. Trong trường hợp này, lớp con có định nghĩa một phương thức với chữ ký giống hệt với phương thức trong lớp cha, nên có thể hiểu là cố ý. Tuy nhiên, những phương thức như vậy rất dễ gây nhầm lẫn. Bạn nên xem xét mạnh mẽ việc loại bỏ hoặc đánh dấu phương thức với chữ ký tương tự nhưng không giống hệt.",
      "nm_confusing": "Nm: Tên phương thức gây nhầm lẫn. Các phương thức tham chiếu có tên chỉ khác nhau bởi cách viết hoa.",
      "nm_class_not_exception": "Nm: Lớp không kế thừa từ Exception, mặc dù tên của nó có đuôi 'Exception'. Lớp này không kế thừa từ một exception khác, nhưng lại có tên kết thúc bằng 'Exception'. Điều này sẽ gây nhầm lẫn cho người dùng của lớp này.",
      "rr_not_checked": "RR: Phương thức bỏ qua kết quả của InputStream.read(). Phương thức này bỏ qua giá trị trả về của một trong các biến thể của java.io.InputStream.read() có thể trả về nhiều byte. Nếu giá trị trả về không được kiểm tra, người gọi sẽ không thể xử lý đúng trường hợp có ít byte được đọc hơn so với yêu cầu. Đây là một loại lỗi rất tinh vi, vì trong nhiều chương trình, việc đọc từ các input stream thường đọc đủ lượng dữ liệu yêu cầu, dẫn đến chương trình chỉ thất bại một cách thỉnh thoảng. Xem CWE-252: Giá trị trả về không được kiểm tra.",
      "sr_not_checked": "RR: Phương thức bỏ qua kết quả của InputStream.skip(). Phương thức này bỏ qua giá trị trả về của java.io.InputStream.skip() có thể bỏ qua nhiều byte. Nếu giá trị trả về không được kiểm tra, người gọi sẽ không thể xử lý đúng trường hợp có ít byte bị bỏ qua hơn so với yêu cầu. Đây là một loại lỗi rất tinh vi, vì trong nhiều chương trình, việc bỏ qua dữ liệu từ các input stream thường bỏ qua đủ lượng dữ liệu yêu cầu, dẫn đến chương trình chỉ thất bại một cách thỉnh thoảng. Tuy nhiên, với các dòng Buffered, phương thức skip() chỉ bỏ qua dữ liệu trong bộ đệm, và thường xuyên thất bại khi bỏ qua số byte yêu cầu. Xem CWE-252: Giá trị trả về không được kiểm tra.",
      "se_no_suitable_constructor": "Se: Lớp là Serializable nhưng lớp cha không định nghĩa constructor void. Lớp này triển khai interface Serializable và lớp cha của nó không có. Khi một đối tượng như vậy được deserialized, các trường của lớp cha cần được khởi tạo bằng cách gọi constructor void của lớp cha. Vì lớp cha không có constructor này, quá trình serialization và deserialization sẽ thất bại tại thời điểm chạy.",
      "se_no_suitable_constructor_for_externalization": "Se: Lớp là Externalizable nhưng không định nghĩa constructor void. Lớp này triển khai interface Externalizable, nhưng không định nghĩa constructor void công khai. Khi các đối tượng Externalizable được deserialized, chúng cần được khởi tạo bằng cách gọi constructor void công khai. Vì lớp này không có constructor này, quá trình serialization và deserialization sẽ thất bại tại thời điểm chạy.",
      "se_comparator_should_be_serializable": "Se: Comparator không triển khai Serializable. Lớp này triển khai interface Comparator. Bạn nên xem xét liệu nó có nên triển khai interface Serializable hay không. Nếu một comparator được sử dụng để xây dựng một collection có thứ tự như TreeMap, thì TreeMap sẽ chỉ có thể serializable nếu comparator cũng serializable. Vì hầu hết các comparators có ít hoặc không có trạng thái, làm cho chúng serializable thường là điều dễ dàng và là một phương pháp lập trình phòng thủ tốt. Xem CWE-1066: Thiếu yếu tố điều khiển Serialization.",
      "se_no_serialversionid": "SnVI: Lớp là Serializable, nhưng không định nghĩa serialVersionUID. Lớp này triển khai interface Serializable, nhưng không định nghĩa trường serialVersionUID. Một thay đổi đơn giản như việc thêm một tham chiếu đến một đối tượng .class sẽ thêm các trường synthetic vào lớp, điều này sẽ thay đổi serialVersionUID ngầm định (ví dụ, thêm một tham chiếu đến String.class sẽ tạo ra một trường tĩnh class$java$lang$String). Thêm vào đó, các trình biên dịch mã nguồn đến bytecode khác nhau có thể sử dụng các quy ước đặt tên khác nhau cho các biến synthetic được tạo ra cho các tham chiếu đến đối tượng lớp hoặc lớp con. Để đảm bảo tính tương thích của Serializable qua các phiên bản, hãy xem xét thêm serialVersionUID một cách rõ ràng.",
      "se_read_resolve_must_return_object": "Se: Phương thức readResolve phải được khai báo với kiểu trả về là Object. Để phương thức readResolve được công nhận bởi cơ chế serialization, nó phải được khai báo có kiểu trả về là Object.",
      "se_transient_field_not_restored": "Se: Trường transient không được thiết lập bởi deserialization. Lớp này chứa một trường được cập nhật ở nhiều nơi trong lớp, vì vậy nó có vẻ là một phần của trạng thái của lớp. Tuy nhiên, vì trường này được đánh dấu là transient và không được thiết lập trong readObject hoặc readResolve, nó sẽ chứa giá trị mặc định trong bất kỳ instance nào của lớp sau khi deserialized.",
      "se_prevent_ext_obj_overwrite": "Se: Ngăn chặn ghi đè đối tượng externalizable. Phương thức readExternal() phải được khai báo là công khai và không được bảo vệ khỏi các caller độc hại, vì vậy mã cho phép bất kỳ caller nào cũng có thể thiết lập lại giá trị của đối tượng bất kỳ lúc nào. Để ngăn chặn ghi đè đối tượng externalizable, bạn có thể sử dụng một cờ Boolean được thiết lập sau khi các trường instance đã được điền đầy đủ. Bạn cũng có thể bảo vệ khỏi các điều kiện race bằng cách đồng bộ hóa trên một đối tượng khóa riêng.",
      "se_nonfinal_serialversionid": "Se: serialVersionUID không phải là final. Lớp này định nghĩa trường serialVersionUID nhưng không phải là final. Trường này nên được khai báo là final nếu nó được dự định chỉ ra version UID cho mục đích serialization.",
      "se_nonstatic_serialversionid": "Se: serialVersionUID không phải là static. Lớp này định nghĩa trường serialVersionUID nhưng không phải là static. Trường này nên được khai báo là static nếu nó được dự định chỉ ra version UID cho mục đích serialization.",
      "se_nonlong_serialversionid": "Se: serialVersionUID không phải là kiểu long. Lớp này định nghĩa trường serialVersionUID nhưng không phải là kiểu long. Trường này nên được khai báo là long nếu nó được dự định chỉ ra version UID cho mục đích serialization.",
      "se_bad_field": "Se: Trường instance không phải transient, không phải serializable trong lớp serializable. Lớp Serializable này định nghĩa một trường instance không phải là kiểu nguyên thủy, không phải transient, không phải Serializable, cũng không phải java.lang.Object, và có vẻ như không triển khai interface Externalizable hay các phương thức readObject() và writeObject(). Các đối tượng của lớp này sẽ không được deserialized chính xác nếu một đối tượng không phải Serializable được lưu trữ trong trường này.",
      "se_inner_class": "Se: Lớp con Serializable. Lớp Serializable này là một lớp con. Mọi cố gắng để serialize nó cũng sẽ serialize instance của lớp ngoài. Instance của lớp ngoài là serializable, vì vậy quá trình này sẽ không thất bại, nhưng có thể sẽ serialize nhiều dữ liệu hơn so với dự định. Nếu có thể, hãy làm cho lớp con trở thành lớp con tĩnh (hay còn gọi là lớp lồng nhau) để giải quyết vấn đề này.",
      "se_bad_field_inner_class": "Se: Lớp không serializable có một lớp con serializable. Lớp Serializable này là một lớp con của một lớp không serializable. Vì vậy, các nỗ lực để serialize nó cũng sẽ cố gắng kết hợp instance của lớp ngoài mà nó liên kết, dẫn đến lỗi tại thời điểm chạy. Nếu có thể, hãy làm cho lớp con trở thành lớp con tĩnh để giải quyết vấn đề. Làm cho lớp ngoài trở thành serializable cũng có thể có tác dụng, nhưng điều đó có nghĩa là việc serialize một instance của lớp con sẽ luôn luôn đồng thời serialize instance của lớp ngoài, điều này thường không phải là điều bạn thực sự mong muốn.",
      "se_bad_field_store": "Se: Giá trị không serializable được lưu trữ vào trường instance của lớp serializable. Một giá trị không serializable được lưu trữ vào trường không phải transient của một lớp serializable.",
      "rv_return_value_ignored_bad_practice": "RV: Phương thức bỏ qua giá trị trả về bất thường. Phương thức này trả về một giá trị mà không kiểm tra. Giá trị trả về nên được kiểm tra vì nó có thể chỉ ra một sự thực thi hàm bất thường hoặc không mong đợi. Ví dụ, phương thức File.delete() trả về false nếu không thể xóa tệp thành công (thay vì ném ra một Exception). Nếu bạn không kiểm tra kết quả, bạn sẽ không nhận ra nếu việc gọi phương thức báo hiệu hành vi bất thường bằng cách trả về một giá trị trả về không điển hình. Xem CWE-253: Kiểm tra không đúng giá trị trả về của hàm.",
      "np_tostring_could_return_null": "NP: Phương thức toString có thể trả về null. Phương thức toString này có vẻ trả về null trong một số trường hợp. Một cách đọc thoải mái của đặc tả có thể được hiểu là cho phép điều này, nhưng có lẽ đây là một ý tưởng xấu và có thể làm cho các mã khác bị hỏng. Hãy trả về chuỗi rỗng hoặc một chuỗi thích hợp khác thay vì null.",
      "np_clone_could_return_null": "NP: Phương thức Clone có thể trả về null. Phương thức clone này có vẻ trả về null trong một số trường hợp, nhưng phương thức clone không bao giờ được phép trả về giá trị null. Nếu bạn chắc chắn rằng đường dẫn này không thể tiếp cận, hãy ném ra một AssertionError thay vì vậy.",
      "os_open_stream": "OS: Phương thức có thể thất bại khi đóng luồng. Phương thức này tạo ra một đối tượng luồng IO, không gán nó vào bất kỳ trường nào, không chuyển nó cho các phương thức khác có thể đóng nó, hoặc không trả về nó, và không có vẻ đóng luồng trên tất cả các đường đi ra khỏi phương thức. Điều này có thể dẫn đến rò rỉ mô tả tệp. Thông thường, một ý tưởng tốt là sử dụng khối finally để đảm bảo rằng các luồng được đóng. Xem CWE-459: Dọn dẹp không đầy đủ.",
      "os_open_stream_exception_path": "OS: Phương thức có thể thất bại khi đóng luồng khi gặp ngoại lệ. Phương thức này tạo ra một đối tượng luồng IO, không gán nó vào bất kỳ trường nào, không chuyển nó cho các phương thức khác, không trả về nó, và không có vẻ đóng luồng trong tất cả các đường đi ngoại lệ ra khỏi phương thức. Điều này có thể dẫn đến rò rỉ mô tả tệp. Thông thường, một ý tưởng tốt là sử dụng khối finally để đảm bảo rằng các luồng được đóng. Xem CWE-459: Dọn dẹp không đầy đủ.",
      "rc_ref_comparison_bad_practice": "RC: So sánh tham chiếu nghi ngờ với hằng số. Phương thức này so sánh giá trị tham chiếu với một hằng số bằng cách sử dụng toán tử == hoặc !=, trong khi cách đúng để so sánh các instance của loại này là sử dụng phương thức equals(). Có thể tạo ra các instance khác nhau nhưng lại bằng nhau mà không thể so sánh bằng == vì chúng là các đối tượng khác nhau. Ví dụ về các lớp không nên so sánh bằng tham chiếu là java.lang.Integer, java.lang.Float, v.v. Xem CWE-595: So sánh tham chiếu đối tượng thay vì nội dung đối tượng.",
      "rc_ref_comparison_bad_practice_boolean": "RC: So sánh tham chiếu nghi ngờ của giá trị Boolean. Phương thức này so sánh hai giá trị Boolean bằng toán tử == hoặc !=. Thông thường, chỉ có hai giá trị Boolean (Boolean.TRUE và Boolean.FALSE), nhưng có thể tạo ra các đối tượng Boolean khác bằng cách sử dụng constructor new Boolean(b). Tốt nhất là tránh các đối tượng như vậy, nhưng nếu chúng tồn tại, việc kiểm tra các đối tượng Boolean để so sánh bằng == hoặc != sẽ cho kết quả khác so với việc sử dụng .equals(...). Xem CWE-595: So sánh tham chiếu đối tượng thay vì nội dung đối tượng.",
      "va_format_string_uses_newline": "FS: Chuỗi định dạng nên sử dụng %n thay vì n. Chuỗi định dạng này bao gồm ký tự newline (\n). Trong chuỗi định dạng, thường thì nên sử dụng %n, điều này sẽ tạo ra dấu phân cách dòng cụ thể cho nền tảng. Khi sử dụng các khối văn bản được giới thiệu trong Java 15, sử dụng chuỗi thoát: String value = ''' first line%n second line%n'';",
      "fs_bad_date_format_flag_combo": "FS: Chuỗi định dạng ngày có thể dẫn đến hành vi không mong muốn. Chuỗi định dạng này bao gồm một sự kết hợp không hợp lý của các cờ có thể dẫn đến hành vi không mong muốn. Một số sự kết hợp không hợp lý có thể bao gồm: sử dụng năm tuần ('Y') với tháng trong năm ('M') và ngày trong tháng ('d') mà không chỉ định tuần trong năm ('w'). Cờ ('y') có thể được ưa chuộng hơn trong trường hợp này. sử dụng giờ AM/PM ('h' hoặc 'K') mà không chỉ định dấu chỉ AM/PM ('a') hoặc dấu chỉ khoảng thời gian trong ngày ('B'). sử dụng giờ định dạng 24 giờ ('H' hoặc 'k') mà không chỉ định dấu chỉ AM/PM hoặc dấu chỉ khoảng thời gian trong ngày. sử dụng milli của ngày ('A') cùng với giờ ('H', 'h', 'K', 'k') và/hoặc phút ('m') và/hoặc giây ('s'). sử dụng milli của ngày ('A') và nano của ngày ('N') cùng nhau. sử dụng phần giây ('S') và nano của giây ('n') cùng nhau. sử dụng các dấu chỉ AM/PM ('a') và khoảng thời gian trong ngày ('B') cùng nhau. sử dụng năm ('y') và năm của kỷ nguyên ('u') cùng nhau.",
      "bit_signed_check": "BIT: Kiểm tra dấu của phép toán bitwise. Phương thức này so sánh một biểu thức như ((event.detail & SWT.SELECTED) > 0). Sử dụng phép toán bitwise và sau đó so sánh với toán tử lớn hơn có thể dẫn đến kết quả không mong muốn (tất nhiên là tùy thuộc vào giá trị của SWT.SELECTED). Nếu SWT.SELECTED là một số âm, đây là một ứng cử viên cho một lỗi. Ngay cả khi SWT.SELECTED không phải là số âm, việc sử dụng '!= 0' thay vì '> 0' có vẻ là một thực tiễn tốt.",
      "odr_open_database_resource": "ODR: Phương thức có thể thất bại khi đóng tài nguyên cơ sở dữ liệu. Phương thức này tạo ra một tài nguyên cơ sở dữ liệu (như kết nối cơ sở dữ liệu hoặc tập hàng), không gán nó vào bất kỳ trường nào, không chuyển nó cho các phương thức khác, không trả về nó, và không có vẻ đóng đối tượng trên tất cả các đường đi ra khỏi phương thức. Việc không đóng tài nguyên cơ sở dữ liệu trên tất cả các đường đi ra khỏi phương thức có thể dẫn đến hiệu suất kém và có thể khiến ứng dụng gặp vấn đề khi giao tiếp với cơ sở dữ liệu. Xem CWE-459: Dọn dẹp không đầy đủ.",
      "odr_open_database_resource_exception_path": "ODR: Phương thức có thể thất bại khi đóng tài nguyên cơ sở dữ liệu khi gặp ngoại lệ. Phương thức này tạo ra một tài nguyên cơ sở dữ liệu (như kết nối cơ sở dữ liệu hoặc tập hàng), không gán nó vào bất kỳ trường nào, không chuyển nó cho các phương thức khác, không trả về nó, và không có vẻ đóng đối tượng trên tất cả các đường đi ngoại lệ ra khỏi phương thức. Việc không đóng tài nguyên cơ sở dữ liệu trên tất cả các đường đi ra khỏi phương thức có thể dẫn đến hiệu suất kém và có thể khiến ứng dụng gặp vấn đề khi giao tiếp với cơ sở dữ liệu. Xem CWE-459: Dọn dẹp không đầy đủ.",
      "isc_instantiate_static_class": "ISC: Tạo thể hiện không cần thiết của lớp chỉ cung cấp các phương thức tĩnh. Lớp này cấp phát một đối tượng dựa trên lớp chỉ cung cấp các phương thức tĩnh. Đối tượng này không cần phải được tạo, chỉ cần truy cập các phương thức tĩnh trực tiếp bằng cách sử dụng tên lớp như là một chỉ thị.",
      "dmi_random_used_only_once": "DMI: Tạo đối tượng Random và sử dụng chỉ một lần. Mã này tạo ra một đối tượng java.util.Random, sử dụng nó để tạo ra một số ngẫu nhiên và sau đó loại bỏ đối tượng Random. Điều này tạo ra các số ngẫu nhiên chất lượng trung bình và không hiệu quả. Nếu có thể, viết lại mã sao cho đối tượng Random được tạo một lần và lưu lại, và mỗi khi cần một số ngẫu nhiên mới, gọi phương thức trên đối tượng Random hiện có để lấy số đó. Nếu điều quan trọng là các số ngẫu nhiên được tạo ra không thể đoán trước, bạn không nên tạo một đối tượng Random mới cho mỗi số ngẫu nhiên; các giá trị rất dễ đoán. Bạn nên cân nhắc sử dụng java.security.SecureRandom thay thế (và tránh cấp phát một SecureRandom mới cho mỗi số ngẫu nhiên cần thiết).",
      "bc_equals_method_should_work_for_all_objects": "BC: Phương thức Equals không nên giả định gì về kiểu của đối số. Phương thức equals(Object o) không nên giả định bất kỳ điều gì về kiểu của o. Nó nên chỉ đơn giản trả về false nếu o không phải là kiểu giống với đối tượng này.",
      "j2_ee_store_of_non_serializable_object_into_session": "J2EE: Lưu trữ đối tượng không thể serialize vào HttpSession. Mã này có vẻ đang lưu trữ một đối tượng không thể serialize vào HttpSession. Nếu session này bị thụ động hóa hoặc di chuyển, một lỗi sẽ xảy ra. Xem CWE-579: Các Thực Hành Sai Lầm trong J2EE: Đối tượng không thể serialize được lưu trong Session.",
      "gc_unchecked_type_in_generic_call": "GC: Kiểu không kiểm tra trong gọi phương thức generic. Lời gọi này đến một phương thức trong collection generic truyền một đối số có kiểu Object trong khi một kiểu cụ thể từ các tham số kiểu generic được kỳ vọng. Do đó, cả hệ thống kiểu Java chuẩn và phân tích tĩnh đều không thể cung cấp thông tin hữu ích về việc liệu đối tượng được truyền vào như một tham số có phải là kiểu phù hợp hay không.",
      "pz_dont_reuse_entry_objects_in_iterators": "PZ: Không tái sử dụng các đối tượng entry trong iterators. Phương thức entrySet() cho phép trả về một chế độ xem của Map cơ sở, trong đó có một Iterator và Map.Entry. Ý tưởng thông minh này đã được sử dụng trong một số triển khai Map, nhưng lại gây ra khả năng sai sót trong lập trình. Nếu một map m trả về iterator cho entrySet, thì c.addAll(m.entrySet()) sẽ gặp lỗi nghiêm trọng. Tất cả các triển khai Map trong OpenJDK 7 đã được viết lại để tránh điều này, bạn cũng nên làm vậy.",
      "dmi_entry_sets_may_reuse_entry_objects": "DMI: Thêm các phần tử của entry set có thể thất bại do tái sử dụng đối tượng Entry. Phương thức entrySet() cho phép trả về một chế độ xem của Map cơ sở, trong đó một đối tượng Entry duy nhất được tái sử dụng và trả về trong suốt quá trình lặp. Kể từ Java 6, cả IdentityHashMap và EnumMap đều làm như vậy. Khi lặp qua một Map như vậy, giá trị Entry chỉ hợp lệ cho đến khi bạn tiến đến lần lặp tiếp theo. Nếu, ví dụ, bạn cố gắng truyền entrySet như vậy cho một phương thức addAll, mọi thứ sẽ đi sai.",
      "dmi_using_removeall_to_clear_collection": "DMI: Đừng sử dụng removeAll để xóa một collection. Nếu bạn muốn xóa tất cả các phần tử trong một collection c, hãy sử dụng c.clear, không phải c.removeAll(c). Gọi c.removeAll(c) để xóa một collection không rõ ràng, dễ dẫn đến lỗi do gõ sai, kém hiệu quả và đối với một số collection, có thể gây ra ConcurrentModificationException.",
      "throws_method_throws_runtimeexception": "THROWS: Phương thức cố tình ném RuntimeException. Phương thức này cố tình ném RuntimeException. Theo quy tắc SEI CERT ERR07-J, việc ném RuntimeException có thể gây ra lỗi, chẳng hạn như người gọi không thể kiểm tra ngoại lệ và do đó không thể phục hồi đúng cách từ nó. Hơn nữa, việc ném RuntimeException sẽ buộc người gọi phải bắt RuntimeException và do đó vi phạm quy tắc SEI CERT ERR08-J. Lưu ý rằng bạn có thể kế thừa từ Exception hoặc RuntimeException và có thể ném một thể hiện mới của ngoại lệ đó. Xem CWE-397: Khai báo Throws cho Ngoại lệ Chung.",
      "throws_method_throws_clause_basic_exception": "THROWS: Phương thức liệt kê Exception trong phần throws, nhưng có thể cụ thể hơn. Phương thức này liệt kê Exception trong phần throws. Khi khai báo một phương thức, các kiểu ngoại lệ trong phần throws nên là các kiểu cụ thể nhất. Do đó, việc sử dụng Exception trong phần throws sẽ buộc người gọi phải sử dụng nó trong phần throws của chính mình, hoặc sử dụng nó trong một khối try-catch (khi nó không nhất thiết chứa bất kỳ thông tin có ý nghĩa nào về ngoại lệ bị ném). Xem quy tắc SEI CERT ERR07-J. Xem CWE-397: Khai báo Throws cho Ngoại lệ Chung.",
      "throws_method_throws_clause_throwable": "THROWS: Phương thức liệt kê Throwable trong phần throws, nhưng có thể cụ thể hơn. Phương thức này liệt kê Throwable trong phần throws. Khi khai báo một phương thức, các kiểu ngoại lệ trong phần throws nên là các kiểu cụ thể nhất. Do đó, việc sử dụng Throwable trong phần throws sẽ buộc người gọi phải sử dụng nó trong phần throws của chính mình, hoặc sử dụng nó trong một khối try-catch (khi nó không nhất thiết chứa bất kỳ thông tin có ý nghĩa nào về ngoại lệ bị ném). Hơn nữa, việc sử dụng Throwable như vậy là một thực hành xấu về mặt ngữ nghĩa, vì Throwables bao gồm cả Errors, nhưng theo định nghĩa, chúng xảy ra trong các tình huống không thể phục hồi. Xem quy tắc SEI CERT ERR07-J. Xem CWE-397: Khai báo Throws cho Ngoại lệ Chung.",
      "pa_public_primitive_attribute": "PA: Trường kiểu nguyên thủy là public. Quy tắc SEI CERT OBJ01-J yêu cầu quyền truy cập vào các trường phải được giới hạn. Nếu không, giá trị của các trường có thể bị thay đổi từ bên ngoài lớp, điều này có thể gây ra hành vi không mong đợi hoặc không mong muốn. Nói chung, yêu cầu không cho phép trường nào là public là quá mức và không thực tế. Ngay cả quy tắc cũng đề cập rằng các trường final có thể là public. Ngoài các trường final, có thể có những cách sử dụng khác cho các trường public: một số trường public có thể đóng vai trò như 'cờ' ảnh hưởng đến hành vi của lớp. Những trường cờ này được kỳ vọng sẽ được đọc bởi thể hiện hiện tại (hoặc lớp hiện tại, trong trường hợp các trường static), nhưng sẽ được ghi bởi các đối tượng khác. Nếu một trường vừa được ghi bởi các phương thức của thể hiện hiện tại (hoặc lớp hiện tại, trong trường hợp các trường static) và từ bên ngoài, mã nguồn sẽ trở nên đáng ngờ. Hãy xem xét việc làm cho các trường này trở thành private và cung cấp các phương thức setter thích hợp, nếu cần. Lưu ý rằng các constructor, initializer và finalizer là ngoại lệ, nếu chúng chỉ ghi trường bên trong lớp, trường đó không được coi là đã được lớp tự ghi. Xem CWE-766: Phần tử dữ liệu quan trọng được khai báo là public.",
      "pa_public_array_attribute": "PA: Trường kiểu mảng là public. Quy tắc SEI CERT OBJ01-J yêu cầu quyền truy cập vào các trường phải được giới hạn. Việc làm cho một trường kiểu mảng là final không ngăn cản các lớp khác thay đổi nội dung của mảng. Tuy nhiên, nói chung, yêu cầu không cho phép trường nào là public là quá mức và không thực tế. Có thể có các cách sử dụng cho các trường public: một số trường public có thể đóng vai trò như 'cờ' ảnh hưởng đến hành vi của lớp. Những trường cờ này được kỳ vọng sẽ được đọc bởi thể hiện hiện tại (hoặc lớp hiện tại, trong trường hợp các trường static), nhưng sẽ được ghi bởi các đối tượng khác. Nếu một trường vừa được ghi bởi các phương thức của thể hiện hiện tại (hoặc lớp hiện tại, trong trường hợp các trường static) và từ bên ngoài, mã nguồn sẽ trở nên đáng ngờ. Hãy xem xét việc làm cho các trường này trở thành private và cung cấp các phương thức setter thích hợp, nếu cần. Lưu ý rằng các constructor, initializer và finalizer là ngoại lệ, nếu chúng chỉ ghi trường bên trong lớp, trường đó không được coi là đã được lớp tự ghi. Xem CWE-766: Phần tử dữ liệu quan trọng được khai báo là public.",
      "pa_public_mutable_object_attribute": "PA: Trường đối tượng có thể thay đổi là public. Quy tắc SEI CERT OBJ01-J yêu cầu quyền truy cập vào các trường phải được giới hạn. Việc làm cho trường đối tượng có thể thay đổi là final không ngăn cản các lớp khác thay đổi nội dung của đối tượng. Tuy nhiên, nói chung, yêu cầu không cho phép trường nào là public là quá mức và không thực tế. Có thể có các cách sử dụng cho các trường public: một số trường public có thể đóng vai trò như 'cờ' ảnh hưởng đến hành vi của lớp. Những trường cờ này được kỳ vọng sẽ được đọc bởi thể hiện hiện tại (hoặc lớp hiện tại, trong trường hợp các trường static), nhưng sẽ được ghi bởi các đối tượng khác. Nếu một trường vừa được ghi bởi các phương thức của thể hiện hiện tại (hoặc lớp hiện tại, trong trường hợp các trường static) và từ bên ngoài, mã nguồn sẽ trở nên đáng ngờ. Hãy xem xét việc làm cho các trường này trở thành private và cung cấp các phương thức setter thích hợp, nếu cần. Lưu ý rằng các constructor, initializer và finalizer là ngoại lệ, nếu chúng chỉ ghi trường bên trong lớp, trường đó không được coi là đã được lớp tự ghi. Trong trường hợp các trường đối tượng, 'ghi' có nghĩa là gọi các phương thức có tên gợi ý sự thay đổi. Xem CWE-766: Phần tử dữ liệu quan trọng được khai báo là public.",
      "pi_do_not_reuse_public_identifiers_class_names": "PI: Không tái sử dụng các định danh public từ JSL làm tên lớp. Đây là một thực hành tốt để tránh tái sử dụng các định danh public từ Java Standard Library làm tên lớp. Lý do là Java Standard Library là một phần của nền tảng Java và được kỳ vọng có sẵn trong tất cả các môi trường Java. Việc làm như vậy có thể dẫn đến xung đột tên và sự nhầm lẫn, làm cho việc hiểu và duy trì mã nguồn trở nên khó khăn hơn. Thực hành tốt nhất là chọn tên lớp duy nhất và mô tả chính xác mục đích và chức năng của mã nguồn của bạn. Ví dụ, giả sử bạn muốn tạo một lớp để xử lý ngày tháng trong ứng dụng của bạn. Thay vì sử dụng tên chung như 'Date', tên này xung đột với lớp java.util.Date đã tồn tại, bạn có thể chọn một tên cụ thể và duy nhất hơn như 'AppDate' hoặc 'DisplayDate'. Một vài điểm chính cần lưu ý khi chọn tên làm định danh: Sử dụng tiền tố hoặc không gian tên có ý nghĩa: Thêm một tiền tố hoặc không gian tên cụ thể của dự án vào tên lớp của bạn để làm chúng nổi bật. Ví dụ, nếu dự án của bạn có tên 'MyApp', bạn có thể sử dụng 'MyAppDate' làm tên lớp của bạn. Sử dụng tên mô tả: Lựa chọn tên lớp mô tả rõ ràng mục đích và chức năng của nó. Điều này giúp tránh việc che khuất các định danh trong Java Standard Library hiện có. Ví dụ, thay vì 'List', bạn có thể sử dụng 'CustomAppList'. Tuân thủ quy ước đặt tên: Tuân theo quy ước đặt tên của Java, chẳng hạn như sử dụng camel case (ví dụ, MyClass) cho tên lớp. Điều này giúp mã nguồn dễ đọc hơn và giảm khả năng xung đột. Xem quy tắc SEI CERT DCL01-J. Không tái sử dụng các định danh public từ Java Standard Library.",
      "pi_do_not_reuse_public_identifiers_field_names": "PI: Không tái sử dụng các định danh public từ JSL làm tên trường. Đây là một thực hành tốt để tránh tái sử dụng các định danh public từ Java Standard Library làm tên trường trong mã nguồn của bạn. Việc làm như vậy có thể dẫn đến sự nhầm lẫn và xung đột tiềm ẩn, làm cho việc hiểu và duy trì mã nguồn trở nên khó khăn hơn. Thay vào đó, nên chọn các tên trường duy nhất và mô tả chính xác mục đích của chúng và phân biệt chúng với các định danh trong Java Standard Library. Ví dụ, giả sử bạn muốn tạo một lớp để xử lý ngày tháng trong ứng dụng của bạn. Thay vì sử dụng tên chung như 'Date', tên này xung đột với lớp java.util.Date đã tồn tại, bạn có thể chọn một tên cụ thể và duy nhất hơn như 'AppDate' hoặc 'DisplayDate'. Ví dụ, giả sử bạn đang tạo một lớp để đại diện cho một chiếc ô tô trong ứng dụng của bạn. Thay vì sử dụng tên chung như 'Component' cho một trường, tên này xung đột với lớp java.awt.Component đã tồn tại, bạn nên chọn một tên cụ thể và rõ ràng hơn, chẳng hạn như 'VehiclePart' hoặc 'CarComponent'. Một vài điểm chính cần lưu ý khi chọn tên làm định danh: Sử dụng tên mô tả: Lựa chọn tên trường mô tả rõ ràng mục đích và chức năng của nó. Điều này giúp tránh việc che khuất các định danh trong Java Standard Library hiện có. Ví dụ, thay vì 'list', bạn có thể sử dụng 'myFancyList'. Tuân thủ quy ước đặt tên: Tuân theo quy ước đặt tên của Java, chẳng hạn như sử dụng chữ hoa và chữ thường cho tên trường. Bắt đầu với chữ cái đầu tiên là chữ thường và các từ bên trong bắt đầu bằng chữ hoa (ví dụ, myFieldUsesMixedCase). Điều này giúp mã nguồn dễ đọc hơn và giảm khả năng xung đột. Xem quy tắc SEI CERT DCL01-J. Không tái sử dụng các định danh public từ Java Standard Library.",
      "pi_do_not_reuse_public_identifiers_method_names": "PI: Không tái sử dụng các định danh public từ JSL làm tên phương thức. Đây là một thực hành tốt để tránh tái sử dụng các định danh public từ Java Standard Library làm tên phương thức trong mã nguồn của bạn. Việc làm như vậy có thể dẫn đến sự nhầm lẫn, xung đột tiềm ẩn và hành vi không mong muốn. Để duy trì sự rõ ràng trong mã và đảm bảo chức năng chính xác, nên chọn các tên phương thức duy nhất và mô tả rõ ràng mục đích của chúng và phân biệt chúng với các định danh trong thư viện chuẩn. Ví dụ, giả sử bạn muốn tạo một phương thức để xử lý việc tạo một tệp tùy chỉnh trong ứng dụng của bạn. Thay vì sử dụng tên chung như 'File' cho phương thức, tên này xung đột với lớp java.io.File đã tồn tại, bạn có thể chọn một tên cụ thể và duy nhất như 'generateFile' hoặc 'createOutPutFile'. Một vài điểm chính cần lưu ý khi chọn tên làm định danh: Sử dụng tên mô tả: Lựa chọn tên phương thức mô tả rõ ràng mục đích và chức năng của nó. Điều này giúp tránh việc che khuất các định danh trong Java Standard Library hiện có. Ví dụ, thay vì 'abs()', bạn có thể sử dụng 'calculateAbsoluteValue()'. Tuân thủ quy ước đặt tên: Tuân theo quy ước đặt tên của Java, chẳng hạn như sử dụng chữ hoa và chữ thường cho tên phương thức. Tên phương thức nên là động từ, bắt đầu với chữ cái đầu tiên là chữ thường và chữ cái đầu tiên của các từ bên trong viết hoa (ví dụ, runFast()). Điều này giúp mã nguồn dễ đọc hơn và giảm khả năng xung đột. Xem quy tắc SEI CERT DCL01-J. Không tái sử dụng các định danh public từ Java Standard Library.",
      "pi_do_not_reuse_public_identifiers_local_variable_names": "PI: Không tái sử dụng các định danh public từ JSL làm tên biến cục bộ. Khi khai báo các biến cục bộ trong Java, đây là một thực hành tốt để tránh tái sử dụng các định danh public từ Java Standard Library. Việc tái sử dụng các định danh này làm tên biến cục bộ có thể dẫn đến sự nhầm lẫn, gây khó khăn trong việc hiểu mã và có thể gây ra xung đột với các tên định danh công khai có sẵn trong Java Standard Library. Để duy trì sự rõ ràng trong mã và tránh các vấn đề như vậy, nên chọn các tên biến cục bộ duy nhất và mô tả rõ ràng mục đích của chúng. Ví dụ, giả sử bạn muốn lưu trữ giá trị phông chữ tùy chỉnh trong một biến. Thay vì sử dụng tên chung như 'Font' cho tên biến, tên này xung đột với lớp java.awt.Font đã tồn tại, bạn có thể chọn một tên cụ thể và duy nhất như 'customFont' hoặc 'loadedFontName'. Một vài điểm chính cần lưu ý khi chọn tên làm định danh: Sử dụng tên mô tả: Lựa chọn tên biến mô tả rõ ràng mục đích và chức năng của nó. Điều này giúp tránh việc che khuất các định danh trong Java Standard Library hiện có. Ví dụ, thay vì 'variable', bạn có thể sử dụng 'myVariableName'. Tuân thủ quy ước đặt tên: Tuân theo quy ước đặt tên của Java, chẳng hạn như sử dụng chữ hoa và chữ thường cho tên biến. Bắt đầu với chữ cái đầu tiên là chữ thường và các từ bên trong bắt đầu bằng chữ hoa (ví dụ, myVariableName). Điều này giúp mã nguồn dễ đọc hơn và giảm khả năng xung đột. Xem quy tắc SEI CERT DCL01-J. Không tái sử dụng các định danh public từ Java Standard Library.",
      "env_use_property_instead_of_env": "ENV: Thực tế là nên sử dụng thuộc tính Java di động thay vì biến môi trường. Các biến môi trường không di động, tên biến (không chỉ giá trị) có thể khác nhau tùy thuộc vào hệ điều hành đang chạy. Không chỉ tên của các biến môi trường cụ thể có thể khác nhau (ví dụ: USERNAME trong Windows và USER trong hệ thống Unix), mà ngay cả ngữ nghĩa cũng khác nhau, ví dụ như tính phân biệt chữ hoa chữ thường (Windows không phân biệt chữ hoa chữ thường và Unix thì phân biệt). Hơn nữa, bản đồ các biến môi trường được trả về bởi java.lang.System.getenv() và các view collection của nó có thể không tuân thủ hợp đồng chung của các phương thức Object.equals(java.lang.Object) và Object.hashCode(). Do đó, việc sử dụng biến môi trường có thể gây ra các hiệu ứng phụ không mong muốn. Thêm vào đó, phạm vi khả dụng của các biến môi trường ít bị hạn chế hơn so với thuộc tính Java: chúng có thể nhìn thấy với tất cả các con cháu của tiến trình định nghĩa, không chỉ các tiến trình Java con ngay lập tức. Vì những lý do này, ngay cả API Java của java.lang.System cũng khuyên nên sử dụng thuộc tính Java (java.lang.System.getProperty(java.lang.String)) thay vì các biến môi trường (java.lang.System.getenv(java.lang.String)) nếu có thể. Nếu một giá trị có thể truy cập thông qua cả System.getProperty() và System.getenv(), nó nên được truy cập bằng phương thức đầu tiên. Mapping các thuộc tính Java System tương ứng: Biến môi trường \t Thuộc tính JAVA_HOME \t java.home JAVA_VERSION \t java.version TEMP \t java.io.tmpdir TMP \t java.io.tmpdir PROCESSOR_ARCHITECTURE \t os.arch OS \t os.name USER \t user.name USERNAME \t user.name HOME \t user.home HOMEPATH \t user.home CD \t user.dir PWD \t user.dir Xem quy tắc SEI CERT ENV02-J. Không tin tưởng vào giá trị của các biến môi trường.",
      "overriding_methods_must_invoke_super": "CN: Phương thức super được chú thích với @OverridingMethodsMustInvokeSuper, nhưng phương thức ghi đè lại không gọi phương thức super. Phương thức super được chú thích với @OverridingMethodsMustInvokeSuper, nhưng phương thức ghi đè lại không gọi phương thức super.",
      "np_optional_return_null": "NP: Phương thức có kiểu trả về Optional trả về null rõ ràng. Việc sử dụng kiểu trả về Optional (java.util.Optional hoặc com.google.common.base.Optional) luôn có nghĩa là việc trả về null rõ ràng không được mong muốn theo thiết kế. Trả về giá trị null trong trường hợp này là vi phạm hợp đồng và có khả năng làm hỏng mã của khách hàng.",
      "np_nonnull_field_not_initialized_in_constructor": "NP: Trường không null không được khởi tạo. Trường được đánh dấu là không null, nhưng không được ghi vào bởi constructor. Trường có thể được khởi tạo ở nơi khác trong constructor, hoặc có thể luôn được khởi tạo trước khi sử dụng.",
      "vr_unresolvable_reference": "VR: Lớp tham chiếu đến lớp hoặc phương thức không thể giải quyết. Lớp này tham chiếu đến một lớp hoặc phương thức mà không thể giải quyết được bằng các thư viện mà nó đang được phân tích.",
      "il_infinite_loop": "IL: Vòng lặp vô hạn rõ ràng. Vòng lặp này không có cách nào để kết thúc (ngoài việc có thể ném một ngoại lệ). Xem CWE-835: Vòng lặp với điều kiện thoát không thể đạt được ('Vòng lặp vô hạn').",
      "io_appending_to_object_output_stream": "IO: Nỗ lực không thành công khi thêm vào một object output stream. Mã này mở một tệp ở chế độ thêm và sau đó bọc kết quả vào một object output stream như sau: OutputStream out = new FileOutputStream(anyFile, true); new ObjectOutputStream(out); Điều này sẽ không cho phép bạn thêm vào một object output stream đã tồn tại trong tệp. Nếu bạn muốn có thể thêm vào một object output stream, bạn cần giữ object output stream đó mở. Tình huống duy nhất mà mở tệp ở chế độ thêm và ghi một object output stream có thể hoạt động là nếu khi đọc tệp, bạn dự định mở nó ở chế độ truy cập ngẫu nhiên và tìm đến vị trí byte mà việc thêm đã bắt đầu.",
      "il_infinite_recursive_loop": "IL: Vòng lặp đệ quy vô hạn rõ ràng. Phương thức này gọi chính nó mà không có điều kiện dừng. Điều này có vẻ chỉ ra một vòng lặp đệ quy vô hạn, dẫn đến tràn ngăn xếp. Xem CWE-674: Đệ quy không kiểm soát và CWE-835: Vòng lặp với điều kiện thoát không thể đạt được ('Vòng lặp vô hạn').",
      "il_container_added_to_itself": "IL: Một tập hợp được thêm vào chính nó. Một tập hợp được thêm vào chính nó. Kết quả là, khi tính toán hashCode của tập hợp này sẽ gây ra lỗi StackOverflowException.",
      "rp_c_repeated_conditional_test": "RpC: Kiểm tra điều kiện lặp lại. Mã chứa một phép kiểm tra điều kiện được thực hiện hai lần, một ngay sau lần kia (ví dụ, x == 0",
      "fl_math_using_float_precision": "FL: Phương thức thực hiện toán học sử dụng độ chính xác của số thực. Phương thức này thực hiện các phép toán sử dụng độ chính xác của số thực. Độ chính xác của số thực rất không chính xác. Ví dụ, 16777216.0f + 1.0f = 16777216.0f. Cân nhắc sử dụng toán học với kiểu double thay thế. Xem CWE-1339: Độ chính xác hoặc độ chính xác không đủ của một số thực.",
      "caa_covariant_array_element_store": "CAA: Phần tử không tương thích có thể được lưu trong mảng đồng biến. Giá trị được lưu vào mảng và kiểu giá trị không khớp với kiểu mảng. Được biết từ phân tích rằng kiểu mảng thực tế hẹp hơn kiểu khai báo của biến hoặc trường và việc gán này không thỏa mãn kiểu mảng ban đầu. Việc gán này có thể gây ra ArrayStoreException khi chạy.",
      "dmi_vacuous_call_to_easymock_method": "Dm: Lệnh gọi EasyMock vô ích/không cần thiết. Lệnh gọi này không truyền bất kỳ đối tượng nào cho phương thức EasyMock, vì vậy lệnh gọi này không thực hiện gì cả.",
      "dmi_futile_attempt_to_change_maxpool_size_of_scheduled_thread_pool_executor": "Dm: Nỗ lực vô ích để thay đổi kích thước tối đa của ScheduledThreadPoolExecutor. (Javadoc) Mặc dù ScheduledThreadPoolExecutor kế thừa từ ThreadPoolExecutor, một số phương thức điều chỉnh thừa kế không hữu ích cho nó. Cụ thể, vì nó hoạt động như một pool kích thước cố định sử dụng các luồng corePoolSize và một hàng đợi không giới hạn, các điều chỉnh đối với maximumPoolSize không có hiệu quả hữu ích.",
      "dmi_bigdecimal_constructed_from_double": "DMI: BigDecimal được tạo từ double mà không được biểu diễn chính xác. Mã này tạo ra một BigDecimal từ giá trị double không chuyển đổi chính xác thành số thập phân. Ví dụ, người ta có thể cho rằng việc viết new BigDecimal(0.1) trong Java tạo ra một BigDecimal có giá trị chính xác bằng 0.1 (giá trị chưa được thay đổi là 1, với độ chính xác là 1), nhưng thực tế nó bằng 0.1000000000000000055511151231257827021181583404541015625. Bạn có thể muốn sử dụng phương thức BigDecimal.valueOf(double d), sử dụng biểu diễn String của double để tạo BigDecimal (ví dụ, BigDecimal.valueOf(0.1) cho 0.1). Xem CWE-1339: Độ chính xác hoặc độ chính xác không đủ của một số thực.",
      "dmi_scheduled_thread_pool_executor_with_zero_core_threads": "Dm: Tạo ScheduledThreadPoolExecutor với số luồng core bằng 0.",
      "dmi_annotation_is_not_visible_to_reflection": "Dm: Không thể sử dụng reflection để kiểm tra sự hiện diện của annotation mà không có retention runtime. Trừ khi một annotation được đánh dấu với @Retention(RetentionPolicy.RUNTIME), annotation không thể được quan sát bằng reflection (ví dụ, sử dụng phương thức isAnnotationPresent).",
      "np_argument_might_be_null": "NP: Phương thức không kiểm tra đối số null. Một tham số của phương thức này đã được xác định là giá trị cần luôn được kiểm tra xem có phải là null hay không, nhưng nó đang bị tham chiếu mà không có kiểm tra null trước.",
      "rv_absolute_value_of_random_int": "RV: Nỗ lực sai khi tính giá trị tuyệt đối của số nguyên ngẫu nhiên có dấu. Mã này tạo ra một số nguyên ngẫu nhiên có dấu và sau đó tính giá trị tuyệt đối của số nguyên ngẫu nhiên đó. Nếu số được trả về từ bộ sinh số ngẫu nhiên là Integer.MIN_VALUE, kết quả cũng sẽ là giá trị âm (vì Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE). (Vấn đề tương tự xảy ra với giá trị long).",
      "rv_absolute_value_of_hashcode": "RV: Nỗ lực sai khi tính giá trị tuyệt đối của hashcode 32-bit có dấu. Mã này tạo ra một hashcode và sau đó tính giá trị tuyệt đối của hashcode đó. Nếu hashcode là Integer.MIN_VALUE, kết quả cũng sẽ là giá trị âm (vì Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE). Một trong 2^32 chuỗi có hashCode là Integer.MIN_VALUE, bao gồm 'polygenelubricants', 'GydZG_' và ''DESIGNING WORKHOUSES'.",
      "rv_01_to_int": "RV: Giá trị ngẫu nhiên từ 0 đến 1 bị ép buộc thành số nguyên 0. Một giá trị ngẫu nhiên từ 0 đến 1 đang bị ép buộc thành giá trị số nguyên 0. Bạn có thể muốn nhân giá trị ngẫu nhiên với một giá trị khác trước khi ép buộc nó thành số nguyên, hoặc sử dụng phương thức Random.nextInt(n).",
      "dm_invalid_min_max": "Dm: Kết hợp sai giữa Math.max và Math.min. Mã này cố gắng giới hạn phạm vi giá trị sử dụng cấu trúc như Math.min(0, Math.max(100, value)). Tuy nhiên, thứ tự của các hằng số là sai: nó phải là Math.min(100, Math.max(0, value)). Kết quả là mã này luôn tạo ra cùng một kết quả (hoặc NaN nếu giá trị là NaN).",
      "eq_comparing_class_names": "Eq: Phương thức equals so sánh tên lớp thay vì các đối tượng lớp. Lớp này định nghĩa phương thức equals kiểm tra xem hai đối tượng có cùng lớp không bằng cách kiểm tra xem tên lớp của chúng có bằng nhau không. Bạn có thể có các lớp khác nhau với cùng tên nếu chúng được tải bởi các class loader khác nhau. Hãy kiểm tra xem các đối tượng lớp có giống nhau không. Xem CWE-486: So sánh các lớp bằng tên.",
      "eq_always_true": "Eq: Phương thức equals luôn trả về true. Lớp này định nghĩa phương thức equals luôn trả về true. Điều này tưởng tượng nhưng không rất thông minh. Hơn nữa, điều này có nghĩa là phương thức equals không đối xứng. Xem CWE-571: Biểu thức luôn đúng.",
      "eq_always_false": "Eq: Phương thức equals luôn trả về false. Lớp này định nghĩa phương thức equals luôn trả về false. Điều này có nghĩa là một đối tượng không bằng chính nó, và không thể tạo ra các Map hoặc Set hữu ích từ lớp này. Quan trọng hơn, điều này có nghĩa là equals không phản xạ, một trong những yêu cầu của phương thức equals. Ý nghĩa có thể là sự đồng nhất đối tượng: một đối tượng bằng chính nó. Đây là hành vi kế thừa từ lớp Object. Nếu bạn cần ghi đè một equals được kế thừa từ lớp cha khác, bạn có thể sử dụng: public boolean equals(Object o) { return this == o; } Xem CWE-570: Biểu thức luôn sai.",
      "eq_overriding_equals_not_symmetric": "Eq: Phương thức equals ghi đè phương thức equals trong lớp cha và có thể không đối xứng. Lớp này định nghĩa một phương thức equals ghi đè phương thức equals trong lớp cha. Cả hai phương thức equals đều sử dụng instanceof để xác định xem hai đối tượng có bằng nhau hay không. Điều này rất nguy hiểm, vì quan trọng là phương thức equals phải đối xứng (nói cách khác, a.equals(b) == b.equals(a)). Nếu B là một kiểu con của A, và phương thức equals của A kiểm tra đối số có phải là instanceof A, và phương thức equals của B kiểm tra đối số có phải là instanceof B, thì rất có thể quan hệ tương đương được định nghĩa bởi các phương thức này không đối xứng.",
      "eq_dont_define_equals_for_enum": "Eq: Phương thức equals() đồng loại được định nghĩa cho enum. Lớp này định nghĩa một kiểu liệt kê, và sự bằng nhau của các kiểu liệt kê được định nghĩa bằng nhận dạng đối tượng. Định nghĩa một phương thức equals đồng loại cho một giá trị kiểu liệt kê là một thực hành cực kỳ xấu, vì nó có thể dẫn đến việc có hai giá trị kiểu liệt kê khác nhau nhưng lại so sánh bằng nhau khi sử dụng phương thức enum đồng loại, và không bằng nhau khi so sánh thông thường. Đừng làm vậy.",
      "eq_self_use_object": "Eq: Phương thức equals() đồng loại được định nghĩa, Object.equals(Object) kế thừa. Lớp này định nghĩa một phiên bản đồng loại của phương thức equals(), nhưng kế thừa phương thức equals(Object) bình thường được định nghĩa trong lớp java.lang.Object cơ sở. Lớp này có thể cần định nghĩa một phương thức boolean equals(Object).",
      "eq_other_use_object": "Eq: Phương thức equals() được định nghĩa nhưng không ghi đè Object.equals(Object). Lớp này định nghĩa một phương thức equals() nhưng không ghi đè phương thức equals(Object) bình thường được định nghĩa trong lớp java.lang.Object cơ sở. Lớp này có thể cần định nghĩa một phương thức boolean equals(Object).",
      "eq_other_no_object": "Eq: Phương thức equals() được định nghĩa nhưng không ghi đè equals(Object). Lớp này định nghĩa một phương thức equals() nhưng không ghi đè phương thức equals(Object) bình thường được định nghĩa trong lớp java.lang.Object cơ sở. Thay vào đó, nó kế thừa phương thức equals(Object) từ lớp cha. Lớp này có thể cần định nghĩa một phương thức boolean equals(Object).",
      "he_signature_declares_hashing_of_unhashable_class": "HE: Chữ ký khai báo sử dụng lớp không thể băm trong cấu trúc băm. Một phương thức, trường hoặc lớp khai báo một chữ ký tổng quát mà trong đó một lớp không thể băm được sử dụng trong ngữ cảnh yêu cầu lớp có thể băm. Một lớp khai báo phương thức equals nhưng kế thừa phương thức hashCode() từ Object là lớp không thể băm, vì nó không đáp ứng yêu cầu các đối tượng bằng nhau phải có hashCode bằng nhau.",
      "he_use_of_unhashable_class": "HE: Sử dụng lớp không có phương thức hashCode() trong cấu trúc dữ liệu băm. Lớp định nghĩa phương thức equals(Object) nhưng không có phương thức hashCode(), và do đó không đáp ứng yêu cầu các đối tượng bằng nhau phải có hashCode bằng nhau. Một thể hiện của lớp này được sử dụng trong cấu trúc dữ liệu băm, vì vậy việc sửa vấn đề này là cực kỳ quan trọng.",
      "ur_uninit_read": "UR: Đọc trường chưa được khởi tạo trong constructor. Constructor này đọc một trường chưa được gán giá trị. Điều này thường xảy ra khi lập trình viên vô tình sử dụng trường thay vì một trong các tham số của constructor. Xem CWE-457: Sử dụng Biến Chưa Khởi Tạo.",
      "ur_uninit_read_called_from_super_constructor": "UR: Đọc trường chưa được khởi tạo trong phương thức gọi từ constructor của lớp cha. Phương thức này được gọi trong constructor của lớp cha. Lúc này, các trường của lớp chưa được khởi tạo. Để làm rõ hơn, xem xét các lớp sau: abstract class A { int hashCode; abstract Object getValue(); A() { hashCode = getValue().hashCode(); } } class B extends A { Object value; B(Object v) { this.value = v; } Object getValue() { return value; } } Khi một B được tạo ra, constructor của lớp A được gọi trước khi constructor của B gán giá trị cho value. Do đó, khi constructor của A gọi getValue, một giá trị chưa được khởi tạo được đọc cho value. Xem CWE-457: Sử dụng Biến Chưa Khởi Tạo.",
      "nm_very_confusing": "Nm: Tên phương thức rất gây nhầm lẫn. Các phương thức được tham chiếu có tên chỉ khác nhau ở chữ hoa. Điều này rất gây nhầm lẫn vì nếu chữ hoa giống nhau thì một trong các phương thức sẽ ghi đè phương thức kia.",
      "nm_wrong_package": "Nm: Phương thức không ghi đè phương thức trong lớp cha do tham số có gói sai. Phương thức trong lớp con không ghi đè một phương thức tương tự trong lớp cha vì kiểu của một tham số không hoàn toàn khớp với kiểu của tham số tương ứng trong lớp cha. Ví dụ, nếu bạn có: import alpha.Foo; public class A { public int f(Foo x) { return 17; } } ---- import beta.Foo; public class B extends A { public int f(Foo x) { return 42; } } Phương thức f(Foo) được định nghĩa trong lớp B không ghi đè phương thức f(Foo) được định nghĩa trong lớp A, vì kiểu tham số Foo thuộc các gói khác nhau.",
      "nm_method_constructor_confusion": "Nm: Nhầm lẫn rõ ràng giữa phương thức và constructor. Phương thức thông thường này có cùng tên với lớp mà nó được định nghĩa. Có khả năng đây là một constructor. Nếu đúng là constructor, hãy loại bỏ khai báo kiểu trả về void. Nếu bạn vô tình định nghĩa phương thức này, nhận ra sai lầm, định nghĩa một constructor đúng nhưng không thể xóa phương thức này do tính tương thích ngược, hãy đánh dấu phương thức này là đã lỗi thời.",
      "nm_lcase_hashcode": "Nm: Lớp định nghĩa hashcode(); có phải là hashCode()? Lớp này định nghĩa một phương thức gọi là hashcode(). Phương thức này không ghi đè phương thức hashCode() trong java.lang.Object, điều này có thể là ý định ban đầu.",
      "nm_lcase_tostring": "Nm: Lớp định nghĩa tostring(); có phải là toString()? Lớp này định nghĩa một phương thức gọi là tostring(). Phương thức này không ghi đè phương thức toString() trong java.lang.Object, điều này có thể là ý định ban đầu.",
      "nm_bad_equal": "Nm: Lớp định nghĩa equal(Object); có phải là equals(Object)? Lớp này định nghĩa một phương thức equal(Object). Phương thức này không ghi đè phương thức equals(Object) trong java.lang.Object, điều này có thể là ý định ban đầu.",
      "se_read_resolve_is_static": "Se: Phương thức readResolve không được khai báo là phương thức tĩnh. Để phương thức readResolve được công nhận bởi cơ chế serialization, nó không được khai báo là phương thức tĩnh.",
      "se_method_must_be_private": "Se: Phương thức phải là private để serialization hoạt động. Lớp này triển khai interface Serializable và định nghĩa một phương thức cho serialization/deserialization tùy chỉnh. Nhưng vì phương thức này không được khai báo là private, nó sẽ bị bỏ qua một cách âm thầm bởi API serialization/deserialization.",
      "sf_dead_store_due_to_switch_fallthrough": "SF: Lưu giá trị không cần thiết do sự cố switch statement fall through. Một giá trị đã được lưu trong case trước bị ghi đè ở đây do sự cố fall through của switch. Có thể bạn đã quên đặt break hoặc return ở cuối case trước. Xem CWE-484: Thiếu câu lệnh Break trong Switch.",
      "sf_dead_store_due_to_switch_fallthrough_to_throw": "SF: Lưu giá trị không cần thiết do sự cố switch statement fall through đến throw. Một giá trị đã được lưu trong case trước bị bỏ qua ở đây do sự cố fall through của switch đến một nơi mà ngoại lệ được ném ra. Có thể bạn đã quên đặt break hoặc return ở cuối case trước. Xem CWE-484: Thiếu câu lệnh Break trong Switch.",
      "np_unwritten_field": "NP: Đọc trường chưa được ghi. Chương trình đang dereference một trường mà không có giá trị không null nào được ghi vào đó. Trừ khi trường được khởi tạo thông qua một cơ chế mà phân tích không thể nhìn thấy, việc dereference giá trị này sẽ gây ra ngoại lệ null pointer. Xem CWE-457: Sử dụng Biến Chưa Khởi Tạo.",
      "uwf_null_field": "UwF: Trường chỉ được gán giá trị null. Tất cả các ghi vào trường này đều có giá trị null, vì vậy tất cả các lần đọc trường sẽ trả về null. Kiểm tra lỗi hoặc loại bỏ nếu nó vô dụng.",
      "uwf_unwritten_field": "UwF: Trường chưa được ghi. Trường này không bao giờ được ghi. Tất cả các lần đọc trường này sẽ trả về giá trị mặc định. Kiểm tra lỗi (nó có nên được khởi tạo không?), hoặc loại bỏ nếu nó vô dụng. Xem CWE-457: Sử dụng Biến Chưa Khởi Tạo.",
      "sic_threadlocal_deadly_embrace": "SIC: Mối quan hệ chết giữa lớp con không tĩnh và thread local. Lớp này là lớp con, nhưng có lẽ nên là lớp con tĩnh. Như hiện tại, có một nguy cơ lớn về mối quan hệ chết giữa lớp con và thread local trong lớp ngoài. Vì lớp con không tĩnh, nó giữ tham chiếu đến lớp ngoài. Nếu thread local chứa tham chiếu đến một instance của lớp con, cả instance lớp con và lớp ngoài sẽ đều có thể truy cập và không thể thu gom rác.",
      "range_array_index": "RANGE: Chỉ số mảng vượt ra ngoài phạm vi. Thao tác trên mảng được thực hiện, nhưng chỉ số mảng vượt ra ngoài phạm vi, điều này sẽ dẫn đến ArrayIndexOutOfBoundsException khi chạy.",
      "range_array_offset": "RANGE: Offset mảng vượt ra ngoài phạm vi. Phương thức được gọi với tham số mảng và tham số offset, nhưng offset vượt ra ngoài phạm vi. Điều này sẽ dẫn đến IndexOutOfBoundsException khi chạy.",
      "range_array_length": "RANGE: Chiều dài mảng vượt ra ngoài phạm vi. Phương thức được gọi với tham số mảng và tham số chiều dài, nhưng chiều dài vượt ra ngoài phạm vi. Điều này sẽ dẫn đến IndexOutOfBoundsException khi chạy.",
      "range_string_index": "RANGE: Chỉ số chuỗi vượt ra ngoài phạm vi. Phương thức chuỗi được gọi và chỉ số chuỗi chỉ định vượt ra ngoài phạm vi. Điều này sẽ dẫn đến StringIndexOutOfBoundsException khi chạy.",
      "rv_return_value_ignored": "RV: Phương thức bỏ qua giá trị trả về. Giá trị trả về của phương thức này cần được kiểm tra. Một nguyên nhân phổ biến của cảnh báo này là gọi phương thức trên một đối tượng bất biến, nghĩ rằng nó sẽ cập nhật đối tượng đó. Ví dụ, trong đoạn mã sau, String dateString = getHeaderField(name); dateString.trim(); lập trình viên có vẻ nghĩ rằng phương thức trim() sẽ cập nhật chuỗi được tham chiếu bởi dateString. Nhưng vì Strings là bất biến, hàm trim() trả về một giá trị String mới, và giá trị này bị bỏ qua ở đây. Mã cần được sửa lại thành: String dateString = getHeaderField(name); dateString = dateString.trim(); Xem CWE-252: Không Kiểm Tra Giá Trị Trả Về.",
      "rv_exception_not_thrown": "RV: Ngoại lệ được tạo ra và bỏ qua thay vì ném ra. Mã này tạo ra một đối tượng ngoại lệ (hoặc lỗi), nhưng không làm gì với nó. Ví dụ, một cái gì đó như: if (x < 0) { new IllegalArgumentException('x must be nonnegative'); } Có thể ý định của lập trình viên là ném ngoại lệ đã tạo ra: if (x < 0) { throw new IllegalArgumentException('x must be nonnegative'); }",
      "rv_check_compareto_for_specific_return_value": "RV: Mã kiểm tra các giá trị cụ thể trả về bởi compareTo. Mã này gọi phương thức compareTo hoặc compare, và kiểm tra xem giá trị trả về có phải là một giá trị cụ thể, như 1 hoặc -1 không. Khi gọi các phương thức này, bạn chỉ nên kiểm tra dấu của kết quả, chứ không kiểm tra bất kỳ giá trị không phải là 0 cụ thể nào. Mặc dù nhiều hoặc hầu hết các phương thức compareTo và compare chỉ trả về -1, 0 hoặc 1, một số phương thức trong số chúng sẽ trả về các giá trị khác. Xem CWE-253: Kiểm tra không chính xác giá trị trả về của hàm.",
      "np_always_null": "NP: Dereference con trỏ null. Một con trỏ null đang được dereference ở đây. Điều này sẽ dẫn đến NullPointerException khi mã được thực thi.",
      "np_closing_null": "NP: close() được gọi trên giá trị luôn là null. close() đang được gọi trên một giá trị luôn là null. Nếu câu lệnh này được thực thi, sẽ xảy ra ngoại lệ null pointer. Tuy nhiên, nguy cơ lớn ở đây là bạn không bao giờ đóng thứ gì đó mà lẽ ra phải đóng.",
      "np_store_into_nonnull_field": "NP: Lưu giá trị null vào trường được chú thích @Nonnull. Một giá trị có thể là null được lưu vào một trường đã được chú thích là @Nonnull.",
      "np_always_null_exception": "NP: Dereference con trỏ null trong phương thức trên đường dẫn ngoại lệ. Một con trỏ null trên đường dẫn ngoại lệ đang được dereference ở đây. Điều này sẽ dẫn đến NullPointerException khi mã được thực thi. Lưu ý rằng vì SpotBugs hiện tại không cắt bỏ các đường dẫn ngoại lệ không khả thi, đây có thể là một cảnh báo sai. Cũng lưu ý rằng SpotBugs xem trường hợp mặc định của câu lệnh switch là một đường dẫn ngoại lệ, vì trường hợp mặc định thường không khả thi.",
      "np_null_on_some_path": "NP: Có thể dereference con trỏ null. Có một nhánh câu lệnh mà nếu được thực thi, sẽ đảm bảo rằng một giá trị null sẽ được dereference, điều này sẽ tạo ra NullPointerException khi mã được thực thi. Tất nhiên, vấn đề có thể là nhánh hoặc câu lệnh không khả thi và ngoại lệ con trỏ null không bao giờ có thể được thực thi; việc quyết định điều này vượt quá khả năng của SpotBugs.",
      "np_null_on_some_path_exception": "NP: Có thể dereference con trỏ null trong phương thức trên đường dẫn ngoại lệ. Một giá trị tham chiếu null trên một số đường dẫn điều khiển ngoại lệ đang được dereference ở đây. Điều này có thể dẫn đến NullPointerException khi mã được thực thi. Lưu ý rằng vì SpotBugs hiện tại không cắt bỏ các đường dẫn ngoại lệ không khả thi, đây có thể là một cảnh báo sai. Cũng lưu ý rằng SpotBugs xem trường hợp mặc định của câu lệnh switch là một đường dẫn ngoại lệ, vì trường hợp mặc định thường không khả thi.",
      "np_null_param_deref": "NP: Gọi phương thức truyền giá trị null cho tham số không null. Lần gọi phương thức này truyền giá trị null cho một tham số phương thức không thể là null. Hoặc tham số này được chú thích là tham số luôn không null, hoặc phân tích đã chỉ ra rằng nó sẽ luôn được dereference.",
      "np_null_param_deref_nonvirtual": "NP: Gọi phương thức không ảo truyền giá trị null cho tham số không null. Một giá trị có thể là null được truyền cho một tham số phương thức không thể là null. Hoặc tham số này được chú thích là tham số luôn không null, hoặc phân tích đã chỉ ra rằng nó sẽ luôn được dereference.",
      "np_null_param_deref_all_targets_dangerous": "NP: Lần gọi phương thức truyền giá trị null cho tham số không null. Một giá trị có thể là null được truyền tại một điểm gọi mà tất cả các phương thức đích đã biết yêu cầu tham số phải là không null. Hoặc tham số này được chú thích là tham số luôn không null, hoặc phân tích đã chỉ ra rằng nó sẽ luôn được dereference.",
      "np_nonnull_param_violation": "NP: Lần gọi phương thức truyền null cho tham số không null. Phương thức này truyền giá trị null như một tham số của một phương thức mà tham số đó phải không null. Hoặc tham số này đã được chú thích rõ ràng là @Nonnull, hoặc phân tích đã xác định rằng tham số này luôn được dereference.",
      "np_nonnull_return_violation": "NP: Phương thức có thể trả về null, nhưng được khai báo @Nonnull. Phương thức này có thể trả về giá trị null, nhưng phương thức (hoặc phương thức của lớp cha mà nó ghi đè) được khai báo là trả về @Nonnull.",
      "np_guaranteed_deref": "NP: Giá trị null được đảm bảo sẽ được dereference. Có một câu lệnh hoặc nhánh mà nếu được thực thi, đảm bảo rằng giá trị là null tại điểm này và giá trị này sẽ được dereference (ngoại trừ trên các đường dẫn tiếp theo liên quan đến ngoại lệ thời gian chạy). Lưu ý rằng một kiểm tra như if (x == null) throw new NullPointerException(); được coi là một lần dereference x.",
      "np_guaranteed_deref_on_exception_path": "NP: Giá trị là null và được đảm bảo sẽ được dereference trên đường dẫn ngoại lệ. Có một câu lệnh hoặc nhánh trên đường dẫn ngoại lệ mà nếu được thực thi, đảm bảo rằng giá trị là null tại điểm này và giá trị này sẽ được dereference (ngoại trừ trên các đường dẫn tiếp theo liên quan đến ngoại lệ thời gian chạy).",
      "dmi_arguments_wrong_order": "DMI: Đối số phương thức bị đảo ngược. Các đối số cho lần gọi phương thức này có vẻ bị đảo ngược thứ tự. Ví dụ, một lần gọi Preconditions.checkNotNull('message', message) có đối số bị đảo ngược: giá trị cần kiểm tra là đối số đầu tiên. Xem CWE-683: Gọi hàm với thứ tự đối số không chính xác.",
      "rcn_redundant_nullcheck_would_have_been_a_npe": "RCN: Kiểm tra null cho giá trị đã được dereference trước đó. Một giá trị được kiểm tra xem có phải là null không, nhưng giá trị này không thể là null vì nó đã được dereference trước đó và nếu nó là null thì một ngoại lệ con trỏ null đã xảy ra tại lần dereference trước. Thực chất, mã này và lần dereference trước đó không đồng ý về việc giá trị này có thể là null hay không. Hoặc kiểm tra là thừa hoặc lần dereference trước đó là sai.",
      "rc_ref_comparison": "RC: So sánh tham chiếu nghi ngờ. Phương thức này so sánh hai giá trị tham chiếu sử dụng toán tử == hoặc !=, trong khi cách chính xác để so sánh các thể hiện của loại này thường là sử dụng phương thức equals(). Có thể tạo ra các thể hiện khác nhau nhưng lại bằng nhau, nhưng không so sánh được bằng == vì chúng là các đối tượng khác nhau. Các ví dụ về lớp mà thường không nên so sánh bằng tham chiếu là java.lang.Integer, java.lang.Float, v.v. RC_REF_COMPARISON chỉ bao gồm các kiểu gói cho các kiểu nguyên thủy. Danh sách các kiểu nghi ngờ có thể được mở rộng bằng cách thêm thuộc tính hệ thống frc.suspicious với các lớp cách nhau dấu phẩy: java.time.LocalDate,java.util.List Xem CWE-595: So sánh các tham chiếu đối tượng thay vì nội dung đối tượng.",
      "va_primitive_array_passed_to_object_vararg": "VA: Mảng nguyên thủy được truyền vào hàm mong đợi một số lượng đối số đối tượng. Mã này truyền một mảng nguyên thủy vào một hàm nhận một số lượng đối số đối tượng. Điều này tạo ra một mảng có chiều dài một để chứa mảng nguyên thủy và truyền nó vào hàm.",
      "ec_unrelated_types_using_pointer_equality": "EC: Sử dụng sự so sánh con trỏ để so sánh các kiểu khác nhau. Phương thức này sử dụng sự so sánh con trỏ để so sánh hai tham chiếu có vẻ thuộc các kiểu khác nhau. Kết quả của sự so sánh này sẽ luôn là sai khi chạy mã. Xem CWE-570: Biểu thức luôn sai.",
      "ec_unrelated_types": "EC: Gọi equals() để so sánh các kiểu khác nhau. Phương thức này gọi equals(Object) trên hai tham chiếu của các lớp khác nhau và phân tích cho thấy chúng sẽ là các đối tượng của các lớp khác nhau khi chạy mã. Hơn nữa, kiểm tra các phương thức equals mà sẽ được gọi cho thấy hoặc là cuộc gọi này sẽ luôn trả về sai, hoặc phương thức equals không đối xứng (đây là tính chất yêu cầu trong hợp đồng của equals trong lớp Object). Xem CWE-570: Biểu thức luôn sai.",
      "ec_array_and_nonarray": "EC: equals() được sử dụng để so sánh mảng và không phải mảng. Phương thức này gọi .equals(Object o) để so sánh một mảng và một tham chiếu không có vẻ là mảng. Nếu các đối tượng được so sánh thuộc các kiểu khác nhau, chúng đảm bảo là không bằng nhau và sự so sánh này gần như chắc chắn là một lỗi. Ngay cả khi chúng đều là mảng, phương thức equals() trên mảng chỉ xác định xem hai mảng có phải là cùng một đối tượng không. Để so sánh nội dung của các mảng, sử dụng java.util.Arrays.equals(Object[], Object[]).",
      "ec_null_arg": "EC: Gọi equals(null). Phương thức này gọi equals(Object), truyền một giá trị null làm đối số. Theo hợp đồng của phương thức equals(), cuộc gọi này luôn trả về sai. Xem CWE-570: Biểu thức luôn sai.",
      "ec_unrelated_interfaces": "EC: Gọi equals() để so sánh các kiểu giao diện khác nhau. Phương thức này gọi equals(Object) trên hai tham chiếu của các kiểu giao diện không liên quan, trong đó không cái nào là kiểu con của cái còn lại, và không có lớp không trừu tượng nào biết được thực thi cả hai giao diện. Do đó, các đối tượng được so sánh không có khả năng là thành viên của cùng một lớp khi chạy mã (trừ khi một số lớp ứng dụng chưa được phân tích, hoặc việc tải lớp động có thể xảy ra khi chạy mã). Theo hợp đồng của equals(), các đối tượng của các lớp khác nhau luôn phải so sánh là không bằng nhau; do đó, theo hợp đồng được định nghĩa bởi java.lang.Object.equals(Object), kết quả của sự so sánh này luôn là sai khi chạy mã. Xem CWE-570: Biểu thức luôn sai.",
      "ec_unrelated_class_and_interface": "EC: Gọi equals() để so sánh lớp không liên quan và giao diện. Phương thức này gọi equals(Object) trên hai tham chiếu, một tham chiếu là lớp và tham chiếu còn lại là giao diện, trong đó không lớp nào và không có bất kỳ lớp con không trừu tượng nào của nó thực thi giao diện. Do đó, các đối tượng được so sánh không có khả năng là thành viên của cùng một lớp khi chạy mã (trừ khi một số lớp ứng dụng chưa được phân tích, hoặc việc tải lớp động có thể xảy ra khi chạy mã). Theo hợp đồng của equals(), các đối tượng của các lớp khác nhau luôn phải so sánh là không bằng nhau; do đó, theo hợp đồng được định nghĩa bởi java.lang.Object.equals(Object), kết quả của sự so sánh này luôn là sai khi chạy mã. Xem CWE-570: Biểu thức luôn sai.",
      "sa_local_self_assignment_instead_of_field": "SA: Gán giá trị cho chính nó của biến cục bộ thay vì gán cho trường. Phương thức này chứa một phép gán giá trị cho chính nó của một biến cục bộ, và có một trường có tên giống hệt, ví dụ: int foo; public void setFoo(int foo) { foo = foo; } Phép gán này là vô nghĩa. Bạn có phải muốn gán cho trường thay vì không?",
      "int_bad_comparison_with_int_value": "INT: So sánh sai giá trị int với hằng số long. Mã này so sánh một giá trị int với một hằng số long ngoài phạm vi giá trị có thể được biểu diễn dưới dạng giá trị int. Sự so sánh này là vô nghĩa và có thể không chính xác.",
      "int_bad_comparison_with_signed_byte": "INT: So sánh sai byte có dấu. Các byte có dấu chỉ có thể có giá trị trong khoảng từ -128 đến 127. So sánh một byte có dấu với một giá trị ngoài phạm vi đó là vô nghĩa và có khả năng sai. Để chuyển một byte có dấu b thành một giá trị không dấu trong phạm vi 0..255, sử dụng 0xff & b.",
      "int_bad_comparison_with_nonnegative_value": "INT: So sánh sai giá trị không âm với hằng số âm hoặc bằng không. Mã này so sánh một giá trị được đảm bảo là không âm với một hằng số âm hoặc bằng không.",
      "bit_add_of_signed_byte": "BIT: Thêm một giá trị byte và một giá trị được biết là có 8 bit thấp hơn được xóa. Các giá trị được tải từ một mảng byte được mở rộng dấu đến 32 bit trước khi bất kỳ hoạt động bitwise nào được thực hiện trên giá trị đó. Do đó, nếu b[0] chứa giá trị 0xff và x ban đầu là 0, thì mã ((x << 8) + b[0]) sẽ ký hiệu mở rộng 0xff để lấy 0xffffffff và do đó đưa ra giá trị 0xffffffff làm kết quả.\n\nĐặc biệt, mã sau đây để đóng gói một mảng byte vào một int là sai nghiêm trọng:\n\nint result = 0;\nfor (int i = 0; i < 4; i++)\n result = ((result << 8) + b[i]);\nThành ngữ sau đây sẽ hoạt động thay thế:\n\nint result = 0;\nfor (int i = 0; i < 4; i++)\n result = ((result << 8) + (b[i] & 0xff));",
      "bit_ior_of_signed_byte": "BIT: Bitwise OR của giá trị byte có dấu\nTải một giá trị byte (ví dụ: giá trị được tải từ một mảng byte hoặc được trả về bởi một phương thức có kiểu trả về byte) và thực hiện bitwise OR với giá trị đó. Giá trị byte được mở rộng dấu thành 32 bit trước khi bất kỳ hoạt động bitwise nào được thực hiện trên giá trị đó. Do đó, nếu b[0] chứa giá trị 0xff và x ban đầu là 0, thì mã ((x << 8) | b[0]) sẽ ký hiệu mở rộng 0xff để lấy 0xffffffff và do đó đưa ra giá trị 0xffffffff làm kết quả.\n\nĐặc biệt, mã sau đây để đóng gói một mảng byte vào một int là sai nghiêm trọng:\n\nint result = 0;\nfor (int i = 0; i < 4; i++) {\n result = ((result << 8) | b[i]);\n}\nThành ngữ sau đây sẽ hoạt động thay thế:\n\nint result = 0;\nfor (int i = 0; i < 4; i++) {\n result = ((result << 8) | (b[i] & 0xff));\n}",
      "bit_signed_check_high_bit": "BIT: Kiểm tra dấu của phép toán bitwise liên quan đến số âm\nPhương pháp này so sánh một biểu thức bitwise như ((val & CONSTANT) > 0) trong đó CONSTANT là số âm. Sử dụng phép tính số học bit rồi so sánh với toán tử lớn hơn có thể dẫn đến kết quả không mong muốn. Phép so sánh này khó có thể hoạt động như mong đợi. Thực hành tốt là sử dụng '!= 0' thay vì '> 0'.",
      "bit_and": "BIT: Mặt nạ bit không tương thích\nPhương pháp này so sánh biểu thức có dạng (e & C) với D, biểu thức này sẽ luôn so sánh không bằng nhau do các giá trị cụ thể của hằng số C và D. Điều này có thể chỉ ra lỗi logic hoặc lỗi đánh máy.",
      "bit_and_zz": "BIT: Kiểm tra xem ((…) & 0) == 0\nPhương pháp này so sánh biểu thức có dạng (e & 0) với 0, biểu thức này sẽ luôn so sánh bằng nhau. Điều này có thể chỉ ra lỗi logic hoặc lỗi đánh máy.",
      "bit_ior": "BIT: Mặt nạ bit không tương thích\nPhương pháp này so sánh một biểu thức có dạng (e | C) với D. Biểu thức này sẽ luôn so sánh không bằng nhau do các giá trị cụ thể của hằng số C và D. Điều này có thể chỉ ra lỗi logic hoặc lỗi đánh máy.\n\nThông thường, lỗi này xảy ra vì mã muốn thực hiện kiểm tra thành viên trong một tập bit, nhưng sử dụng toán tử bitwise OR ('|') thay vì bitwise AND ('&').\n\nLỗi như vậy cũng có thể xuất hiện trong các biểu thức như (e & A | B) == C được phân tích cú pháp như ((e & A) | B) == C trong khi (e & (A | B)) == C là cố ý.",
      "sa_field_self_assignment": "SA: Gán giá trị cho trường tự thân. Phương thức này chứa việc gán giá trị cho một trường tự thân; ví dụ: int x; public void foo() { x = x; } Các phép gán như vậy là vô ích và có thể chỉ ra lỗi logic hoặc lỗi chính tả.",
      "sa_field_self_computation": "SA: Tính toán vô nghĩa tự thân liên quan đến một trường (ví dụ, x & x). Phương thức này thực hiện một phép tính vô nghĩa của một trường với tham chiếu khác đến cùng một trường (ví dụ, x&x hoặc x-x). Do bản chất của phép tính, phép toán này có vẻ không hợp lý và có thể chỉ ra lỗi chính tả hoặc lỗi logic. Hãy kiểm tra lại phép tính.",
      "sa_local_self_computation": "SA: Tính toán vô nghĩa tự thân liên quan đến một biến (ví dụ, x & x). Phương thức này thực hiện một phép tính vô nghĩa của một biến cục bộ với tham chiếu khác đến cùng một biến (ví dụ, x&x hoặc x-x). Do bản chất của phép tính, phép toán này có vẻ không hợp lý và có thể chỉ ra lỗi chính tả hoặc lỗi logic. Hãy kiểm tra lại phép tính.",
      "sa_field_self_comparison": "SA: So sánh tự thân của trường với chính nó. Phương thức này so sánh một trường với chính nó và có thể chỉ ra lỗi chính tả hoặc lỗi logic. Hãy đảm bảo rằng bạn đang so sánh những thứ đúng.",
      "sa_local_self_comparison": "SA: So sánh tự thân của giá trị với chính nó. Phương thức này so sánh một biến cục bộ với chính nó và có thể chỉ ra lỗi chính tả hoặc lỗi logic. Hãy đảm bảo rằng bạn đang so sánh những thứ đúng.",
      "umac_uncallable_method_of_anonymous_class": "UMAC: Phương thức không thể gọi được định nghĩa trong lớp ẩn danh. Lớp ẩn danh này định nghĩa một phương thức mà không được gọi trực tiếp và không ghi đè phương thức trong lớp cha. Vì các phương thức trong các lớp khác không thể gọi trực tiếp các phương thức được khai báo trong một lớp ẩn danh, có vẻ như phương thức này không thể gọi được. Phương thức có thể chỉ là mã chết, nhưng cũng có thể phương thức này được dự định ghi đè một phương thức được khai báo trong lớp cha, và do lỗi chính tả hoặc lỗi khác mà phương thức không ghi đè phương thức mà nó định ghi đè.",
      "iju_assert_method_invoked_from_run_method": "IJU: Kiểm tra JUnit trong phương thức run sẽ không được JUnit chú ý. Một kiểm tra JUnit được thực hiện trong phương thức run. Các kiểm tra JUnit thất bại chỉ dẫn đến ngoại lệ bị ném ra. Do đó, nếu ngoại lệ này xảy ra trong một luồng khác ngoài luồng gọi phương thức kiểm tra, ngoại lệ sẽ kết thúc luồng đó nhưng không dẫn đến việc kiểm tra thất bại.",
      "iju_bad_suite_method": "IJU: TestCase khai báo một phương thức suite sai. Lớp là một JUnit TestCase và định nghĩa một phương thức suite(). Tuy nhiên, phương thức suite cần phải được khai báo là một trong hai: public static junit.framework.Test suite() hoặc public static junit.framework.TestSuite suite()",
      "iju_setup_no_super": "IJU: TestCase định nghĩa setUp mà không gọi super.setUp(). Lớp là một JUnit TestCase và thực hiện phương thức setUp. Phương thức setUp nên gọi super.setUp(), nhưng không làm vậy.",
      "iju_teardown_no_super": "IJU: TestCase định nghĩa tearDown mà không gọi super.tearDown(). Lớp là một JUnit TestCase và thực hiện phương thức tearDown. Phương thức tearDown nên gọi super.tearDown(), nhưng không làm vậy.",
      "iju_suite_not_static": "IJU: TestCase triển khai phương thức suite không tĩnh. Lớp là một JUnit TestCase và triển khai phương thức suite(). Phương thức suite nên được khai báo là tĩnh, nhưng không phải.",
      "iju_no_tests": "IJU: TestCase không có kiểm tra nào. Lớp là một JUnit TestCase nhưng không triển khai bất kỳ phương thức kiểm tra nào.",
      "boa_badly_overridden_adapter": "BOA: Lớp ghi đè một phương thức đã triển khai trong lớp cha Adapter sai. Phương thức này ghi đè một phương thức tìm thấy trong lớp cha, nơi lớp cha là một Adapter triển khai một listener được định nghĩa trong gói java.awt.event hoặc javax.swing.event. Kết quả là, phương thức này sẽ không được gọi khi sự kiện xảy ra.",
      "sql_bad_resultset_access": "SQL: Phương thức cố gắng truy cập trường trong kết quả với chỉ số 0. Một cuộc gọi tới các phương thức getXXX hoặc updateXXX của kết quả đã được thực hiện, trong đó chỉ số trường là 0. Vì các trường trong ResultSet bắt đầu từ chỉ số 1, đây luôn là một lỗi.",
      "sql_bad_prepared_statement_access": "SQL: Phương thức cố gắng truy cập tham số của câu lệnh chuẩn với chỉ số 0. Một cuộc gọi tới phương thức setXXX của câu lệnh chuẩn đã được thực hiện, trong đó chỉ số tham số là 0. Vì các chỉ số tham số bắt đầu từ chỉ số 1, đây luôn là một lỗi.",
      "sio_superfluous_instanceof": "SIO: Kiểm tra kiểu không cần thiết sử dụng toán tử instanceof. Kiểm tra kiểu được thực hiện bằng toán tử instanceof, trong khi có thể xác định tĩnh xem đối tượng có phải kiểu yêu cầu hay không.",
      "bac_bad_applet_constructor": "BAC: Constructor Applet sai dựa vào AppletStub chưa khởi tạo. Constructor này gọi các phương thức trong Applet cha phụ thuộc vào AppletStub. Vì AppletStub không được khởi tạo cho đến khi phương thức init() của applet này được gọi, nên các phương thức này sẽ không thực hiện đúng.",
      "ec_incompatible_array_compare": "EC: equals(...) được sử dụng để so sánh các mảng không tương thích. Phương thức này gọi .equals(Object o) để so sánh hai mảng, nhưng các mảng có kiểu không tương thích (ví dụ, String[] và StringBuffer[], hoặc String[] và int[]). Chúng sẽ không bao giờ bằng nhau. Hơn nữa, khi sử dụng equals(...) để so sánh các mảng, nó chỉ kiểm tra xem chúng có phải là cùng một mảng hay không, và bỏ qua nội dung của các mảng.",
      "ec_bad_array_compare": "EC: Gọi equals() trên một mảng, điều này tương đương với ==. Phương thức này gọi phương thức .equals(Object o) trên một mảng. Vì các mảng không ghi đè phương thức equals của Object, việc gọi equals trên mảng tương đương với việc so sánh địa chỉ của chúng. Để so sánh nội dung của các mảng, sử dụng java.util.Arrays.equals(Object[], Object[]). Để so sánh địa chỉ của các mảng, sẽ ít gây nhầm lẫn hơn nếu bạn kiểm tra rõ ràng sự bằng nhau của các con trỏ bằng cách sử dụng ==.",
      "sti_interrupted_on_currentthread": "STI: Sử dụng không cần thiết của phương thức currentThread() để gọi interrupted(). Phương thức này gọi phương thức Thread.currentThread(), chỉ để gọi phương thức interrupted(). Vì interrupted() là phương thức tĩnh, sẽ đơn giản và rõ ràng hơn khi sử dụng Thread.interrupted().",
      "sti_interrupted_on_unknownthread": "STI: Phương thức tĩnh Thread.interrupted() được gọi trên đối tượng luồng. Phương thức này gọi phương thức Thread.interrupted() trên một đối tượng Thread dường như không phải là luồng hiện tại. Vì phương thức interrupted() là tĩnh, phương thức interrupted sẽ được gọi trên một đối tượng khác với đối tượng mà tác giả định gọi.",
      "dls_dead_local_increment_in_return": "DLS: Tăng không cần thiết trong câu lệnh return. Câu lệnh này có một return như return x++; / return x--; Một phép tăng/giảm hậu tố không ảnh hưởng đến giá trị của biểu thức, vì vậy phép tăng/giảm này không có tác dụng. Hãy xác minh rằng câu lệnh này thực hiện đúng chức năng.",
      "dls_dead_store_of_class_literal": "DLS: Lưu trữ chết của lớp literal. Câu lệnh này gán một literal lớp cho một biến và sau đó không bao giờ sử dụng nó. Hành vi này khác nhau giữa Java 1.4 và Java 5. Trong Java 1.4 và các phiên bản trước, tham chiếu đến Foo.class sẽ buộc bộ khởi tạo tĩnh cho Foo được thực thi, nếu nó chưa được thực thi. Trong Java 5 và các phiên bản sau, điều này không xảy ra.",
      "ip_parameter_is_dead_but_overwritten": "IP: Tham số bị chết khi vào phương thức nhưng bị ghi đè. Giá trị ban đầu của tham số này bị bỏ qua, và tham số bị ghi đè tại đây. Điều này thường chỉ ra sự hiểu lầm rằng việc ghi vào tham số sẽ được truyền ngược lại cho caller.",
      "mf_method_masks_field": "MF: Phương thức định nghĩa một biến che khuất một trường. Phương thức này định nghĩa một biến cục bộ với cùng tên với một trường trong lớp này hoặc lớp cha. Điều này có thể khiến phương thức đọc một giá trị chưa được khởi tạo từ trường, để trường không được khởi tạo, hoặc cả hai.",
      "mf_class_masks_field": "MF: Lớp định nghĩa trường che khuất trường trong lớp cha. Lớp này định nghĩa một trường với cùng tên với một trường thể hiện có thể truy cập trong lớp cha. Điều này gây nhầm lẫn và có thể chỉ ra một lỗi nếu các phương thức cập nhật hoặc truy cập một trong các trường khi chúng muốn truy cập trường khác.",
      "fe_test_if_equal_to_not_a_number": "FE: Kiểm tra sự bằng nhau với NaN là vô ích. Mã này kiểm tra xem một giá trị điểm động có bằng với giá trị Not A Number đặc biệt (ví dụ, nếu (x == Double.NaN)) hay không. Tuy nhiên, do đặc thù của NaN, không có giá trị nào bằng NaN, kể cả NaN. Do đó, x == Double.NaN luôn trả về false. Để kiểm tra xem một giá trị trong x có phải là giá trị Not A Number đặc biệt hay không, sử dụng Double.isNaN(x) (hoặc Float.isNaN(x) nếu x là số thực).",
      "icast_int_2_long_as_instant": "ICAST: Giá trị int chuyển sang long và được sử dụng làm thời gian tuyệt đối. Mã này chuyển đổi một giá trị int 32-bit thành giá trị long 64-bit, và sau đó truyền giá trị đó vào một tham số phương thức yêu cầu một giá trị thời gian tuyệt đối. Một giá trị thời gian tuyệt đối là số mili giây kể từ thời điểm chuẩn được biết đến là 'thời đại', tức là 00:00:00 GMT ngày 1 tháng 1 năm 1970. Ví dụ, phương thức sau đây, được thiết kế để chuyển đổi giây từ thời đại thành Date, bị lỗi nghiêm trọng:",
      "icast_int_cast_to_double_passed_to_ceil": "ICAST: Giá trị số nguyên được ép kiểu thành double và sau đó truyền vào Math.ceil. Mã này chuyển đổi một giá trị số nguyên (ví dụ: int hoặc long) thành một số dấu chấm động độ chính xác kép và sau đó truyền kết quả vào hàm Math.ceil(), hàm này làm tròn số dấu chấm động lên giá trị nguyên cao hơn tiếp theo. Hoạt động này luôn nên là một phép toán không có tác dụng, vì việc chuyển đổi số nguyên thành số double sẽ cho một số không có phần thập phân. Có thể phép toán đã tạo ra giá trị được truyền vào Math.ceil dự định được thực hiện bằng toán học dấu chấm động.",
      "icast_int_cast_to_float_passed_to_round": "ICAST: Giá trị int chuyển sang float và sau đó truyền vào Math.round. Mã này chuyển một giá trị int thành một số dấu chấm động với độ chính xác float và sau đó truyền kết quả vào hàm Math.round(), hàm này trả về int/long gần nhất với đối số. Hoạt động này luôn nên là một phép toán không có tác dụng, vì việc chuyển một số nguyên thành float sẽ cho một số không có phần thập phân. Có thể phép toán đã tạo ra giá trị được truyền vào Math.round dự định được thực hiện bằng toán học dấu chấm động.",
      "np_null_instanceof": "NP: Kiểm tra một giá trị null đã biết xem nó có phải là thể hiện của một loại nào đó không. Kiểm tra instanceof này sẽ luôn trả về false, vì giá trị được kiểm tra chắc chắn là null. Mặc dù điều này là an toàn, hãy chắc chắn rằng nó không phải là dấu hiệu của sự hiểu lầm hoặc một lỗi logic khác.",
      "dmi_long_bits_to_double_invoked_on_int": "DMI: Double.longBitsToDouble được gọi với một int. Phương thức Double.longBitsToDouble được gọi, nhưng một giá trị int 32-bit được truyền vào như một đối số. Điều này gần như chắc chắn không phải là mục đích và không thể đưa ra kết quả như mong muốn.",
      "bc_impossible_cast": "BC: Ép kiểu không thể thực hiện. Phép ép kiểu này sẽ luôn ném ra một ClassCastException. SpotBugs theo dõi thông tin kiểu từ các kiểm tra instanceof, và cũng sử dụng thông tin chính xác hơn về kiểu của các giá trị trả về từ các phương thức và được tải từ các trường. Do đó, nó có thể có thông tin chính xác hơn chỉ về kiểu khai báo của một biến và có thể sử dụng thông tin này để xác định rằng phép ép kiểu sẽ luôn ném ra một ngoại lệ khi chạy.",
      "bc_impossible_downcast": "BC: Ép kiểu xuống không thể thực hiện. Phép ép kiểu này sẽ luôn ném ra một ClassCastException. Phân tích tin rằng nó biết chính xác kiểu của giá trị đang được ép kiểu, và việc cố gắng ép kiểu xuống một kiểu con sẽ luôn thất bại với việc ném ra một ClassCastException.",
      "bc_impossible_downcast_of_toarray": "BC: Ép kiểu xuống không thể thực hiện đối với kết quả của toArray(). Mã này ép kiểu kết quả của việc gọi toArray() trên một collection thành một kiểu cụ thể hơn so với Object[], như sau: String[] getAsArray(Collection c) { return (String[]) c.toArray(); } Điều này thường sẽ thất bại và ném ra một ClassCastException. Phương thức toArray() của hầu hết các collection trả về Object[]. Chúng không thể thực hiện gì khác, vì đối tượng Collection không có tham chiếu đến kiểu tổng quát được khai báo của collection đó. Cách đúng để có được một mảng của một kiểu cụ thể từ một collection là sử dụng c.toArray(new String[0]); hoặc c.toArray(new String[c.size()]); (cái đầu tiên hiệu quả hơn một chút kể từ các cập nhật Java 6 muộn).",
      "bc_impossible_instanceof": "BC: instanceof sẽ luôn trả về false. Kiểm tra instanceof này sẽ luôn trả về false. Mặc dù điều này là an toàn, hãy chắc chắn rằng nó không phải là dấu hiệu của sự hiểu lầm hoặc một lỗi logic khác.",
      "re_possible_unintended_pattern": "RE: Dùng “.” hoặc “",
      "re_bad_syntax_for_regular_expression": "RE: Cú pháp không hợp lệ cho biểu thức chính quy. Mã này sử dụng một biểu thức chính quy không hợp lệ theo cú pháp cho biểu thức chính quy. Lệnh này sẽ ném ra một PatternSyntaxException khi thực thi. Xem CWE-185: Biểu thức chính quy không chính xác.",
      "re_cant_use_file_separator_as_regular_expression": "RE: Sử dụng File.separator cho biểu thức chính quy. Mã này sử dụng File.separator trong khi yêu cầu một biểu thức chính quy. Điều này sẽ thất bại trên các nền tảng Windows, nơi File.separator là dấu gạch chéo ngược, điều này được diễn giải trong biểu thức chính quy như một ký tự thoát. Trong số các lựa chọn khác, bạn có thể chỉ cần sử dụng File.separatorChar=='\\' ? '\\' : File.separator thay vì File.separator. Xem CWE-185: Biểu thức chính quy không chính xác.",
      "dls_overwritten_increment": "DLS: Gia tăng bị ghi đè. Mã này thực hiện một phép gia tăng/giảm (ví dụ, i++ / i--) và sau đó ngay lập tức ghi đè nó. Ví dụ, i = i++ / i = i-- ngay lập tức ghi đè giá trị đã gia tăng/giảm bằng giá trị ban đầu. Xem CWE-563: Gán giá trị cho biến mà không sử dụng.",
      "icast_bad_shift_amount": "BSHIFT: Dịch trái 32 bit int với một giá trị không nằm trong khoảng -31..31. Mã này thực hiện dịch một giá trị int 32 bit với một giá trị hằng số ngoài phạm vi -31..31. Hệ quả của việc này là sử dụng 5 bit thấp nhất của giá trị nguyên để quyết định mức độ dịch (ví dụ, dịch 40 bit tương đương với dịch 8 bit, và dịch 32 bit tương đương với dịch 0 bit). Điều này có thể không phải là điều bạn mong muốn, và ít nhất là gây nhầm lẫn.",
      "bshift_wrong_add_priority": "BSHIFT: Phân tích sai có thể xảy ra trong phép toán dịch. Mã này thực hiện một phép toán như (x << 8 + y). Mặc dù có thể đúng, có lẽ nó được thiết kế để thực hiện (x << 8) + y, nhưng phép toán dịch có độ ưu tiên thấp hơn, vì vậy nó thực sự được phân tích là x << (8 + y).",
      "im_multiplying_result_of_irem": "IM: Nhân số nguyên của kết quả phép toán chia dư số nguyên. Mã này nhân kết quả của phép toán chia dư số nguyên với một hằng số số nguyên. Hãy chắc chắn rằng bạn không nhầm lẫn độ ưu tiên của các phép toán. Ví dụ, i % 60 * 1000 là (i % 60) * 1000, chứ không phải i % (60 * 1000).",
      "dmi_invoking_hashcode_on_array": "DMI: Gọi hashCode trên một mảng. Mã này gọi phương thức hashCode trên một mảng. Gọi hashCode trên một mảng trả về giá trị giống như System.identityHashCode, và bỏ qua nội dung và độ dài của mảng. Nếu bạn cần một hashCode phụ thuộc vào nội dung của mảng a, hãy sử dụng java.util.Arrays.hashCode(a).",
      "dmi_invoking_tostring_on_array": "USELESS_STRING: Gọi toString trên một mảng. Mã này gọi toString trên một mảng, điều này sẽ tạo ra một kết quả khá vô ích như [C@16f0472. Hãy xem xét sử dụng Arrays.toString để chuyển mảng thành một String có thể đọc được, thể hiện nội dung của mảng. Xem Programming Puzzlers, chương 3, câu đố 12.",
      "dmi_invoking_tostring_on_anonymous_array": "USELESS_STRING: Gọi toString trên một mảng vô danh. Mã này gọi toString trên một mảng (vô danh). Gọi toString trên một mảng sẽ tạo ra một kết quả khá vô ích như [C@16f0472. Hãy xem xét sử dụng Arrays.toString để chuyển mảng thành một String có thể đọc được, thể hiện nội dung của mảng. Xem Programming Puzzlers, chương 3, câu đố 12.",
      "dmi_bad_month": "DMI: Giá trị hằng số không hợp lệ cho tháng. Mã này truyền một giá trị tháng hằng số ngoài phạm vi mong đợi từ 0..11 vào một phương thức.",
      "dmi_calling_next_from_hasnext": "DMI: Phương thức hasNext gọi phương thức next. Phương thức hasNext() gọi phương thức next(). Đây gần như chắc chắn là sai, vì phương thức hasNext() không được phép thay đổi trạng thái của iterator, trong khi phương thức next lại phải thay đổi trạng thái của iterator.",
      "qba_questionable_boolean_assignment": "QBA: Phương thức gán giá trị boolean literal trong biểu thức boolean. Phương thức này gán một giá trị boolean literal (true hoặc false) cho một biến boolean trong biểu thức if hoặc while. Có thể đây là một phép so sánh boolean sử dụng == thay vì một phép gán sử dụng =. Xem CWE-481: Gán thay vì So sánh.",
      "gc_unrelated_types": "GC: Không có mối quan hệ giữa tham số generic và đối số phương thức. Lệnh gọi phương thức tập hợp generic này chứa một đối số với lớp không tương thích với tham số của tập hợp (tức là kiểu của đối số không phải là supertype hay subtype của tham số generic tương ứng). Do đó, không có khả năng tập hợp này chứa bất kỳ đối tượng nào bằng với đối số phương thức được sử dụng ở đây. Hầu hết có thể giá trị sai đang được truyền vào phương thức. Trong trường hợp chung, các thể hiện của hai lớp không liên quan không bằng nhau. Ví dụ, nếu các lớp Foo và Bar không có quan hệ kế thừa, thì một thể hiện của Foo không nên bằng một thể hiện của Bar. Trong số các vấn đề khác, làm như vậy có thể dẫn đến phương thức equals không đối xứng. Ví dụ, nếu bạn định nghĩa lớp Foo sao cho một Foo có thể bằng một String, phương thức equals của bạn sẽ không đối xứng vì một String chỉ có thể bằng một String. Trong những trường hợp hiếm hoi, mọi người có thể định nghĩa phương thức equals không đối xứng và vẫn làm cho mã của họ hoạt động. Mặc dù không có API nào ghi lại hoặc đảm bảo điều này, nhưng thông thường nếu bạn kiểm tra xem một Collection có chứa Foo hay không, phương thức equals của đối số (ví dụ, phương thức equals của lớp Foo) sẽ được sử dụng để kiểm tra sự bằng nhau.",
      "dmi_vacuous_self_collection_call": "DMI: Gọi collections vô nghĩa. Lệnh gọi này không có ý nghĩa. Đối với bất kỳ tập hợp c nào, gọi c.containsAll(c) luôn phải trả về true, và c.retainAll(c) không có tác dụng.",
      "dmi_doh": "DMI: Gọi phương thức vô nghĩa. Lệnh gọi phương thức này không có ý nghĩa, vì lý do sẽ rõ ràng khi xem xét.",
      "dmi_collections_should_not_contain_themselves": "DMI: Các collections không nên chứa chính chúng. Lệnh gọi phương thức của một tập hợp generic chỉ có ý nghĩa nếu một tập hợp chứa chính nó (ví dụ, nếu s.contains(s) là true). Điều này khó có thể đúng và sẽ gây ra vấn đề nếu nó đúng (như tính toán mã băm dẫn đến đệ quy vô hạn). Có khả năng giá trị sai đang được truyền vào làm tham số.",
      "tq_unknown_value_used_where_always_strictly_required": "TQ: Giá trị không có qualifier kiểu được sử dụng ở nơi cần có qualifier đó. Một giá trị đang được sử dụng theo cách yêu cầu giá trị phải có qualifier kiểu. Qualifier kiểu là nghiêm ngặt, vì vậy công cụ từ chối bất kỳ giá trị nào không có chú thích thích hợp. Để ép một giá trị có chú thích nghiêm ngặt, định nghĩa một hàm identity nơi giá trị trả về được chú thích với qualifier nghiêm ngặt. Đây là cách duy nhất để biến một giá trị không có chú thích thành giá trị có chú thích qualifier kiểu nghiêm ngặt.",
      "tq_comparing_values_with_incompatible_type_qualifiers": "TQ: So sánh giá trị với qualifier kiểu không tương thích. Một giá trị được xác định là mang chú thích qualifier kiểu được so sánh với một giá trị không bao giờ mang qualifier đó. Cụ thể hơn, một giá trị được chú thích với qualifier kiểu chỉ định when=ALWAYS được so sánh với một giá trị mà qualifier kiểu tương ứng chỉ định when=NEVER. Ví dụ, giả sử @NonNegative là biệt danh cho chú thích qualifier kiểu @Negative(when=When.NEVER). Mã sau đây sẽ tạo ra cảnh báo này vì câu lệnh return yêu cầu một giá trị @NonNegative, nhưng nhận được một giá trị được đánh dấu là @Negative. public boolean example(@Negative Integer value1, @NonNegative Integer value2) { return value1.equals(value2); }",
      "tq_always_value_used_where_never_required": "TQ: Giá trị được chú thích là mang qualifier kiểu được sử dụng ở nơi yêu cầu giá trị không mang qualifier đó. Một giá trị được xác định là mang chú thích qualifier kiểu được tiêu thụ tại một vị trí hoặc các vị trí yêu cầu giá trị không mang chú thích đó. Cụ thể hơn, một giá trị được chú thích với qualifier kiểu chỉ định when=ALWAYS đảm bảo sẽ đến một vị trí hoặc các vị trí mà qualifier kiểu tương ứng chỉ định when=NEVER. Ví dụ, giả sử @NonNegative là biệt danh cho chú thích qualifier kiểu @Negative(when=When.NEVER). Mã sau đây sẽ tạo ra cảnh báo này vì câu lệnh return yêu cầu một giá trị @NonNegative, nhưng nhận được một giá trị được đánh dấu là @Negative. public @NonNegative Integer example(@Negative Integer value) { return value; }",
      "tq_never_value_used_where_always_required": "TQ: Giá trị được chú thích là không bao giờ mang qualifier kiểu được sử dụng ở nơi yêu cầu giá trị mang qualifier đó. Một giá trị được xác định là không mang chú thích qualifier kiểu sẽ đảm bảo bị tiêu thụ ở một vị trí hoặc các vị trí yêu cầu giá trị mang chú thích đó. Cụ thể hơn, một giá trị được chú thích với qualifier kiểu chỉ định when=NEVER đảm bảo sẽ đến một vị trí hoặc các vị trí mà qualifier kiểu tương ứng chỉ định when=ALWAYS. TODO: example",
      "tq_maybe_source_value_reaches_always_sink": "TQ: Giá trị có thể không mang qualifier kiểu luôn được sử dụng theo cách yêu cầu qualifier đó. Một giá trị được chú thích là có thể không phải là thể hiện của các giá trị được chỉ định bởi qualifier kiểu, và giá trị này được đảm bảo sẽ được sử dụng theo cách yêu cầu các giá trị được chỉ định bởi qualifier đó.",
      "tq_maybe_source_value_reaches_never_sink": "TQ: Giá trị có thể mang qualifier kiểu luôn được sử dụng theo cách cấm nó mang qualifier đó. Một giá trị được chú thích là có thể là thể hiện của các giá trị được chỉ định bởi qualifier kiểu, và giá trị này được đảm bảo sẽ được sử dụng theo cách cấm các giá trị được chỉ định bởi qualifier đó.",
      "fb_unexpected_warning": "FB: Cảnh báo bất ngờ/không mong muốn từ SpotBugs. SpotBugs tạo ra một cảnh báo mà, theo chú thích @NoWarning, là bất ngờ hoặc không mong muốn.",
      "fb_missing_expected_warning": "FB: Thiếu cảnh báo mong đợi hoặc mong muốn từ SpotBugs. SpotBugs không tạo ra một cảnh báo mà, theo chú thích @ExpectedWarning, là mong đợi hoặc mong muốn.",
      "eos_bad_end_of_stream_check": "EOS: Dữ liệu đọc được chuyển đổi trước khi so sánh với -1. Phương thức java.io.FileInputStream.read() trả về một int. Nếu int này được chuyển đổi thành byte, thì -1 (chỉ báo EOF) và byte 0xFF trở nên không thể phân biệt, việc so sánh kết quả (đã chuyển đổi) với -1 sẽ khiến việc đọc (có thể trong một vòng lặp) kết thúc sớm nếu gặp ký tự 0xFF. Tương tự, phương thức java.io.FileReader.read() cũng trả về một int. Nếu nó được chuyển đổi thành char, thì -1 trở thành 0xFFFF, tức là Character.MAX_VALUE. Việc so sánh kết quả với -1 là vô nghĩa, vì ký tự là không dấu trong Java. Nếu kiểm tra EOF là điều kiện của một vòng lặp, thì vòng lặp này sẽ là vô hạn. Xem quy tắc SEI CERT FIO08-J. Phân biệt giữa các ký tự hoặc byte đọc từ luồng và -1.",
      "fl_floats_as_loop_counters": "FL: Không sử dụng biến số thực làm bộ đếm vòng lặp. Việc sử dụng biến số thực làm bộ đếm vòng lặp không nên, vì chúng không chính xác, có thể dẫn đến vòng lặp không đúng. Bộ đếm vòng lặp là một biến thay đổi sau mỗi lần lặp và kiểm soát khi nào vòng lặp nên kết thúc. Nó được giảm hoặc tăng một giá trị cố định sau mỗi lần lặp. Xem quy tắc NUM09-J và CWE-1339: Độ chính xác hoặc độ chính xác không đủ của một số thực.",
      "sing_singleton_implements_cloneable": "SING: Lớp sử dụng mẫu thiết kế singleton trực tiếp triển khai giao diện Cloneable. Nếu một lớp sử dụng mẫu thiết kế singleton trực tiếp triển khai giao diện Cloneable, có thể tạo ra một bản sao của đối tượng, do đó vi phạm mẫu singleton. Do đó, nên tránh việc triển khai giao diện Cloneable. Để biết thêm thông tin, xem: SEI CERT MSC07-J, và CWE-543: Sử dụng mẫu Singleton mà không có đồng bộ hóa trong bối cảnh đa luồng.",
      "sing_singleton_indirectly_implements_cloneable": "SING: Lớp sử dụng mẫu thiết kế singleton gián tiếp triển khai giao diện Cloneable. Nếu một lớp sử dụng mẫu thiết kế singleton gián tiếp triển khai giao diện Cloneable, có thể tạo ra một bản sao của đối tượng, do đó vi phạm mẫu singleton. Do đó, nên tránh việc triển khai giao diện Cloneable. Nếu không thể tránh được vì lớp cha mở rộng, giải pháp sẽ là ghi đè phương thức clone để ném CloneNotSupportedException một cách vô điều kiện. Để biết thêm thông tin, xem: SEI CERT MSC07-J, và CWE-543: Sử dụng mẫu Singleton mà không có đồng bộ hóa trong bối cảnh đa luồng.",
      "sing_singleton_implements_clone_method": "SING: Lớp sử dụng mẫu thiết kế singleton triển khai phương thức clone() mà không ném CloneNotSupportedException một cách vô điều kiện. Lớp này sử dụng mẫu thiết kế singleton và không triển khai giao diện Cloneable, nhưng triển khai phương thức clone() mà không ném CloneNotSupportedException một cách vô điều kiện. Điều này sẽ cho phép tạo ra một bản sao của đối tượng, vi phạm mẫu singleton. Do đó, nên tránh triển khai phương thức clone, nếu không giải pháp sẽ là ghi đè phương thức clone để ném CloneNotSupportedException một cách vô điều kiện. Để biết thêm thông tin, xem: SEI CERT MSC07-J, và CWE-543: Sử dụng mẫu Singleton mà không có đồng bộ hóa trong bối cảnh đa luồng.",
      "sing_singleton_has_nonprivate_constructor": "SING: Lớp sử dụng mẫu thiết kế singleton có constructor không phải là private. Lớp này sử dụng mẫu thiết kế singleton và có constructor không phải là private (lưu ý rằng có thể có một constructor mặc định không phải là private). Với điều này, có thể tạo ra một bản sao của đối tượng, vi phạm mẫu singleton. Giải pháp dễ dàng hơn là làm cho constructor trở thành private. Để biết thêm thông tin, xem: SEI CERT MSC07-J, và CWE-543: Sử dụng mẫu Singleton mà không có đồng bộ hóa trong bối cảnh đa luồng.",
      "sing_singleton_implements_serializable": "SING: Lớp sử dụng mẫu thiết kế singleton trực tiếp hoặc gián tiếp triển khai giao diện Serializable. Lớp này (sử dụng mẫu thiết kế singleton) trực tiếp hoặc gián tiếp triển khai giao diện Serializable, cho phép lớp này có thể được tuần tự hóa. Việc giải tuần tự hóa làm cho việc khởi tạo nhiều đối tượng của một lớp singleton trở nên khả thi, do đó nên tránh điều này. Để biết thêm thông tin, xem: SEI CERT MSC07-J, và CWE-543: Sử dụng mẫu Singleton mà không có đồng bộ hóa trong bối cảnh đa luồng.",
      "sing_singleton_getter_not_synchronized": "SING: Phương thức getter của instance trong lớp sử dụng mẫu thiết kế singleton không được đồng bộ hóa. Phương thức getter của instance trong lớp sử dụng mẫu thiết kế singleton không được đồng bộ hóa. Khi phương thức này được gọi đồng thời bởi hai hoặc nhiều luồng, việc khởi tạo nhiều đối tượng của lớp singleton trở nên khả thi. Để biết thêm thông tin, xem: SEI CERT MSC07-J, và CWE-543: Sử dụng mẫu Singleton mà không có đồng bộ hóa trong bối cảnh đa luồng.",
      "hsm_hiding_method": "HSM: Nên tránh việc che giấu phương thức. Việc che giấu xảy ra khi một lớp con định nghĩa một phương thức tĩnh với cùng tiêu đề (chữ ký cộng với kiểu trả về) như trong bất kỳ lớp cha nào. Trong trường hợp che giấu phương thức, phương thức được gọi được xác định dựa trên tên đầy đủ hoặc biểu thức gọi phương thức được sử dụng tại điểm gọi. Kết quả thường không như mong đợi, mặc dù ngôn ngữ Java cung cấp các quy tắc rõ ràng cho việc gọi phương thức trong trường hợp che giấu phương thức. Hơn nữa, việc che giấu phương thức và ghi đè phương thức thường bị nhầm lẫn bởi lập trình viên. Do đó, lập trình viên nên tránh việc che giấu phương thức. Lập trình viên nên khai báo phương thức tương ứng là không tĩnh hoặc hạn chế nó là private để loại bỏ vấn đề. Xem quy tắc SEI CERT MET07-J. Không bao giờ khai báo phương thức lớp che giấu phương thức được khai báo trong lớp cha hoặc siêu giao diện.",
      "skipped_class_too_big": "SKIPPED: Lớp quá lớn để phân tích. Lớp này lớn hơn mức có thể xử lý hiệu quả và không được phân tích đầy đủ để phát hiện lỗi.",
      "unknown": "TEST: Mẫu lỗi không xác định. Một cảnh báo đã được ghi lại, nhưng SpotBugs không thể tìm thấy mô tả của mẫu lỗi này và do đó không thể mô tả nó. Điều này chỉ nên xảy ra trong trường hợp có lỗi trong SpotBugs hoặc cấu hình của nó, hoặc có thể nếu một phân tích được tạo ra bằng cách sử dụng một plugin, nhưng plugin đó hiện không được tải.",
      "testing": "TEST: Đang kiểm tra. Mẫu lỗi này chỉ được tạo ra bởi các bộ phát hiện lỗi mới, chưa được triển khai đầy đủ.",
      "testing1": "TEST: Đang kiểm tra 1. Mẫu lỗi này chỉ được tạo ra bởi các bộ phát hiện lỗi mới, chưa được triển khai đầy đủ.",
      "testing2": "TEST: Đang kiểm tra 2. Mẫu lỗi này chỉ được tạo ra bởi các bộ phát hiện lỗi mới, chưa được triển khai đầy đủ.",
      "testing3": "TEST: Đang kiểm tra 3. Mẫu lỗi này chỉ được tạo ra bởi các bộ phát hiện lỗi mới, chưa được triển khai đầy đủ.",
      "obl_unsatisfied_obligation": "OBL: Phương thức có thể không dọn dẹp stream hoặc tài nguyên. Phương thức này có thể không dọn dẹp (đóng, giải phóng) một stream, đối tượng cơ sở dữ liệu hoặc tài nguyên khác yêu cầu một thao tác dọn dẹp rõ ràng. Nói chung, nếu một phương thức mở một stream hoặc tài nguyên khác, phương thức nên sử dụng khối try/finally để đảm bảo rằng stream hoặc tài nguyên được dọn dẹp trước khi phương thức trả về. Mẫu lỗi này về cơ bản giống như các mẫu lỗi OS_OPEN_STREAM và ODR_OPEN_DATABASE_RESOURCE, nhưng dựa trên một kỹ thuật phân tích tĩnh khác (và hy vọng là tốt hơn). Chúng tôi quan tâm đến phản hồi về tính hữu ích của mẫu lỗi này. Để gửi phản hồi, vui lòng tham khảo: hướng dẫn đóng góp, danh sách gửi thư. Đặc biệt, các phép toán giảm thiểu false-positive cho mẫu lỗi này chưa được điều chỉnh kỹ lưỡng, vì vậy các báo cáo về false positive sẽ giúp chúng tôi. Xem Weimer và Necula, Finding and Preventing Run-Time Error Handling Mistakes (PDF), để biết mô tả về kỹ thuật phân tích.",
      "obl_unsatisfied_obligation_exception_edge": "OBL: Phương thức có thể không dọn dẹp stream hoặc tài nguyên trong trường hợp ngoại lệ đã kiểm tra. Phương thức này có thể không dọn dẹp (đóng, giải phóng) một stream, đối tượng cơ sở dữ liệu hoặc tài nguyên khác yêu cầu một thao tác dọn dẹp rõ ràng. Nói chung, nếu một phương thức mở một stream hoặc tài nguyên khác, phương thức nên sử dụng khối try/finally để đảm bảo rằng stream hoặc tài nguyên được dọn dẹp trước khi phương thức trả về. Mẫu lỗi này về cơ bản giống như các mẫu lỗi OS_OPEN_STREAM và ODR_OPEN_DATABASE_RESOURCE, nhưng dựa trên một kỹ thuật phân tích tĩnh khác (và hy vọng là tốt hơn). Chúng tôi quan tâm đến phản hồi về tính hữu ích của mẫu lỗi này. Để gửi phản hồi, vui lòng tham khảo: hướng dẫn đóng góp, danh sách gửi thư. Đặc biệt, các phép toán giảm thiểu false-positive cho mẫu lỗi này chưa được điều chỉnh kỹ lưỡng, vì vậy các báo cáo về false positive sẽ giúp chúng tôi. Xem Weimer và Necula, Finding and Preventing Run-Time Error Handling Mistakes (PDF), để biết mô tả về kỹ thuật phân tích.",
      "lg_lost_logger_due_to_weak_reference": "LG: Thay đổi logger có thể bị mất do tham chiếu yếu trong OpenJDK. OpenJDK giới thiệu một sự không tương thích tiềm ẩn. Cụ thể, hành vi của java.util.logging.Logger đã thay đổi. Thay vì sử dụng tham chiếu mạnh, bây giờ nó sử dụng tham chiếu yếu bên trong. Đây là một thay đổi hợp lý, nhưng không may một số mã dựa vào hành vi cũ - khi thay đổi cấu hình logger, nó chỉ đơn giản là bỏ qua tham chiếu logger. Điều đó có nghĩa là garbage collector có thể thu hồi bộ nhớ đó, dẫn đến việc cấu hình logger bị mất. Ví dụ, xem xét: public static void initLogging() throws Exception { Logger logger = Logger.getLogger('edu.umd.cs'); logger.addHandler(new FileHandler()); // gọi để thay đổi cấu hình logger logger.setUseParentHandlers(false); // gọi khác để thay đổi cấu hình logger } Tham chiếu logger bị mất vào cuối phương thức (nó không thoát khỏi phương thức), vì vậy nếu có một chu kỳ garbage collection ngay sau khi gọi initLogging, cấu hình logger bị mất (vì Logger chỉ giữ tham chiếu yếu). public static void main(String[] args) throws Exception { initLogging(); // thêm file handler vào logger System.gc(); // cấu hình logger bị mất Logger.getLogger('edu.umd.cs').info('Some message'); // điều này không được ghi vào file như mong đợi } Ulf Ochsenfahrt và Eric Fellheimer",
      "dm_convert_case": "Dm: Cân nhắc sử dụng phiên bản phương thức với tham số Locale\nMột chuỗi đang được chuyển đổi sang chữ hoa hoặc chữ thường, sử dụng mã hóa mặc định của nền tảng. Điều này có thể dẫn đến chuyển đổi không chính xác khi sử dụng với các ký tự quốc tế. Hãy sử dụng các phiên bản\n\nString.toUpperCase( Locale l )\nString.toLowerCase( Locale l )thay vào đó.",
      "dm_default_encoding": "Dm: Phụ thuộc vào mã hóa mặc định\nTìm thấy một lời gọi đến phương thức sẽ thực hiện việc chuyển đổi từ byte sang String (hoặc String sang byte), và giả định rằng mã hóa mặc định của nền tảng là phù hợp. Điều này sẽ gây ra sự thay đổi trong hành vi ứng dụng giữa các nền tảng. Hãy sử dụng API thay thế và chỉ định tên charset hoặc đối tượng Charset một cách rõ ràng.\n\nXem CWE-173: Xử lý không đúng về Mã hóa thay thế.",
      "dp_do_inside_do_privileged": "DP: Phương thức được gọi chỉ nên được gọi trong một khối doPrivileged\nMã này gọi một phương thức yêu cầu kiểm tra quyền truy cập bảo mật. Nếu mã này sẽ được cấp quyền bảo mật, nhưng có thể bị gọi bởi mã không có quyền bảo mật, thì việc gọi phương thức cần phải xảy ra trong một khối doPrivileged.\n\nLớp java.security.AccessController, chứa các phương thức doPrivileged, đã bị loại bỏ trong Java 17 (xem JEP 411) và bị gỡ bỏ trong Java 24 (xem JEP 486). Vì lý do này, lỗi này không được báo cáo trong các lớp nhắm đến Java 17 và cao hơn.\nXem CWE-266: Gán quyền không chính xác.",
      "dp_create_classloader_inside_do_privileged": "DP: Classloaders chỉ nên được tạo bên trong khối doPrivileged\nMã này tạo một classloader, điều này cần quyền nếu một security manager được cài đặt. Nếu mã này có thể bị gọi bởi mã không có quyền bảo mật, thì việc tạo classloader cần phải xảy ra trong một khối doPrivileged.\n\nLớp java.security.AccessController, chứa các phương thức doPrivileged, đã bị loại bỏ trong Java 17 (xem JEP 411) và bị gỡ bỏ trong Java 24 (xem JEP 486). Vì lý do này, lỗi này không được báo cáo trong các lớp nhắm đến Java 17 và cao hơn.\nXem CWE-266: Gán quyền không chính xác.",
      "fi_public_should_be_protected": "FI: Finalizer nên được bảo vệ, không phải công khai\nPhương thức finalize() của lớp nên có quyền truy cập protected, không phải public.\n\nXem CWE-583: finalize() Phương thức khai báo là Public.",
      "ms_expose_rep": "MS: Phương thức static public có thể lộ ra sự đại diện nội bộ bằng cách trả về đối tượng hoặc mảng có thể thay đổi\nPhương thức static public trả về một tham chiếu đến một đối tượng có thể thay đổi hoặc một mảng là một phần của trạng thái static của lớp. Bất kỳ mã nào gọi phương thức này có thể tự do thay đổi mảng cơ bản. Một cách sửa là trả về bản sao của mảng.",
      "ms_expose_buf": "MS: Có thể lộ ra sự đại diện nội bộ bằng cách trả về bộ đệm chia sẻ dữ liệu không công khai\nPhương thức static public trả về một bộ đệm (java.nio.*Buffer) bao bọc một mảng là một phần của trạng thái static của lớp chỉ bằng cách giữ một tham chiếu đến mảng này hoặc trả về một bản sao nông của bộ đệm là một phần của trạng thái static của lớp, chia sẻ tham chiếu của nó với bộ đệm gốc. Bất kỳ mã nào gọi phương thức này có thể tự do thay đổi mảng cơ bản. Một cách sửa là trả về bộ đệm chỉ đọc hoặc một bộ đệm mới với bản sao của mảng.",
      "ei_expose_rep": "EI: Có thể lộ ra sự đại diện nội bộ bằng cách trả về tham chiếu đến đối tượng có thể thay đổi\nViệc trả về tham chiếu đến một giá trị đối tượng có thể thay đổi được lưu trữ trong một trong các trường của đối tượng sẽ lộ ra sự đại diện nội bộ của đối tượng. Nếu các thể hiện được truy cập bởi mã không đáng tin cậy, và việc thay đổi không kiểm tra đối với đối tượng có thể thay đổi sẽ làm suy yếu bảo mật hoặc các thuộc tính quan trọng khác, bạn sẽ cần làm điều gì đó khác. Trả về bản sao mới của đối tượng là cách tiếp cận tốt hơn trong nhiều tình huống.\n\nXem CWE-374: Truyền đối tượng có thể thay đổi vào phương thức không đáng tin cậy.",
      "ei_expose_buf": "EI: Có thể lộ ra sự đại diện nội bộ bằng cách trả về bộ đệm chia sẻ dữ liệu không công khai\nViệc trả về tham chiếu đến một bộ đệm (java.nio.*Buffer) bao bọc một mảng lưu trữ trong một trong các trường của đối tượng sẽ lộ ra sự đại diện nội bộ của các phần tử mảng vì bộ đệm chỉ lưu trữ tham chiếu đến mảng thay vì sao chép nội dung của nó. Tương tự, việc trả về một bản sao nông của bộ đệm như vậy (sử dụng phương thức duplicate()) lưu trữ trong một trong các trường của đối tượng cũng sẽ lộ ra sự đại diện nội bộ của bộ đệm. Nếu các thể hiện được truy cập bởi mã không đáng tin cậy, và việc thay đổi không kiểm tra đối với mảng sẽ làm suy yếu bảo mật hoặc các thuộc tính quan trọng khác, bạn sẽ cần làm điều gì đó khác. Trả về bộ đệm chỉ đọc (sử dụng phương thức asReadOnly()) hoặc sao chép mảng vào bộ đệm mới (sử dụng phương thức put()) là cách tiếp cận tốt hơn trong nhiều tình huống.\n\nXem CWE-374: Truyền đối tượng có thể thay đổi vào phương thức không đáng tin cậy.",
      "ei_expose_rep2": "EI2: Có thể lộ ra sự đại diện nội bộ bằng cách kết hợp tham chiếu đến đối tượng có thể thay đổi\nMã này lưu trữ một tham chiếu đến một đối tượng có thể thay đổi từ bên ngoài vào sự đại diện nội bộ của đối tượng. Nếu các thể hiện được truy cập bởi mã không đáng tin cậy, và việc thay đổi không kiểm tra đối với đối tượng có thể thay đổi sẽ làm suy yếu bảo mật hoặc các thuộc tính quan trọng khác, bạn sẽ cần làm điều gì đó khác. Lưu trữ bản sao của đối tượng là cách tiếp cận tốt hơn trong nhiều tình huống.\n\nXem CWE-374: Truyền đối tượng có thể thay đổi vào phương thức không đáng tin cậy.",
      "ei_expose_static_rep2": "MS: Có thể lộ ra trạng thái nội bộ tĩnh bằng cách lưu trữ đối tượng có thể thay đổi vào trường tĩnh\nMã này lưu trữ một tham chiếu đến một đối tượng có thể thay đổi từ bên ngoài vào trường tĩnh. Nếu việc thay đổi không kiểm tra đối với đối tượng có thể thay đổi sẽ làm suy yếu bảo mật hoặc các thuộc tính quan trọng khác, bạn sẽ cần làm điều gì đó khác. Lưu trữ bản sao của đối tượng là cách tiếp cận tốt hơn trong nhiều tình huống.",
      "ei_expose_buf2": "EI2: Có thể lộ ra sự đại diện nội bộ bằng cách tạo bộ đệm kết hợp tham chiếu đến mảng\nMã này tạo ra một bộ đệm lưu trữ tham chiếu đến một mảng bên ngoài hoặc mảng của bộ đệm bên ngoài vào sự đại diện nội bộ của đối tượng. Nếu các thể hiện được truy cập bởi mã không đáng tin cậy, và việc thay đổi không kiểm tra đối với mảng sẽ làm suy yếu bảo mật hoặc các thuộc tính quan trọng khác, bạn sẽ cần làm điều gì đó khác. Lưu trữ bản sao của mảng là cách tiếp cận tốt hơn trong nhiều tình huống.\n\nXem CWE-374: Truyền đối tượng có thể thay đổi vào phương thức không đáng tin cậy.",
      "ei_expose_static_buf2": "MS: Có thể lộ ra trạng thái nội bộ tĩnh bằng cách tạo bộ đệm lưu trữ mảng bên ngoài vào trường tĩnh\nMã này tạo ra một bộ đệm lưu trữ tham chiếu đến một mảng bên ngoài hoặc mảng của bộ đệm bên ngoài vào trường tĩnh. Nếu việc thay đổi không kiểm tra đối với mảng sẽ làm suy yếu bảo mật hoặc các thuộc tính quan trọng khác, bạn sẽ cần làm điều gì đó khác. Lưu trữ bản sao của mảng là cách tiếp cận tốt hơn trong nhiều tình huống.",
      "ms_ooi_pkgprotect": "MS: Trường nên được di chuyển ra khỏi giao diện và làm bảo vệ gói\nMột trường static final được định nghĩa trong giao diện tham chiếu đến một đối tượng có thể thay đổi như mảng hoặc bảng băm. Đối tượng có thể thay đổi này có thể bị mã độc thay đổi hoặc vô tình từ một gói khác. Để giải quyết điều này, trường cần được di chuyển vào một lớp và làm bảo vệ gói để tránh lỗ hổng này.",
      "ms_final_pkgprotect": "MS: Trường nên vừa là final vừa bảo vệ gói\nMột trường static có thể thay đổi có thể bị mã độc thay đổi hoặc vô tình từ một gói khác. Trường có thể được làm bảo vệ gói và/hoặc làm final để tránh lỗ hổng này.",
      "ms_should_be_final": "MS: Trường không phải final nhưng nên làm như vậy\nTrường static public hoặc protected này không phải final, và có thể bị mã độc thay đổi hoặc vô tình từ một gói khác. Trường có thể được làm final để tránh lỗ hổng này.\n\nXem CWE-500: Trường static public không được đánh dấu là final.",
      "ms_should_be_refactored_to_be_final": "MS: Trường không phải final nhưng nên được tái cấu trúc để làm như vậy\nTrường static public hoặc protected này không phải final, và có thể bị mã độc thay đổi hoặc vô tình từ một gói khác. Trường có thể được làm final để tránh lỗ hổng này. Tuy nhiên, bộ khởi tạo static chứa nhiều phép ghi vào trường này, vì vậy việc làm vậy sẽ yêu cầu phải tái cấu trúc.\n\nXem CWE-500: Trường static public không được đánh dấu là final.",
      "ms_pkgprotect": "MS: Trường nên được bảo vệ gói\nMột trường static có thể thay đổi có thể bị mã độc thay đổi hoặc vô tình từ một gói khác. Trường có thể được làm bảo vệ gói để tránh lỗ hổng này.\n\nXem CWE-607: Trường static final public tham chiếu đối tượng có thể thay đổi.",
      "ms_mutable_hashtable": "MS: Trường là một Hashtable có thể thay đổi\nMột trường static final tham chiếu đến một Hashtable và có thể bị mã độc thay đổi hoặc vô tình từ một gói khác. Mã này có thể tự do sửa đổi nội dung của Hashtable.",
      "ms_mutable_array": "MS: Trường là một mảng có thể thay đổi\nMột trường static final tham chiếu đến một mảng và có thể bị mã độc thay đổi hoặc vô tình từ một gói khác. Mã này có thể tự do sửa đổi nội dung của mảng.",
      "ms_mutable_collection": "MS: Trường là một collection có thể thay đổi\nMột thể hiện collection có thể thay đổi được gán cho một trường static final, do đó có thể bị thay đổi bởi mã độc hoặc vô tình từ một gói khác. Hãy cân nhắc bao bọc trường này trong Collections.unmodifiableSet/List/Map/etc. để tránh lỗ hổng này.",
      "ms_mutable_collection_pkgprotect": "MS: Trường là một collection có thể thay đổi và nên được bảo vệ gói\nMột thể hiện collection có thể thay đổi được gán cho một trường static final, do đó có thể bị thay đổi bởi mã độc hoặc vô tình từ một gói khác. Trường có thể được làm bảo vệ gói để tránh lỗ hổng này. Ngoài ra, bạn có thể bao bọc trường này trong Collections.unmodifiableSet/List/Map/etc. để tránh lỗ hổng này.",
      "ms_cannot_be_final": "MS: Trường không phải final và không thể được bảo vệ khỏi mã độc\nMột trường static có thể thay đổi có thể bị mã độc thay đổi hoặc vô tình từ một gói khác. Rất tiếc, cách sử dụng trường này không cho phép có cách sửa chữa đơn giản cho vấn đề này.",
      "reflc_reflection_may_increase_accessibility_of_class": "REFLC: Phương thức public sử dụng reflection để tạo một lớp nhận từ tham số, điều này có thể làm tăng khả năng truy cập của bất kỳ lớp nào\nQuy tắc SEI CERT SEC05-J cấm việc sử dụng reflection để tăng khả năng truy cập của các lớp, phương thức hoặc trường. Nếu một lớp trong một gói cung cấp một phương thức public nhận một đối tượng java.lang.Class làm tham số và gọi phương thức newInstance() của nó, thì nó làm tăng khả năng truy cập của các lớp trong cùng gói mà không có constructor public. Mã tấn công có thể gọi phương thức này và truyền lớp như vậy để tạo một thể hiện của nó. Điều này nên được tránh bằng cách làm phương thức không public hoặc kiểm tra quyền truy cập gói trên gói. Một khả năng khác là sử dụng phương thức java.beans.Beans.instantiate() thay vì java.lang.Class.newInstance() vì nó kiểm tra xem đối tượng Class nhận được có bất kỳ constructor public nào không.\n\nXem CWE-470: Sử dụng đầu vào điều khiển từ bên ngoài để chọn các lớp hoặc mã ('Reflection không an toàn').",
      "reflf_reflection_may_increase_accessibility_of_field": "REFLF: Phương thức public sử dụng reflection để sửa đổi trường nhận từ tham số, điều này có thể làm tăng khả năng truy cập của bất kỳ lớp nào\nQuy tắc SEI CERT SEC05-J cấm việc sử dụng reflection để tăng khả năng truy cập của các lớp, phương thức hoặc trường. Nếu một lớp trong một gói cung cấp một phương thức public nhận một đối tượng java.lang.reflect.Field làm tham số và gọi phương thức setter (hoặc setAccessible()) thì nó làm tăng khả năng truy cập của các trường trong cùng gói mà là private, protected hoặc package private. Mã tấn công có thể gọi phương thức này và truyền trường như vậy để thay đổi nó. Điều này nên được tránh bằng cách làm phương thức không public hoặc kiểm tra quyền truy cập gói trên gói.\n\nXem CWE-470: Sử dụng đầu vào điều khiển từ bên ngoài để chọn các lớp hoặc mã ('Reflection không an toàn').",
      "mc_overridable_method_call_in_constructor": "MC: Phương thức có thể ghi đè được gọi từ constructor\nGọi phương thức có thể ghi đè trong constructor có thể dẫn đến việc sử dụng dữ liệu chưa được khởi tạo. Nó cũng có thể rò rỉ tham chiếu this của đối tượng đang được xây dựng một phần. Chỉ nên gọi các phương thức static, final hoặc private từ constructor.\n\nXem quy tắc SEI CERT MET05-J. Đảm bảo rằng constructor không gọi phương thức có thể ghi đè.",
      "mc_overridable_method_call_in_clone": "MC: Phương thức có thể ghi đè được gọi từ phương thức clone()\nGọi phương thức có thể ghi đè từ phương thức clone() là không an toàn vì một lớp con có thể ghi đè phương thức, ảnh hưởng đến hành vi của clone(). Nó cũng có thể quan sát hoặc sửa đổi đối tượng clone khi đối tượng chưa được khởi tạo hoàn chỉnh. Chỉ nên gọi các phương thức static, final hoặc private từ phương thức clone().\n\nXem quy tắc SEI CERT MET06-J. Không gọi phương thức có thể ghi đè trong clone().",
      "mc_overridable_method_call_in_read_object": "MC: Phương thức có thể ghi đè được gọi từ phương thức readObject\nPhương thức readObject() không được gọi bất kỳ phương thức có thể ghi đè nào. Gọi phương thức có thể ghi đè từ phương thức readObject có thể cung cấp quyền truy cập vào trạng thái của đối tượng trước khi nó được khởi tạo hoàn chỉnh. Quyền truy cập sớm này là khả thi vì trong quá trình giải mã, phương thức readObject đóng vai trò như constructor của đối tượng và do đó việc khởi tạo đối tượng chưa hoàn tất cho đến khi readObject kết thúc.\n\nXem quy tắc SEI CERT SER09-J. Không gọi phương thức có thể ghi đè từ phương thức readObject().",
      "perm_super_not_called_in_getpermissions": "PERM: Bộ tải lớp tùy chỉnh không gọi phương thức getPermissions() của lớp cha\nQuy tắc SEI CERT SEC07-J yêu cầu các bộ tải lớp tùy chỉnh phải luôn gọi phương thức getPermissions() của lớp cha trong phương thức getPermissions() của chính chúng để khởi tạo đối tượng mà chúng trả về ở cuối. Việc bỏ qua điều này có nghĩa là một lớp được định nghĩa bằng bộ tải lớp tùy chỉnh này sẽ có quyền truy cập hoàn toàn độc lập với những quyền được chỉ định trong tệp chính sách toàn hệ thống. Trên thực tế, quyền của lớp này sẽ ghi đè các quyền đã được chỉ định.",
      "usc_potential_security_check_based_on_untrusted_source": "USC: Kiểm tra bảo mật tiềm ẩn dựa trên nguồn không đáng tin cậy\nMột phương thức public của một lớp public có thể bị gọi từ bên ngoài gói, có nghĩa là dữ liệu không đáng tin cậy có thể được truyền vào đó. Việc gọi một phương thức trước khi thực hiện doPrivileged để kiểm tra giá trị trả về của nó và sau đó gọi lại phương thức đó bên trong lớp là nguy hiểm nếu phương thức hoặc lớp bao quanh nó không phải là final. Một kẻ tấn công có thể truyền một thể hiện của lớp con độc hại thay vì một thể hiện của lớp mong đợi, nơi phương thức này bị ghi đè theo cách mà nó trả về các giá trị khác nhau trong các lần gọi khác nhau. Ví dụ, một phương thức trả về đường dẫn tệp có thể trả về một đường dẫn vô hại để kiểm tra trước khi vào khối doPrivileged và sau đó trả về một tệp nhạy cảm khi gọi bên trong khối doPrivileged. Để tránh tình huống như vậy, hãy sao chép đối tượng nhận được trong tham số, ví dụ bằng cách sử dụng constructor sao chép của lớp được sử dụng làm kiểu tham số chính thức. Điều này đảm bảo rằng phương thức hoạt động chính xác như mong đợi.\n\nXem quy tắc SEI CERT SEC02-J. Không dựa vào các nguồn không đáng tin cậy để kiểm tra bảo mật, CWE-302: Bỏ qua xác thực do dữ liệu giả định là không thay đổi, và CWE-470: Sử dụng đầu vào điều khiển từ bên ngoài để chọn các lớp hoặc mã ('Reflection không an toàn').\n\nLớp java.security.AccessController, chứa các phương thức doPrivileged, đã bị deprecated trong Java 17 (xem JEP 411), và bị loại bỏ trong Java 24 (xem JEP 486). Do đó, lỗi này không được báo cáo trong các lớp nhắm tới Java 17 trở lên.",
      "vsc_vulnerable_security_check_methods": "VSC: Các phương thức kiểm tra bảo mật không phải là Private và không phải là final có thể bị tấn công\nCác phương thức thực hiện kiểm tra bảo mật cần được ngừng ghi đè, vì vậy chúng phải được khai báo là private hoặc final. Nếu không, các phương thức này có thể bị xâm phạm khi một lớp con độc hại ghi đè chúng và bỏ qua các kiểm tra.\n\nXem quy tắc SEI CERT MET03-J. Các phương thức thực hiện kiểm tra bảo mật phải được khai báo là private hoặc final.",
      "at_operation_sequence_on_concurrent_abstraction": "AT: Dãy gọi đến trừu tượng đồng thời có thể không là nguyên tử\nĐoạn mã này chứa một dãy các cuộc gọi đến một trừu tượng đồng thời (như concurrent hash map). Những cuộc gọi này sẽ không được thực thi một cách nguyên tử.\n\nXem các tham chiếu sau: CWE-362: Thực thi đồng thời sử dụng tài nguyên chia sẻ với đồng bộ hóa không đúng ('Điều kiện đua'), CWE-366: Điều kiện đua trong một luồng, CWE-662: Đồng bộ hóa không đúng.",
      "at_unsafe_resource_access_in_thread": "AT: Thao tác trên tài nguyên không an toàn trong bối cảnh đa luồng\nĐoạn mã này chứa một thao tác trên tài nguyên không an toàn trong bối cảnh đa luồng. Tài nguyên có thể bị truy cập bởi nhiều luồng đồng thời mà không có đồng bộ hóa đúng cách. Điều này có thể dẫn đến sự cố dữ liệu. Sử dụng đồng bộ hóa hoặc các cơ chế kiểm soát đồng thời khác để đảm bảo tài nguyên được truy cập một cách an toàn.\n\nXem quy tắc SEI CERT liên quan, nhưng công cụ phát hiện không bị giới hạn ở các phương thức chuỗi: VNA04-J. Đảm bảo rằng các cuộc gọi đến các phương thức chuỗi là nguyên tử.\n\nXem các tham chiếu sau: CWE-362: Thực thi đồng thời sử dụng tài nguyên chia sẻ với đồng bộ hóa không đúng ('Điều kiện đua'), CWE-366: Điều kiện đua trong một luồng, CWE-662: Đồng bộ hóa không đúng.",
      "stcal_static_calendar_instance": "STCAL: Trường Calendar tĩnh\nMặc dù JavaDoc không có gợi ý về vấn đề này, Calendars vốn không an toàn khi sử dụng trong môi trường đa luồng. Việc chia sẻ một thể hiện duy nhất qua các biên giới luồng mà không có đồng bộ hóa đúng cách sẽ dẫn đến hành vi không ổn định của ứng dụng. Dưới phiên bản 1.4, vấn đề này có vẻ ít xuất hiện hơn so với Java 5, nơi bạn có thể gặp phải các lỗi như ArrayIndexOutOfBoundsException hoặc IndexOutOfBoundsException trong phương thức sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate().\n\nBạn cũng có thể gặp phải các vấn đề về tuần tự hóa.\n\nKhuyến nghị sử dụng trường thể hiện.\n\nĐể biết thêm thông tin về vấn đề này, xem lỗi JDK #6231579 và JDK #6178997.",
      "stcal_static_simple_date_format_instance": "STCAL: DateFormat tĩnh\nNhư JavaDoc đã chỉ ra, DateFormats vốn không an toàn khi sử dụng trong môi trường đa luồng. Việc chia sẻ một thể hiện duy nhất qua các biên giới luồng mà không có đồng bộ hóa đúng cách sẽ dẫn đến hành vi không ổn định của ứng dụng.\n\nBạn cũng có thể gặp phải các vấn đề về tuần tự hóa.\n\nKhuyến nghị sử dụng trường thể hiện.\n\nĐể biết thêm thông tin về vấn đề này, xem lỗi JDK #6231579 và JDK #6178997.",
      "stcal_invoke_on_static_calendar_instance": "STCAL: Gọi phương thức Calendar tĩnh\nMặc dù JavaDoc không có gợi ý về vấn đề này, Calendars vốn không an toàn khi sử dụng trong môi trường đa luồng. Công cụ phát hiện đã tìm thấy một cuộc gọi đến thể hiện của Calendar được lấy qua một trường tĩnh. Điều này có vẻ đáng ngờ.\n\nĐể biết thêm thông tin về vấn đề này, xem lỗi JDK #6231579 và JDK #6178997.",
      "stcal_invoke_on_static_date_format_instance": "STCAL: Gọi phương thức DateFormat tĩnh\nNhư JavaDoc đã chỉ ra, DateFormats vốn không an toàn khi sử dụng trong môi trường đa luồng. Công cụ phát hiện đã tìm thấy một cuộc gọi đến thể hiện của DateFormat được lấy qua một trường tĩnh. Điều này có vẻ đáng ngờ.\n\nĐể biết thêm thông tin về vấn đề này, xem lỗi JDK #6231579 và JDK #6178997.",
      "np_sync_and_null_check_field": "NP: Đồng bộ hóa và kiểm tra null trên cùng một trường.\nVì trường này đã được đồng bộ hóa, có vẻ không có khả năng nó bị null. Nếu nó bị null và sau đó được đồng bộ hóa, sẽ có một NullPointerException và việc kiểm tra sẽ vô nghĩa. Tốt hơn là đồng bộ hóa trên một trường khác.",
      "vo_volatile_reference_to_array": "VO: Tham chiếu volatile đến mảng không coi các phần tử của mảng là volatile\nĐoạn mã này khai báo một tham chiếu volatile đến một mảng, điều này có thể không phải là những gì bạn mong muốn. Với một tham chiếu volatile đến mảng, việc đọc và ghi tham chiếu đến mảng sẽ được coi là volatile, nhưng các phần tử của mảng lại không phải là volatile. Để các phần tử mảng là volatile, bạn sẽ cần sử dụng một trong các lớp mảng nguyên tử trong java.util.concurrent (được cung cấp trong Java 5.0).",
      "vo_volatile_increment": "VO: Việc tăng giá trị một trường volatile không phải là nguyên tử\nĐoạn mã này thực hiện việc tăng/giảm giá trị một trường volatile. Việc tăng/giảm giá trị của trường volatile không phải là nguyên tử. Nếu có hơn một luồng cùng tăng/giảm trường này cùng lúc, giá trị tăng/giảm có thể bị mất.\n\nXem CWE-567: Truy cập không đồng bộ đến dữ liệu chia sẻ trong bối cảnh đa luồng.",
      "dm_monitor_wait_on_condition": "Dm: Gọi phương thức wait() trên Condition\nPhương thức này gọi phương thức wait() trên một đối tượng java.util.concurrent.locks.Condition. Việc chờ một Condition nên được thực hiện bằng cách sử dụng một trong các phương thức await() được định nghĩa bởi giao diện Condition.",
      "dm_useless_thread": "Dm: Một luồng được tạo ra bằng phương thức run mặc định rỗng\nPhương thức này tạo ra một luồng mà không chỉ định phương thức run, có thể là thông qua việc kế thừa từ lớp Thread, hoặc bằng cách truyền một đối tượng Runnable. Luồng này do đó không làm gì ngoài việc lãng phí thời gian.",
      "dc_doublecheck": "DC: Có thể là kiểm tra đôi cho trường\nPhương thức này có thể chứa một thể hiện của double-checked locking. Cách tiếp cận này không đúng theo ngữ nghĩa của mô hình bộ nhớ Java. Để biết thêm thông tin, xem trang web http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html và CWE-609: Double-Checked Locking.",
      "dc_partially_constructed": "DC: Có thể lộ đối tượng chưa khởi tạo hoàn toàn\nCó vẻ như phương thức này sử dụng khởi tạo trường lười với double-checked locking. Mặc dù trường đã được khai báo đúng là volatile, nhưng có thể cấu trúc nội bộ của đối tượng đã bị thay đổi sau khi gán trường, vì vậy một luồng khác có thể thấy đối tượng chưa khởi tạo hoàn toàn.\n\nĐể khắc phục vấn đề này, hãy xem xét lưu đối tượng vào biến cục bộ trước và chỉ lưu vào trường volatile sau khi nó đã được khởi tạo hoàn toàn.\n\nXem CWE-609: Double-Checked Locking.",
      "dl_synchronization_on_shared_constant": "DL: Đồng bộ hóa trên chuỗi hằng số\nĐoạn mã này đồng bộ hóa trên chuỗi hằng số.\n\nprivate static String LOCK = 'LOCK';\n...\nsynchronized(LOCK) {\n    ...\n}\n...\nCác chuỗi hằng số được lưu trữ và chia sẻ qua tất cả các lớp khác được tải bởi JVM. Vì vậy, đoạn mã này đang đồng bộ hóa trên một đối tượng mà mã khác cũng có thể đồng bộ hóa. Điều này có thể dẫn đến hành vi khóa và deadlock rất kỳ lạ và khó chẩn đoán. Xem http://www.javalobby.org/java/forums/t96352.html và http://jira.codehaus.org/browse/JETTY-352.\n\nXem CERT LCK01-J. Không đồng bộ hóa trên các đối tượng có thể được tái sử dụng và CWE-412: Khóa ngoài không giới hạn có thể truy cập cho thông tin thêm.",
      "dl_synchronization_on_boolean": "DL: Đồng bộ hóa trên Boolean\nĐoạn mã này đồng bộ hóa trên một hằng số nguyên thủy được bao bọc, như Boolean.\n\nprivate static Boolean inited = Boolean.FALSE;\n...\nsynchronized(inited) {\n    if (!inited) {\n        init();\n        inited = Boolean.TRUE;\n    }\n}\n...\nVì thông thường chỉ tồn tại hai đối tượng Boolean, đoạn mã này có thể đang đồng bộ hóa trên cùng một đối tượng với mã không liên quan khác, dẫn đến sự không phản hồi và có thể gây deadlock.\n\nXem CERT LCK01-J. Không đồng bộ hóa trên các đối tượng có thể được tái sử dụng và CWE-412: Khóa ngoài không giới hạn có thể truy cập cho thông tin thêm.",
      "dl_synchronization_on_boxed_primitive": "DL: Đồng bộ hóa trên đối tượng nguyên thủy được bao bọc\nĐoạn mã này đồng bộ hóa trên một hằng số nguyên thủy được bao bọc, như Integer.\n\nprivate static Integer count = 0;\n...\nsynchronized(count) {\n    count++;\n}\n...\nVì các đối tượng Integer có thể được lưu vào bộ nhớ cache và chia sẻ, đoạn mã này có thể đang đồng bộ hóa trên cùng một đối tượng với mã không liên quan khác, dẫn đến sự không phản hồi và có thể gây deadlock.\n\nXem CERT LCK01-J. Không đồng bộ hóa trên các đối tượng có thể được tái sử dụng và CWE-412: Khóa ngoài không giới hạn có thể truy cập cho thông tin thêm.",
      "dl_synchronization_on_unshared_boxed_primitive": "DL: Đồng bộ hóa trên giá trị nguyên thủy được bao bọc\nĐoạn mã này đồng bộ hóa trên một giá trị nguyên thủy được bao bọc, chẳng hạn như Integer.\n\nprivate static final Integer fileLock = new Integer(1);\n...\nsynchronized(fileLock) {\n    .. làm gì đó ..\n}\n...\nĐoạn mã này sẽ tốt hơn rất nhiều nếu khai báo lại fileLock như sau:\n\nprivate static final Object fileLock = new Object();\nMã hiện tại có thể ổn, nhưng nó gây nhầm lẫn và việc tái cấu trúc trong tương lai, chẳng hạn như 'Remove Boxing' trong IntelliJ, có thể thay thế nó bằng việc sử dụng đối tượng Integer đã được lưu trữ, được chia sẻ trên toàn bộ JVM, dẫn đến hành vi rất khó hiểu và có thể gây deadlock.\n\nXem CERT LCK01-J. Không đồng bộ hóa trên các đối tượng có thể được tái sử dụng và CWE-412: Khóa ngoài không giới hạn có thể truy cập cho thông tin thêm.",
      "dl_synchronization_on_interned_string": "DL: Đồng bộ hóa trên String đã được lưu trữ\nĐoạn mã này đồng bộ hóa trên String đã được lưu trữ.\n\nprivate static String LOCK = new String('LOCK').intern();\n...\nsynchronized(LOCK) {\n    ...\n}\n...\nCác chuỗi hằng số được lưu trữ và chia sẻ qua tất cả các lớp khác được tải bởi JVM. Vì vậy, đoạn mã này đang đồng bộ hóa trên một đối tượng mà mã khác cũng có thể đồng bộ hóa. Điều này có thể dẫn đến hành vi khóa và deadlock rất kỳ lạ và khó chẩn đoán. Xem http://www.javalobby.org/java/forums/t96352.html và http://jira.codehaus.org/browse/JETTY-352.\n\nXem CERT LCK01-J. Không đồng bộ hóa trên các đối tượng có thể được tái sử dụng và CWE-412: Khóa ngoài không giới hạn có thể truy cập cho thông tin thêm.",
      "wl_using_getclass_rather_than_class_literal": "WL: Đồng bộ hóa trên getClass thay vì lớp hằng số\nPhương thức thể hiện này đồng bộ hóa trên this.getClass(). Nếu lớp này được kế thừa, các lớp con sẽ đồng bộ hóa trên đối tượng lớp của lớp con, điều này không phải là điều mong muốn. Ví dụ, xem đoạn mã sau từ java.awt.Label:\n\nprivate static final String base = 'label';\nprivate static int nameCounter = 0;\n\nString constructComponentName() {\n    synchronized (getClass()) {\n        return base + nameCounter++;\n    }\n}\nCác lớp con của Label sẽ không đồng bộ hóa trên cùng một lớp con, gây ra race condition. Thay vào đó, đoạn mã này nên đồng bộ hóa trên Label.class.\n\nprivate static final String base = 'label';\nprivate static int nameCounter = 0;\n\nString constructComponentName() {\n    synchronized (Label.class) {\n        return base + nameCounter++;\n    }\n}\nMẫu lỗi được đóng góp bởi Jason Mehrens.\n\nXem CWE-821: Đồng bộ hóa không chính xác.",
      "e_sync_empty_sync": "ESync: Khối đồng bộ hóa rỗng\nĐoạn mã này chứa một khối đồng bộ hóa rỗng:\n\nsynchronized() {\n}\nKhối đồng bộ hóa rỗng khó sử dụng đúng hơn so với những gì người ta nhận thức và hầu như không bao giờ là giải pháp tốt hơn so với các giải pháp đơn giản hơn.\n\nXem CWE-585: Khối đồng bộ hóa rỗng.",
      "msf_mutable_servlet_field": "MSF: Trường servlet có thể thay đổi\nMột máy chủ web thường chỉ tạo một thể hiện của lớp servlet hoặc JSP (tức là coi lớp đó như một Singleton) và sẽ có nhiều luồng gọi các phương thức trên thể hiện đó để phục vụ nhiều yêu cầu đồng thời. Do đó, việc có một trường thể hiện có thể thay đổi thường tạo ra các race condition.",
      "is2_inconsistent_sync": "IS: Đồng bộ hóa không nhất quán\nCác trường của lớp này có vẻ bị truy cập không nhất quán liên quan đến đồng bộ hóa. Báo cáo lỗi này chỉ ra rằng trình phát hiện mẫu lỗi đã đánh giá rằng:\n\nLớp này chứa sự kết hợp giữa các truy cập đã khóa và chưa khóa,\nLớp này không được chú thích là javax.annotation.concurrent.NotThreadSafe,\nÍt nhất một truy cập đã khóa được thực hiện bởi một trong các phương thức của lớp, và\nSố lượng truy cập trường không đồng bộ hóa (đọc và ghi) không nhiều hơn một phần ba tổng số truy cập, với các lần ghi được tính trọng số gấp đôi so với đọc.\nMột lỗi điển hình khớp với mẫu lỗi này là quên đồng bộ hóa một trong các phương thức trong lớp dự định là an toàn với luồng.\n\nBạn có thể chọn các nút có nhãn 'Truy cập không đồng bộ' để hiển thị các vị trí mã nơi trình phát hiện tin rằng một trường đã bị truy cập mà không có đồng bộ hóa.\n\nLưu ý rằng có nhiều nguồn gây thiếu chính xác trong trình phát hiện này; ví dụ, trình phát hiện không thể phát hiện tĩnh tất cả các tình huống mà một khóa được giữ. Ngoài ra, ngay cả khi trình phát hiện chính xác trong việc phân biệt giữa truy cập đã khóa và chưa khóa, mã trong câu hỏi vẫn có thể đúng.\n\nXem CWE-366: Điều kiện race trong một luồng.",
      "nn_naked_notify": "NN: Thông báo không có đối tượng được thay đổi\nMột cuộc gọi đến notify() hoặc notifyAll() đã được thực hiện mà không có bất kỳ thay đổi rõ ràng nào đối với trạng thái đối tượng có thể thay đổi. Nói chung, việc gọi phương thức thông báo trên một khóa được thực hiện vì một điều kiện mà một luồng khác đang chờ đã trở thành đúng. Tuy nhiên, để điều kiện có ý nghĩa, nó phải liên quan đến một đối tượng heap có thể nhìn thấy bởi cả hai luồng.\n\nLỗi này không nhất thiết chỉ ra một lỗi, vì sự thay đổi trạng thái đối tượng có thể thay đổi đã xảy ra trong một phương thức sau đó gọi phương thức chứa thông báo.",
      "ru_invoke_run": "Ru: Gọi run trên một luồng (bạn có ý định khởi động nó không?)\nPhương thức này gọi rõ ràng run() trên một đối tượng. Nói chung, các lớp triển khai giao diện Runnable vì họ sẽ gọi phương thức run() của họ trong một luồng mới, trong trường hợp này, Thread.start() là phương thức đúng để gọi.\n\nXem CWE-572: Gọi Thread run() thay vì start().",
      "sp_spin_on_field": "SP: Phương thức quay vòng trên trường\nPhương thức này quay vòng trong một vòng lặp đọc một trường. Trình biên dịch có thể hợp pháp di chuyển thao tác đọc ra khỏi vòng lặp, biến mã thành một vòng lặp vô hạn. Lớp này nên được thay đổi để sử dụng đồng bộ hóa thích hợp (bao gồm gọi wait và notify).\n\nXem CWE-662: Đồng bộ hóa không đúng.",
      "tlw_two_lock_wait": "TLW: Chờ với hai khóa được giữ\nChờ trên một khóa trong khi hai khóa được giữ có thể gây ra deadlock. Thực hiện một thao tác chờ chỉ giải phóng khóa trên đối tượng đang chờ, không phải bất kỳ khóa nào khác. Điều này không nhất thiết là một lỗi, nhưng đáng để kiểm tra kỹ.\n\nXem CWE-833: Deadlock.",
      "uw_uncond_wait": "UW: Chờ không có điều kiện\nPhương thức này chứa một cuộc gọi đến java.lang.Object.wait() mà không có kiểm soát luồng điều kiện bảo vệ. Mã nên kiểm tra rằng điều kiện mà nó dự định chờ không đã được thỏa mãn trước khi gọi wait; bất kỳ thông báo trước đó sẽ bị bỏ qua.",
      "ug_sync_set_unsync_get": "UG: Phương thức get không đồng bộ, phương thức set đồng bộ\nLớp này chứa các phương thức get và set có tên tương tự, trong đó phương thức set là đồng bộ và phương thức get thì không. Điều này có thể dẫn đến hành vi sai trong thời gian chạy, vì người gọi phương thức get sẽ không nhất thiết thấy trạng thái nhất quán cho đối tượng. Phương thức get nên được đồng bộ.\n\nXem CWE-820: Thiếu đồng bộ hóa.",
      "is_field_not_guarded": "IS: Trường không được bảo vệ chống truy cập đồng thời\nTrường này được chú thích với net.jcip.annotations.GuardedBy hoặc javax.annotation.concurrent.GuardedBy, nhưng có thể bị truy cập theo cách có vẻ vi phạm những chú thích đó.\n\nXem CWE-366: Điều kiện race trong một luồng.",
      "ml_sync_on_field_to_guard_changing_that_field": "ML: Đồng bộ hóa trên trường trong nỗ lực vô ích để bảo vệ trường đó\nPhương thức này đồng bộ hóa trên một trường trong một nỗ lực có vẻ như là để bảo vệ chống lại việc cập nhật đồng thời cho trường đó. Tuy nhiên, bảo vệ một trường sẽ có khóa trên đối tượng tham chiếu, chứ không phải trên trường. Điều này có thể không cung cấp sự loại trừ lẫn nhau mà bạn cần, và các luồng khác có thể đang lấy khóa trên các đối tượng tham chiếu (cho các mục đích khác). Một ví dụ của mẫu này sẽ là:\n\nprivate Long myNtfSeqNbrCounter = new Long(0);\nprivate Long getNotificationSequenceNumber() {\n     Long result = null;\n     synchronized(myNtfSeqNbrCounter) {\n         result = new Long(myNtfSeqNbrCounter.longValue() + 1);\n         myNtfSeqNbrCounter = new Long(result.longValue());\n     }\n     return result;\n}\nXem CWE-821: Đồng bộ hóa không đúng.",
      "ml_sync_on_updated_field": "ML: Phương thức đồng bộ hóa trên một trường đã được cập nhật\nPhương thức này đồng bộ hóa trên một đối tượng được tham chiếu từ một trường có thể thay đổi. Điều này khó có ý nghĩa hữu ích, vì các luồng khác nhau có thể đồng bộ hóa trên các đối tượng khác nhau.\n\nXem CWE-821: Đồng bộ hóa không đúng.",
      "ws_writeobject_sync": "WS: Phương thức writeObject() của lớp được đồng bộ hóa nhưng không có phương thức nào khác\nLớp này có phương thức writeObject() được đồng bộ hóa; tuy nhiên, không có phương thức nào khác của lớp được đồng bộ hóa.\n\nXem CWE-820: Thiếu đồng bộ hóa.",
      "rs_readobject_sync": "RS: Phương thức readObject() của lớp được đồng bộ hóa\nLớp có thể tuần tự này định nghĩa phương thức readObject() được đồng bộ hóa. Theo định nghĩa, một đối tượng được tạo ra từ việc giải tuần tự chỉ có thể được truy cập bởi một luồng, vì vậy không cần thiết phải đồng bộ hóa phương thức readObject(). Nếu phương thức readObject() tự gây ra đối tượng trở nên khả dụng cho một luồng khác, đó là một ví dụ về phong cách lập trình rất đáng ngờ.\n\nXem CWE-820: Thiếu đồng bộ hóa.",
      "sc_start_in_ctor": "SC: Constructor gọi Thread.start()\nConstructor bắt đầu một luồng. Điều này có thể sai nếu lớp này được mở rộng/lớp con, vì luồng sẽ được bắt đầu trước khi constructor của lớp con được bắt đầu.",
      "wa_not_in_loop": "Wa: Wait không trong vòng lặp\nPhương thức này chứa một cuộc gọi đến java.lang.Object.wait() mà không có vòng lặp. Nếu khóa được sử dụng cho nhiều điều kiện, điều kiện mà người gọi dự định chờ có thể không phải là điều kiện thực sự đã xảy ra.",
      "wa_await_not_in_loop": "Wa: Condition.await() không trong vòng lặp\nPhương thức này chứa một cuộc gọi đến java.util.concurrent.await() (hoặc các biến thể) mà không có vòng lặp. Nếu đối tượng được sử dụng cho nhiều điều kiện, điều kiện mà người gọi dự định chờ có thể không phải là điều kiện thực sự đã xảy ra.",
      "no_notify_not_notifyall": "No: Sử dụng notify() thay vì notifyAll()\nPhương thức này gọi notify() thay vì notifyAll(). Các khóa trong Java thường được sử dụng cho nhiều điều kiện. Việc gọi notify() chỉ đánh thức một luồng, có nghĩa là luồng được đánh thức có thể không phải là luồng đang chờ điều kiện mà người gọi vừa làm thỏa mãn.",
      "ul_unreleased_lock": "UL: Phương thức không giải phóng khóa trên tất cả các đường dẫn\nPhương thức này chiếm một khóa JSR-166 (java.util.concurrent), nhưng không giải phóng nó trên tất cả các đường dẫn ra khỏi phương thức. Nói chung, mẫu đúng khi sử dụng khóa JSR-166 là:\n\nLock l = ...;\nl.lock();\ntry {\n    // làm gì đó\n} finally {\n    l.unlock();\n}\nXem CWE-413: Khóa tài nguyên không đúng và CWE-459: Dọn dẹp không đầy đủ.",
      "ul_unreleased_lock_exception_path": "UL: Phương thức không giải phóng khóa trên tất cả các đường dẫn ngoại lệ\nPhương thức này chiếm một khóa JSR-166 (java.util.concurrent), nhưng không giải phóng nó trên tất cả các đường dẫn ngoại lệ ra khỏi phương thức. Nói chung, mẫu đúng khi sử dụng khóa JSR-166 là:\n\nLock l = ...;\nl.lock();\ntry {\n    // làm gì đó\n} finally {\n    l.unlock();\n}\nXem CWE-413: Khóa tài nguyên không đúng và CWE-459: Dọn dẹp không đầy đủ.",
      "mwn_mismatched_wait": "MWN: Gọi wait() không tương thích\nPhương thức này gọi Object.wait() mà không rõ ràng có khóa đối tượng. Gọi wait() mà không giữ khóa sẽ dẫn đến việc ném ra IllegalMonitorStateException.",
      "mwn_mismatched_notify": "MWN: Gọi notify() không tương thích\nPhương thức này gọi Object.notify() hoặc Object.notifyAll() mà không rõ ràng có khóa đối tượng. Gọi notify() hoặc notifyAll() mà không giữ khóa sẽ dẫn đến việc ném ra IllegalMonitorStateException.",
      "li_lazy_init_static": "LI: Khởi tạo trễ không chính xác đối với trường static\nPhương thức này chứa khởi tạo trễ không đồng bộ hóa cho một trường static không volatile. Vì biên dịch viên hoặc bộ xử lý có thể thay đổi thứ tự các lệnh, các luồng không được đảm bảo sẽ thấy đối tượng đã được khởi tạo hoàn chỉnh, nếu phương thức này có thể được gọi bởi nhiều luồng. Bạn có thể làm cho trường này volatile để sửa vấn đề. Để biết thêm thông tin, tham khảo trang web Mô Hình Bộ Nhớ Java.\n\nXem CWE-543: Sử dụng Mẫu Singleton mà không có Đồng bộ hóa trong bối cảnh đa luồng.",
      "li_lazy_init_update_static": "LI: Khởi tạo và cập nhật trễ không chính xác đối với trường static\nPhương thức này chứa khởi tạo trễ không đồng bộ hóa cho một trường static. Sau khi trường này được gán, đối tượng được lưu vào đó sẽ được cập nhật hoặc truy cập thêm. Việc gán trường này sẽ có sẵn cho các luồng khác ngay khi nó được gán. Nếu việc truy cập thêm trong phương thức thiết lập trường này phục vụ cho việc khởi tạo đối tượng, thì bạn có một lỗi đa luồng rất nghiêm trọng, trừ khi có thứ gì đó ngăn chặn bất kỳ luồng nào truy cập đối tượng đã lưu cho đến khi nó được khởi tạo hoàn chỉnh.\n\nNgay cả khi bạn tự tin rằng phương thức này không bao giờ được gọi bởi nhiều luồng, có thể tốt hơn là không gán giá trị cho trường static cho đến khi giá trị bạn gán đã được điền đầy đủ/khởi tạo.\n\nXem CWE-543: Sử dụng Mẫu Singleton mà không có Đồng bộ hóa trong bối cảnh đa luồng.",
      "jlm_jsr166_utilconcurrent_monitorenter": "JLM: Đồng bộ hóa thực hiện trên đối tượng từ lớp util.concurrent\nPhương thức này thực hiện đồng bộ hóa trên một đối tượng là thể hiện của một lớp từ gói java.util.concurrent (hoặc lớp con của nó). Các thể hiện của các lớp này có cơ chế điều khiển đồng thời riêng biệt, không liên quan đến đồng bộ hóa do từ khóa synchronized của Java cung cấp. Ví dụ, đồng bộ hóa trên một AtomicBoolean sẽ không ngăn cản các luồng khác sửa đổi AtomicBoolean.\n\nMã này có thể đúng, nhưng cần được xem xét và tài liệu cẩn thận, và có thể gây nhầm lẫn cho những người phải bảo trì mã sau này.",
      "jml_jsr166_calling_wait_rather_than_await": "JLM: Sử dụng phương thức wait theo kiểu monitor trên trừu tượng util.concurrent\nPhương thức này gọi wait(), notify() hoặc notifyAll() trên một đối tượng cũng cung cấp phương thức await(), signal(), signalAll() (chẳng hạn như đối tượng Condition từ util.concurrent). Điều này có thể không phải là điều bạn muốn, và ngay cả khi bạn muốn, bạn nên xem xét thay đổi thiết kế của mình, vì các nhà phát triển khác sẽ cảm thấy đặc biệt nhầm lẫn.",
      "jlm_jsr166_lock_monitorenter": "JLM: Đồng bộ hóa thực hiện trên Lock\nPhương thức này thực hiện đồng bộ hóa trên một đối tượng triển khai java.util.concurrent.locks.Lock. Một đối tượng như vậy được khóa/mở khóa bằng cách sử dụng acquire()/release() thay vì sử dụng cấu trúc synchronized (...).",
      "swl_sleep_with_lock_held": "SWL: Phương thức gọi Thread.sleep() khi giữ khóa\nPhương thức này gọi Thread.sleep() khi giữ khóa. Điều này có thể dẫn đến hiệu suất và khả năng mở rộng rất kém, hoặc có thể gây deadlock, vì các luồng khác có thể đang chờ để lấy khóa. Một ý tưởng tốt hơn nhiều là gọi wait() trên khóa, điều này sẽ giải phóng khóa và cho phép các luồng khác chạy.\n\nXem CWE-667: Khóa không đúng.",
      "rv_return_value_of_putifabsent_ignored": "RV: Giá trị trả về của putIfAbsent bị bỏ qua, giá trị truyền vào putIfAbsent được sử dụng lại\nPhương thức putIfAbsent thường được sử dụng để đảm bảo rằng một giá trị duy nhất được liên kết với một khóa nhất định (giá trị đầu tiên mà putIfAbsent thành công). Nếu bạn bỏ qua giá trị trả về và giữ tham chiếu đến giá trị đã truyền vào, bạn có thể giữ lại một giá trị không phải là giá trị được liên kết với khóa trong bản đồ. Nếu quan trọng là bạn sử dụng giá trị nào và bạn sử dụng giá trị không được lưu trong bản đồ, chương trình của bạn sẽ hoạt động sai.\nXem CWE-252: Giá trị trả về không được kiểm tra.",
      "ssd_do_not_use_instance_lock_on_shared_static_data": "SSD: Khóa cấp thể hiện được sử dụng trên dữ liệu tĩnh chia sẻ\nNếu khóa hoặc phương thức synchronized không phải là static, nhưng lại sửa đổi trường static, điều này có thể để lại dữ liệu tĩnh chia sẻ không được bảo vệ trước truy cập đồng thời. Điều này có thể xảy ra theo hai cách, nếu một phương thức đồng bộ hóa sử dụng đối tượng khóa không phải static, hoặc một phương thức synchronized được khai báo là không phải static. Cả hai cách này đều không hiệu quả. Giải pháp tốt nhất là sử dụng một đối tượng khóa static final riêng tư để bảo vệ dữ liệu tĩnh chia sẻ.\n\nXem quy tắc SEI CERT LCK06-J. Không sử dụng khóa thể hiện để bảo vệ dữ liệu tĩnh chia sẻ và CWE-667: Khóa không đúng.",
      "at_nonatomic_64_bit_primitive": "AT: Việc ghi biến nguyên thủy 64-bit này có thể không phải là nguyên tử\nlong và double là các kiểu nguyên thủy 64-bit, và tùy thuộc vào cách triển khai Java Virtual Machine, việc gán giá trị cho chúng có thể được xử lý như hai lần ghi 32-bit riêng biệt, vì vậy nó không phải là nguyên tử. Xem JSL 17.7. Xử lý không nguyên tử của double và long. Xem quy tắc SEI CERT VNA05-J. Đảm bảo tính nguyên tử khi đọc và ghi các giá trị 64-bit và CWE-667: Khóa không đúng để biết thêm chi tiết. Lỗi này có thể được bỏ qua trên các nền tảng đảm bảo rằng các phép đọc và ghi kiểu long và double 64-bit là nguyên tử.\n\nĐể sửa lỗi, hãy khai báo biến volatile, thay đổi kiểu trường thành kiểu nguyên tử tương ứng từ java.lang.concurrent.atomic hoặc đồng bộ hóa đúng cách mã nguồn. Việc khai báo biến volatile có thể không đủ trong một số trường hợp: ví dụ, khi biến được gán giá trị phụ thuộc vào giá trị hiện tại hoặc vào kết quả của các phép toán hợp nhất không nguyên tử.",
      "at_stale_thread_write_of_primitive": "AT: Việc ghi biến nguyên thủy chia sẻ này có thể không hiển thị cho các luồng khác\nQuy tắc SEI CERT VNA00-J mô tả rằng việc đọc một biến nguyên thủy chia sẻ trong một luồng có thể không trả về giá trị của lần ghi gần nhất từ một luồng khác. Do đó, luồng có thể quan sát một giá trị lỗi thời của biến chia sẻ.\n\nĐể sửa lỗi, khai báo biến là volatile, thay đổi kiểu của trường thành kiểu nguyên tử tương ứng từ java.lang.concurrent.atomic hoặc đồng bộ hóa đúng cách mã nguồn. Việc khai báo biến là volatile có thể không đủ trong một số trường hợp: ví dụ, khi biến được gán giá trị phụ thuộc vào giá trị hiện tại hoặc vào kết quả của các phép toán hợp nhất không nguyên tử. Điều này đảm bảo rằng các biến nguyên thủy 64-bit long và double được truy cập một cách nguyên tử.\n\nXem thêm CWE-413: Khóa tài nguyên không đúng, CWE-567: Truy cập dữ liệu chia sẻ không đồng bộ trong ngữ cảnh đa luồng và CWE-667: Khóa không đúng.",
      "at_nonatomic_operations_on_shared_variable": "AT: Phép toán trên biến chia sẻ không phải là nguyên tử\nViệc ghi một biến chia sẻ giữa các hàm phụ thuộc vào giá trị hiện tại của biến (hoặc vì đó là phép toán hợp nhất - ví dụ: +=, ++ - hoặc đơn giản là phụ thuộc vào giá trị hiện tại), do đó nó bao gồm nhiều phép toán riêng biệt. Các phép toán này không phải là nguyên tử và cần có sự đồng bộ hóa thêm. Xem quy tắc SEI CERT VNA02-J, CWE-366: Điều kiện đua trong một luồng, CWE-413: Khóa tài nguyên không đúng, CWE-567: Truy cập dữ liệu chia sẻ không đồng bộ trong ngữ cảnh đa luồng và CWE-667: Khóa không đúng.\n\nViệc chỉ khai báo biến là volatile không đảm bảo tính nguyên tử của các phép toán hợp nhất trên biến, nhưng đồng bộ hóa các phép ghi trên biến volatile cho các phép đọc là đủ.\nĐể giải quyết vấn đề này, đồng bộ hóa các phép toán hợp nhất và các phép ghi khác phụ thuộc vào giá trị trước đó, sử dụng khóa đọc-ghi, hoặc khai báo biến chia sẻ với kiểu nguyên tử.",
      "noise_null_dereference": "NOISE: Cảnh báo sai về việc dereference con trỏ null\nCảnh báo sai.",
      "noise_method_call": "NOISE: Cảnh báo sai về việc gọi phương thức\nCảnh báo sai.",
      "noise_field_reference": "NOISE: Cảnh báo sai về việc tham chiếu trường\nCảnh báo sai.",
      "noise_operation": "NOISE: Cảnh báo sai về một phép toán\nCảnh báo sai.",
      "hsc_huge_shared_string_constant": "HSC: Các hằng số chuỗi lớn bị trùng lặp trong nhiều tệp lớp\nMột hằng số String lớn bị trùng lặp trong nhiều tệp lớp. Điều này có thể là do một trường final được khởi tạo với một hằng số String, và ngôn ngữ Java yêu cầu tất cả các tham chiếu đến trường final từ các lớp khác phải được nội tuyến vào tệp lớp đó. Xem lỗi JDK 6447475 để mô tả sự xuất hiện của lỗi này trong JDK và cách giải quyết nó đã giảm kích thước của JDK xuống 1 megabyte.",
      "dmi_blocking_methods_on_url": "Dm: Phương thức equals và hashCode của URL là blocking\nPhương thức equals và hashCode của URL thực hiện phân giải tên miền, điều này có thể gây ảnh hưởng lớn đến hiệu suất. Xem thêm thông tin tại http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html. Hãy cân nhắc sử dụng java.net.URI thay thế.",
      "dmi_collection_of_urls": "Dm: Các Map và Set của URL có thể tốn nhiều tài nguyên hiệu suất\nPhương thức hoặc trường này sử dụng một Map hoặc Set của URL. Vì cả hai phương thức equals và hashCode của URL đều thực hiện phân giải tên miền, điều này có thể gây ảnh hưởng lớn đến hiệu suất. Xem thêm thông tin tại http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html. Hãy cân nhắc sử dụng java.net.URI thay thế.",
      "dm_string_ctor": "Dm: Phương thức gọi constructor String(String) không hiệu quả\nViệc sử dụng constructor java.lang.String(String) lãng phí bộ nhớ vì đối tượng được tạo ra sẽ không khác biệt về chức năng so với String được truyền vào như một tham số. Chỉ cần sử dụng trực tiếp String tham số.",
      "dm_string_void_ctor": "Dm: Phương thức gọi constructor String() không hiệu quả\nViệc tạo một đối tượng java.lang.String mới bằng constructor không tham số lãng phí bộ nhớ vì đối tượng được tạo ra sẽ không khác biệt về chức năng so với hằng số chuỗi rỗng ''. Java đảm bảo rằng các hằng số chuỗi giống nhau sẽ được biểu diễn bởi cùng một đối tượng String. Do đó, bạn nên sử dụng trực tiếp hằng số chuỗi rỗng.",
      "dm_string_tostring": "Dm: Phương thức gọi phương thức toString() trên một String\nGọi String.toString() là một phép toán dư thừa. Chỉ cần sử dụng String trực tiếp.",
      "dm_gc": "Dm: Thu gom rác rõ ràng; rất đáng ngờ trừ khi trong mã benchmarking\nMã gọi thu gom rác rõ ràng. Trừ khi sử dụng đặc biệt trong việc kiểm tra hiệu suất, điều này rất đáng ngờ.\n\nTrước đây, các tình huống mà người ta gọi thu gom rác trong các phương thức như close hoặc finalize đã dẫn đến các 'hố đen hiệu suất' lớn. Thu gom rác có thể tốn kém. Bất kỳ tình huống nào buộc hàng trăm hoặc hàng nghìn lần thu gom rác sẽ làm máy tính chậm lại.",
      "dm_boolean_ctor": "Dm: Phương thức gọi constructor Boolean không hiệu quả; sử dụng Boolean.valueOf(…) thay vào đó\nViệc tạo các đối tượng java.lang.Boolean mới lãng phí bộ nhớ, vì các đối tượng Boolean là bất biến và chỉ có hai giá trị hữu ích cho kiểu này. Sử dụng phương thức Boolean.valueOf() (hoặc autoboxing trong Java 5) để tạo các đối tượng Boolean thay vào đó.",
      "dm_number_ctor": "Bx: Phương thức gọi constructor Number không hiệu quả; sử dụng static valueOf thay vào đó\nViệc sử dụng new Integer(int) luôn tạo ra một đối tượng mới, trong khi Integer.valueOf(int) cho phép bộ biên dịch, thư viện lớp, hoặc JVM lưu trữ các giá trị. Việc sử dụng các giá trị đã lưu trữ tránh việc cấp phát đối tượng và mã sẽ nhanh hơn.\n\nCác giá trị từ -128 đến 127 được đảm bảo có các phiên bản đã lưu trữ và việc sử dụng valueOf nhanh hơn khoảng 3.5 lần so với việc sử dụng constructor. Đối với các giá trị ngoài phạm vi này, hiệu suất của cả hai phương pháp là như nhau.\n\nTrừ khi lớp phải tương thích với các JVM trước Java 5, hãy sử dụng autoboxing hoặc phương thức valueOf() khi tạo các đối tượng Long, Integer, Short, Character, và Byte.",
      "dm_fp_number_ctor": "Bx: Phương thức gọi constructor số thực không hiệu quả; sử dụng static valueOf thay vào đó\nViệc sử dụng new Double(double) luôn tạo ra một đối tượng mới, trong khi Double.valueOf(double) cho phép bộ biên dịch, thư viện lớp, hoặc JVM lưu trữ các giá trị. Việc sử dụng các giá trị đã lưu trữ tránh việc cấp phát đối tượng và mã sẽ nhanh hơn.\n\nTrừ khi lớp phải tương thích với các JVM trước Java 5, hãy sử dụng autoboxing hoặc phương thức valueOf() khi tạo các đối tượng Double và Float.",
      "dm_boxed_primitive_tostring": "Bx: Phương thức cấp phát một kiểu nguyên thủy được đóng gói chỉ để gọi toString\nMột kiểu nguyên thủy được đóng gói được cấp phát chỉ để gọi toString(). Cách hiệu quả hơn là chỉ sử dụng phương thức tĩnh của toString, phương thức này nhận giá trị nguyên thủy. Ví dụ:\n\nThay vì... Với điều này...\nnew Integer(1).toString() Integer.toString(1)\nnew Long(1).toString() Long.toString(1)\nnew Float(1.0).toString() Float.toString(1.0)\nnew Double(1.0).toString() Double.toString(1.0)\nnew Byte(1).toString() Byte.toString(1)\nnew Short(1).toString() Short.toString(1)\nnew Boolean(true).toString() Boolean.toString(true)",
      "dm_boxed_primitive_for_parsing": "Bx: Boxing/unboxing để phân tích một kiểu nguyên thủy\nMột kiểu nguyên thủy được đóng gói được tạo ra từ một String, chỉ để trích xuất giá trị nguyên thủy chưa được đóng gói. Hiệu quả hơn là chỉ cần gọi phương thức static parseXXX.",
      "dm_boxed_primitive_for_compare": "Bx: Boxing một kiểu nguyên thủy để so sánh\nMột kiểu nguyên thủy được đóng gói chỉ để gọi phương thức compareTo(). Hiệu quả hơn là sử dụng phương thức static compare (cho double và float từ Java 1.4, cho các kiểu nguyên thủy khác từ Java 7) hoạt động trực tiếp trên các kiểu nguyên thủy.",
      "bx_unboxed_and_coerced_for_ternary_operator": "Bx: Giá trị nguyên thủy bị unbox và ép kiểu cho toán tử ba ngôi\nGiá trị kiểu nguyên thủy được đóng gói bị unbox và chuyển đổi thành một kiểu nguyên thủy khác như một phần của việc đánh giá toán tử ba ngôi (toán tử b ? e1 : e2). Ngữ nghĩa của Java yêu cầu rằng nếu e1 và e2 là các giá trị số học đóng gói, các giá trị này sẽ bị unbox và chuyển đổi/ép kiểu thành kiểu chung của chúng (ví dụ, nếu e1 có kiểu Integer và e2 có kiểu Float, thì e1 sẽ bị unbox, chuyển thành giá trị số thực và đóng gói lại. Xem JLS Mục 15.25).",
      "bx_unboxing_immediately_reboxed": "Bx: Giá trị đóng gói bị unbox rồi ngay lập tức bị đóng gói lại\nMột giá trị đóng gói bị unbox và ngay lập tức bị đóng gói lại.",
      "bx_boxing_immediately_unboxed": "Bx: Giá trị nguyên thủy bị đóng gói rồi ngay lập tức bị unbox\nMột giá trị nguyên thủy bị đóng gói, và sau đó ngay lập tức bị unbox. Điều này có thể do việc đóng gói thủ công ở một nơi mà giá trị không đóng gói là yêu cầu, do đó buộc trình biên dịch phải ngay lập tức hủy bỏ công việc đóng gói.",
      "bx_boxing_immediately_unboxed_to_perform_coercion": "Bx: Giá trị nguyên thủy bị đóng gói rồi unbox để thực hiện ép kiểu nguyên thủy\nMột giá trị nguyên thủy đóng gói được tạo ra rồi ngay lập tức chuyển thành một kiểu nguyên thủy khác (ví dụ, new Double(d).intValue()). Chỉ cần thực hiện việc ép kiểu nguyên thủy trực tiếp (ví dụ, (int) d).\n\nXem CWE-192: Lỗi ép kiểu Integer.",
      "dm_new_for_getclass": "Dm: Phương thức cấp phát một đối tượng, chỉ để lấy đối tượng class\nPhương thức này cấp phát một đối tượng chỉ để gọi getClass() trên nó, nhằm lấy đối tượng Class của nó. Đơn giản hơn là chỉ cần truy cập thuộc tính .class của lớp.",
      "dm_nextint_via_nextdouble": "Dm: Sử dụng phương thức nextInt của Random thay vì nextDouble để tạo một số nguyên ngẫu nhiên\nNếu r là java.util.Random, bạn có thể tạo một số ngẫu nhiên từ 0 đến n-1 bằng cách sử dụng r.nextInt(n), thay vì sử dụng (int)(r.nextDouble() * n).\n\nĐối số của nextInt phải là số dương. Nếu, ví dụ, bạn muốn tạo một giá trị ngẫu nhiên từ -99 đến 0, hãy sử dụng -r.nextInt(100).",
      "ss_should_be_static": "SS: Trường không đọc: trường này có nên là static không?\nLớp này chứa một trường final thể hiện được khởi tạo với một giá trị static tại thời điểm biên dịch. Cân nhắc việc làm trường này thành static.",
      "uuf_unused_field": "UuF: Trường không được sử dụng\nTrường này không bao giờ được sử dụng. Cân nhắc việc xóa nó khỏi lớp.\n\nXem CWE-563: Gán giá trị cho biến mà không sử dụng.",
      "urf_unread_field": "UrF: Trường không đọc\nTrường này không bao giờ được đọc. Cân nhắc việc xóa nó khỏi lớp.\n\nXem CWE-563: Gán giá trị cho biến mà không sử dụng.",
      "sic_inner_should_be_static": "SIC: Nên là lớp nội tĩnh\nLớp này là lớp nội, nhưng không sử dụng tham chiếu nhúng đến đối tượng đã tạo ra nó. Tham chiếu này làm cho các thể hiện của lớp trở nên lớn hơn và có thể giữ tham chiếu đến đối tượng tạo ra nó lâu hơn cần thiết. Nếu có thể, lớp này nên được làm tĩnh.",
      "sic_inner_should_be_static_needs_this": "SIC: Có thể được tái cấu trúc thành lớp nội tĩnh\nLớp này là lớp nội, nhưng không sử dụng tham chiếu nhúng đến đối tượng đã tạo ra nó ngoài việc xây dựng đối tượng nội. Tham chiếu này làm cho các thể hiện của lớp trở nên lớn hơn và có thể giữ tham chiếu đến đối tượng tạo ra nó lâu hơn cần thiết. Nếu có thể, lớp này nên được chuyển thành lớp nội tĩnh. Vì tham chiếu đến đối tượng bên ngoài là cần thiết trong quá trình xây dựng thể hiện nội, lớp nội sẽ cần được tái cấu trúc sao cho truyền tham chiếu đến thể hiện bên ngoài vào constructor của lớp nội.",
      "sic_inner_should_be_static_anon": "SIC: Có thể được tái cấu trúc thành lớp nội tĩnh có tên\nLớp này là lớp nội, nhưng không sử dụng tham chiếu nhúng đến đối tượng đã tạo ra nó. Tham chiếu này làm cho các thể hiện của lớp trở nên lớn hơn và có thể giữ tham chiếu đến đối tượng tạo ra nó lâu hơn cần thiết. Nếu có thể, lớp này nên được chuyển thành lớp nội tĩnh. Vì các lớp nội vô danh không thể được đánh dấu là static, làm điều này sẽ yêu cầu tái cấu trúc lớp nội sao cho nó trở thành lớp nội có tên.",
      "upm_uncalled_private_method": "UPM: Phương thức private không bao giờ được gọi\nPhương thức private này không bao giờ được gọi. Mặc dù có thể phương thức sẽ được gọi thông qua reflection, nhưng có khả năng cao là phương thức không bao giờ được sử dụng và nên bị xóa.\n\nXem CWE-561: Mã chết.",
      "sbsc_use_stringbuffer_concatenation": "SBSC: Phương thức nối chuỗi sử dụng + trong vòng lặp\nPhương thức có vẻ đang xây dựng một chuỗi String bằng cách nối chuỗi trong vòng lặp. Trong mỗi lần lặp, chuỗi String được chuyển đổi thành StringBuffer/StringBuilder, nối thêm và chuyển lại thành String. Điều này có thể dẫn đến chi phí bình phương theo số vòng lặp, vì chuỗi đang phát triển bị sao chép lại trong mỗi vòng lặp.\n\nHiệu suất tốt hơn có thể đạt được bằng cách sử dụng StringBuffer (hoặc StringBuilder trong Java 5) một cách rõ ràng.\n\nVí dụ:\n\n// Đây là xấu\nString s = '';\nfor (int i = 0; i < field.length; ++i) {\n    s = s + field[i];\n}\n\n// Đây là tốt hơn\nStringBuffer buf = new StringBuffer();\nfor (int i = 0; i < field.length; ++i) {\n    buf.append(field[i]);\n}\nString s = buf.toString();",
      "iil_elements_get_length_in_loop": "IIL: Gọi NodeList.getLength() trong vòng lặp\nPhương thức gọi NodeList.getLength() trong vòng lặp và NodeList được tạo ra bởi lời gọi getElementsByTagName. NodeList này không lưu trữ chiều dài của nó, mà tính toán lại mỗi lần theo cách không tối ưu. Cân nhắc lưu chiều dài vào biến trước vòng lặp.",
      "iil_prepare_statement_in_loop": "IIL: Phương thức gọi prepareStatement trong vòng lặp\nPhương thức gọi Connection.prepareStatement trong vòng lặp với các đối số hằng số. Nếu PreparedStatement nên được thực thi nhiều lần, không có lý do gì để tái tạo nó cho mỗi vòng lặp. Di chuyển lời gọi này ra ngoài vòng lặp.",
      "iil_pattern_compile_in_loop": "IIL: Phương thức gọi Pattern.compile trong vòng lặp\nPhương thức gọi Pattern.compile trong vòng lặp với các đối số hằng số. Nếu Pattern nên được sử dụng nhiều lần, không có lý do gì để biên dịch nó cho mỗi vòng lặp. Di chuyển lời gọi này ra ngoài vòng lặp hoặc thậm chí vào trường static final.",
      "iil_pattern_compile_in_loop_indirect": "IIL: Phương thức biên dịch biểu thức chính quy trong vòng lặp\nPhương thức tạo ra cùng một biểu thức chính quy trong vòng lặp, vì vậy nó sẽ được biên dịch lại trong mỗi lần lặp. Sẽ tối ưu hơn nếu biên dịch trước biểu thức chính quy này bằng Pattern.compile ngoài vòng lặp.",
      "iio_inefficient_index_of": "IIO: Sử dụng không hiệu quả phương thức String.indexOf(String)\nMã này truyền vào một chuỗi hằng có độ dài 1 cho String.indexOf(). Sử dụng các phương thức Integer của String.indexOf() sẽ hiệu quả hơn. Ví dụ: gọi myString.indexOf('.') thay vì myString.indexOf('.')",
      "iio_inefficient_last_index_of": "IIO: Sử dụng không hiệu quả phương thức String.lastIndexOf(String)\nMã này truyền vào một chuỗi hằng có độ dài 1 cho String.lastIndexOf(). Sử dụng các phương thức Integer của String.lastIndexOf() sẽ hiệu quả hơn. Ví dụ: gọi myString.lastIndexOf('.') thay vì myString.lastIndexOf('.')",
      "ita_inefficient_to_array": "ITA: Phương thức sử dụng toArray() với đối số mảng có độ dài bằng 0\nPhương thức này sử dụng phương thức toArray() của lớp kế thừa từ Collection, và truyền vào một đối số mảng prototype có độ dài bằng 0. Sử dụng myCollection.toArray(new Foo[myCollection.size()]) sẽ hiệu quả hơn. Nếu mảng truyền vào đủ lớn để lưu trữ tất cả các phần tử trong collection, mảng đó sẽ được điền vào và trả về trực tiếp. Điều này giúp tránh phải tạo ra một mảng thứ hai (thông qua reflection) để trả về kết quả.",
      "wmi_wrong_map_iterator": "WMI: Sử dụng không hiệu quả iterator của keySet thay vì iterator của entrySet\nPhương thức này truy cập giá trị của một entry trong Map, sử dụng một key được lấy từ iterator của keySet. Sử dụng iterator trên entrySet của Map sẽ hiệu quả hơn để tránh việc tra cứu Map.get(key).",
      "um_unnecessary_math": "UM: Phương thức gọi phương thức tĩnh của lớp Math trên một giá trị hằng\nPhương thức này sử dụng một phương thức tĩnh từ java.lang.Math trên một giá trị hằng. Kết quả của phương thức này trong trường hợp này có thể được xác định tĩnh, và sẽ nhanh hơn và đôi khi chính xác hơn nếu chỉ sử dụng hằng số đó. Các phương thức phát hiện được là:\n\nPhương thức\tTham số\nabs\t-bất kỳ-\nacos\t0.0 hoặc 1.0\nasin\t0.0 hoặc 1.0\natan\t0.0 hoặc 1.0\natan2\t0.0\ncbrt\t0.0 hoặc 1.0\nceil\t-bất kỳ-\ncos\t0.0\ncosh\t0.0\nexp\t0.0 hoặc 1.0\nexpm1\t0.0\nfloor\t-bất kỳ-\nlog\t0.0 hoặc 1.0\nlog10\t0.0 hoặc 1.0\nrint\t-bất kỳ-\nround\t-bất kỳ-\nsin\t0.0\nsinh\t0.0\nsqrt\t0.0 hoặc 1.0\ntan\t0.0\ntanh\t0.0\ntoDegrees\t0.0 hoặc 1.0\ntoRadians\t0.0",
      "ima_inefficient_member_access": "IMA: Phương thức truy cập vào biến thành viên private của lớp sở hữu\nPhương thức này của một lớp nội đọc hoặc ghi vào một biến thành viên private của lớp sở hữu, hoặc gọi một phương thức private của lớp sở hữu. Biên dịch viên phải tạo ra một phương thức đặc biệt để truy cập vào biến private này, làm cho việc này kém hiệu quả hơn. Nới lỏng quyền bảo vệ biến thành viên hoặc phương thức sẽ cho phép biên dịch viên xử lý điều này như một quyền truy cập bình thường.",
      "xss_request_parameter_to_send_error": "XSS: Lỗ hổng phản chiếu cross site scripting trong trang lỗi của Servlet\nMã này ghi trực tiếp một tham số HTTP vào trang lỗi của Server (sử dụng HttpServletResponse.sendError). Việc phản chiếu đầu vào không đáng tin cậy này cho phép xảy ra lỗ hổng cross site scripting phản chiếu. Xem http://en.wikipedia.org/wiki/Cross-site_scripting để biết thêm thông tin.\n\nSpotBugs chỉ tìm kiếm các trường hợp cross site scripting rõ ràng, dễ nhận thấy. Nếu SpotBugs tìm thấy bất kỳ lỗ hổng nào, bạn gần như chắc chắn có thêm các lỗ hổng cross site scripting mà SpotBugs không báo cáo. Nếu bạn lo ngại về cross site scripting, bạn nên nghiêm túc cân nhắc sử dụng một công cụ phân tích tĩnh hoặc công cụ kiểm tra bảo mật thương mại.\n\nXem CWE-81: Trung hòa không đúng cách mã trong trang lỗi và CWE-79: Trung hòa không đúng cách đầu vào trong quá trình tạo trang web ('Cross-site Scripting').",
      "xss_request_parameter_to_servlet_writer": "XSS: Lỗ hổng cross site scripting phản chiếu trong Servlet\nMã này ghi trực tiếp một tham số HTTP vào đầu ra của Servlet, điều này cho phép xảy ra lỗ hổng cross site scripting phản chiếu. Xem http://en.wikipedia.org/wiki/Cross-site_scripting để biết thêm thông tin.\n\nSpotBugs chỉ tìm kiếm các trường hợp cross site scripting rõ ràng, dễ nhận thấy. Nếu SpotBugs tìm thấy bất kỳ lỗ hổng nào, bạn gần như chắc chắn có thêm các lỗ hổng cross site scripting mà SpotBugs không báo cáo. Nếu bạn lo ngại về cross site scripting, bạn nên nghiêm túc cân nhắc sử dụng một công cụ phân tích tĩnh hoặc công cụ kiểm tra bảo mật thương mại.\n\nXem CWE-79: Trung hòa không đúng cách đầu vào trong quá trình tạo trang web ('Cross-site Scripting').",
      "xss_request_parameter_to_jsp_writer": "XSS: Lỗ hổng cross site scripting phản chiếu trong JSP\nMã này ghi trực tiếp một tham số HTTP vào đầu ra của JSP, điều này cho phép xảy ra lỗ hổng cross site scripting. Xem http://en.wikipedia.org/wiki/Cross-site_scripting để biết thêm thông tin.\n\nSpotBugs chỉ tìm kiếm các trường hợp cross site scripting rõ ràng, dễ nhận thấy. Nếu SpotBugs tìm thấy bất kỳ lỗ hổng nào, bạn gần như chắc chắn có thêm các lỗ hổng cross site scripting mà SpotBugs không báo cáo. Nếu bạn lo ngại về cross site scripting, bạn nên nghiêm túc cân nhắc sử dụng một công cụ phân tích tĩnh hoặc công cụ kiểm tra bảo mật thương mại.\n\nXem CWE-79: Trung hòa không đúng cách đầu vào trong quá trình tạo trang web ('Cross-site Scripting').",
      "hrs_request_parameter_to_http_header": "HRS: Lỗ hổng HTTP Response Splitting\nMã này ghi trực tiếp một tham số HTTP vào tiêu đề HTTP, điều này cho phép xảy ra lỗ hổng HTTP response splitting. Xem http://en.wikipedia.org/wiki/HTTP_response_splitting để biết thêm thông tin.\n\nSpotBugs chỉ tìm kiếm các trường hợp HTTP response splitting rõ ràng, dễ nhận thấy. Nếu SpotBugs tìm thấy bất kỳ lỗ hổng nào, bạn gần như chắc chắn có thêm các lỗ hổng mà SpotBugs không báo cáo. Nếu bạn lo ngại về HTTP response splitting, bạn nên nghiêm túc cân nhắc sử dụng một công cụ phân tích tĩnh hoặc công cụ kiểm tra bảo mật thương mại.\n\nXem CWE-113: Trung hòa không đúng cách các chuỗi CRLF trong tiêu đề HTTP ('HTTP Request/Response Splitting').",
      "hrs_request_parameter_to_cookie": "HRS: HTTP cookie được tạo từ đầu vào không đáng tin cậy\nMã này tạo một HTTP Cookie từ một tham số HTTP không đáng tin cậy. Nếu cookie này được thêm vào phản hồi HTTP, nó sẽ cho phép xảy ra lỗ hổng HTTP response splitting. Xem http://en.wikipedia.org/wiki/HTTP_response_splitting để biết thêm thông tin.\n\nSpotBugs chỉ tìm kiếm các trường hợp HTTP response splitting rõ ràng, dễ nhận thấy. Nếu SpotBugs tìm thấy bất kỳ lỗ hổng nào, bạn gần như chắc chắn có thêm các lỗ hổng mà SpotBugs không báo cáo. Nếu bạn lo ngại về HTTP response splitting, bạn nên nghiêm túc cân nhắc sử dụng một công cụ phân tích tĩnh hoặc công cụ kiểm tra bảo mật thương mại.\n\nXem CWE-113: Trung hòa không đúng cách các chuỗi CRLF trong tiêu đề HTTP ('HTTP Request/Response Splitting').",
      "pt_absolute_path_traversal": "PT: Tấn công vượt qua đường dẫn tuyệt đối trong servlet\nPhần mềm sử dụng tham số yêu cầu HTTP để tạo ra một đường dẫn tệp mà lẽ ra phải nằm trong một thư mục hạn chế, nhưng không trung hòa đúng cách các chuỗi đường dẫn tuyệt đối như '/abs/path' có thể dẫn đến vị trí ngoài thư mục đó. Xem http://cwe.mitre.org/data/definitions/36.html để biết thêm thông tin.\n\nSpotBugs chỉ tìm kiếm các trường hợp vượt qua đường dẫn tuyệt đối rõ ràng, dễ nhận thấy. Nếu SpotBugs tìm thấy bất kỳ lỗ hổng nào, bạn gần như chắc chắn có thêm các lỗ hổng mà SpotBugs không báo cáo. Nếu bạn lo ngại về tấn công vượt qua đường dẫn tuyệt đối, bạn nên nghiêm túc cân nhắc sử dụng một công cụ phân tích tĩnh hoặc công cụ kiểm tra bảo mật thương mại.\n\nXem CWE-36: Tấn công vượt qua đường dẫn tuyệt đối.",
      "pt_relative_path_traversal": "PT: Tấn công vượt qua đường dẫn tương đối trong servlet\nPhần mềm sử dụng tham số yêu cầu HTTP để tạo ra một đường dẫn tệp mà lẽ ra phải nằm trong một thư mục hạn chế, nhưng không trung hòa đúng cách các chuỗi như '..' có thể dẫn đến vị trí ngoài thư mục đó. Xem http://cwe.mitre.org/data/definitions/23.html để biết thêm thông tin.\n\nSpotBugs chỉ tìm kiếm các trường hợp vượt qua đường dẫn tương đối rõ ràng, dễ nhận thấy. Nếu SpotBugs tìm thấy bất kỳ lỗ hổng nào, bạn gần như chắc chắn có thêm các lỗ hổng mà SpotBugs không báo cáo. Nếu bạn lo ngại về tấn công vượt qua đường dẫn tương đối, bạn nên nghiêm túc cân nhắc sử dụng một công cụ phân tích tĩnh hoặc công cụ kiểm tra bảo mật thương mại.\n\nXem CWE-23: Tấn công vượt qua đường dẫn tương đối.",
      "dmi_constant_db_password": "Dm: Mật khẩu cơ sở dữ liệu cứng mã hóa\nMã này tạo kết nối cơ sở dữ liệu sử dụng mật khẩu cứng mã hóa, tức là mật khẩu đã được mã hóa và đặt cố định trong mã nguồn. Mọi người có quyền truy cập vào mã nguồn hoặc mã biên dịch có thể dễ dàng biết được mật khẩu này.\n\nXem CWE-259: Sử dụng mật khẩu cứng mã hóa.",
      "dmi_empty_db_password": "Dm: Mật khẩu cơ sở dữ liệu trống\nMã này tạo kết nối cơ sở dữ liệu sử dụng mật khẩu trống. Điều này cho thấy cơ sở dữ liệu không được bảo vệ bằng mật khẩu.\n\nXem CWE-259: Sử dụng mật khẩu cứng mã hóa.",
      "sql_nonconstant_string_passed_to_execute": "SQL: Dãy chuỗi không cố định được truyền vào phương thức execute hoặc addBatch trên một câu lệnh SQL\nPhương thức này gọi phương thức execute hoặc addBatch trên một câu lệnh SQL với một chuỗi có vẻ được tạo động. Cân nhắc sử dụng prepared statement thay vào đó. Cách này hiệu quả hơn và ít bị tấn công SQL injection hơn.\n\nXem CWE-89: Trung hòa không đúng cách các phần tử đặc biệt sử dụng trong lệnh SQL ('SQL Injection').",
      "sql_prepared_statement_generated_from_nonconstant_string": "SQL: Một prepared statement được tạo từ chuỗi không cố định\nMã này tạo một prepared statement SQL từ một chuỗi không cố định. Nếu không kiểm tra, dữ liệu bị nhiễm từ người dùng có thể được sử dụng để xây dựng chuỗi này, từ đó có thể thực hiện tấn công SQL injection để làm câu lệnh thực thi những hành động không mong muốn.\n\nXem CWE-89: Trung hòa không đúng cách các phần tử đặc biệt sử dụng trong lệnh SQL ('SQL Injection').",
      "ase_assertion_with_side_effect": "ASE: Biểu thức trong assertion có thể tạo ra tác dụng phụ\nCác biểu thức sử dụng trong assertion không được tạo ra tác dụng phụ.\n\nXem SEI CERT Rule EXP06 để biết thêm thông tin.",
      "ase_assertion_with_side_effect_method": "ASE: Phương thức gọi trong assertion có thể tạo ra tác dụng phụ\nCác biểu thức sử dụng trong assertion không được tạo ra tác dụng phụ.\n\nXem SEI CERT Rule EXP06 để biết thêm thông tin.",
      "caa_covariant_array_field": "CAA: Gán mảng đồng nhất vào một trường\nMảng có kiểu đồng nhất được gán vào một trường. Điều này gây nhầm lẫn và có thể dẫn đến lỗi ArrayStoreException tại thời gian chạy nếu tham chiếu của một kiểu khác được lưu trong mảng này sau đó, như trong mã dưới đây:\n\nNumber[] arr = new Integer[10];\narr[0] = 1.0;\nCân nhắc thay đổi kiểu mảng được tạo hoặc kiểu trường.",
      "caa_covariant_array_return": "CAA: Mảng đồng nhất được trả về từ phương thức\nMảng có kiểu đồng nhất được trả về từ phương thức. Điều này gây nhầm lẫn và có thể dẫn đến lỗi ArrayStoreException tại thời gian chạy nếu mã gọi thử lưu tham chiếu của một kiểu khác vào mảng trả về.\n\nCân nhắc thay đổi kiểu mảng được tạo hoặc kiểu trả về của phương thức.",
      "caa_covariant_array_local": "CAA: Gán mảng đồng nhất vào biến cục bộ\nMảng có kiểu đồng nhất được gán vào một biến cục bộ. Điều này gây nhầm lẫn và có thể dẫn đến lỗi ArrayStoreException tại thời gian chạy nếu tham chiếu của một kiểu khác sẽ được lưu vào mảng này sau đó, như trong mã dưới đây:\n\nNumber[] arr = new Integer[10];\narr[0] = 1.0;\nCân nhắc thay đổi kiểu mảng được tạo hoặc kiểu biến cục bộ.",
      "dmi_unsupported_method": "Dm: Gọi phương thức không được hỗ trợ\nTất cả các mục tiêu của lời gọi phương thức này đều ném ra một UnsupportedOperationException.",
      "dmi_thread_passed_where_runnable_expected": "Dm: Truyền đối tượng Thread nơi cần một Runnable\nMột đối tượng Thread được truyền dưới dạng tham số cho phương thức nơi một Runnable được mong đợi. Điều này khá bất thường và có thể chỉ ra lỗi logic hoặc gây ra hành vi không mong muốn.",
      "np_dereference_of_readline_value": "NP: Truy xuất kết quả của readLine() mà không kiểm tra null\nKết quả của việc gọi readLine() được truy xuất mà không kiểm tra xem kết quả có phải là null không. Nếu không còn dòng văn bản nào để đọc, readLine() sẽ trả về null và việc truy xuất kết quả này sẽ gây ra ngoại lệ null pointer.",
      "np_immediate_dereference_of_readline": "NP: Truy xuất ngay lập tức kết quả của readLine()\nKết quả của việc gọi readLine() được truy xuất ngay lập tức. Nếu không còn dòng văn bản nào để đọc, readLine() sẽ trả về null và việc truy xuất kết quả này sẽ gây ra ngoại lệ null pointer.",
      "rv_rem_of_random_int": "RV: Số dư của số nguyên ngẫu nhiên 32-bit có dấu\nMã này tạo ra một số nguyên ngẫu nhiên có dấu và sau đó tính toán số dư của giá trị đó chia cho một giá trị khác. Vì số ngẫu nhiên có thể là số âm, kết quả của phép toán số dư cũng có thể là số âm. Hãy chắc chắn rằng điều này là có ý định, và nên xem xét sử dụng phương thức Random.nextInt(int) thay vì.",
      "rv_rem_of_hashcode": "RV: Số dư của hashCode có thể là số âm\nMã này tính toán hashCode, và sau đó tính toán số dư của giá trị đó chia cho một giá trị khác. Vì hashCode có thể là số âm, kết quả của phép toán số dư cũng có thể là số âm.\n\nGiả sử bạn muốn đảm bảo rằng kết quả của phép tính của bạn không phải là số âm, bạn có thể cần thay đổi mã của mình. Nếu bạn biết rằng số chia là một số mũ của 2, bạn có thể sử dụng toán tử AND bitwise thay thế (ví dụ: thay vì sử dụng x.hashCode()%n, hãy sử dụng x.hashCode()&(n-1)). Cách này có thể nhanh hơn việc tính toán số dư. Nếu bạn không biết rằng số chia là một số mũ của 2, hãy lấy giá trị tuyệt đối của kết quả phép toán số dư (ví dụ: sử dụng Math.abs(x.hashCode()%n)).",
      "eq_unusual": "Eq: Phương thức equals bất thường\nLớp này không thực hiện bất kỳ mẫu nào mà chúng tôi nhận ra để kiểm tra xem kiểu của đối số có tương thích với kiểu của đối tượng này không. Có thể không có vấn đề gì với mã này, nhưng vẫn đáng để xem xét lại.",
      "eq_doesnt_override_equals": "Eq: Lớp không ghi đè phương thức equals trong lớp cha\nLớp này mở rộng một lớp định nghĩa phương thức equals và thêm các trường, nhưng không định nghĩa phương thức equals của chính nó. Do đó, sự so sánh sự bằng nhau trên các thể hiện của lớp này sẽ bỏ qua bản chất của lớp con và các trường đã thêm. Hãy chắc chắn rằng đây là điều bạn mong muốn, và bạn không cần ghi đè phương thức equals. Ngay cả khi bạn không cần ghi đè phương thức equals, hãy cân nhắc ghi đè nó để tài liệu hóa rằng phương thức equals của lớp con chỉ trả về kết quả của việc gọi super.equals(o).",
      "ns_non_short_circuit": "NS: Sử dụng logic không ngắt mạch đáng ngờ\nMã này có vẻ đang sử dụng logic không ngắt mạch (ví dụ: & hoặc",
      "ns_dangerous_non_short_circuit": "NS: Sử dụng logic không ngắt mạch có thể nguy hiểm\nMã này có vẻ đang sử dụng logic không ngắt mạch (ví dụ: & hoặc",
      "ic_init_circularity": "IC: Vòng lặp khởi tạo\nMột vòng lặp đã được phát hiện trong các trình khởi tạo tĩnh của hai lớp được tham chiếu bởi trường hợp lỗi. Nhiều loại hành vi bất ngờ có thể phát sinh từ vòng lặp như vậy.",
      "ia_ambiguous_invocation_of_inherited_or_outer_method": "IA: Gọi phương thức có thể gây nhầm lẫn giữa phương thức kế thừa hoặc phương thức bên ngoài\nMột lớp con đang gọi một phương thức có thể được giải quyết là phương thức kế thừa hoặc phương thức được định nghĩa trong lớp bên ngoài. Ví dụ, bạn gọi foo(17), phương thức này được định nghĩa trong cả lớp cha và trong phương thức bên ngoài. Theo nghĩa ngữ pháp Java, nó sẽ được giải quyết để gọi phương thức kế thừa, nhưng điều này có thể không phải là điều bạn mong muốn.\n\nNếu bạn thực sự muốn gọi phương thức kế thừa, hãy gọi nó bằng cách gọi phương thức trên super (ví dụ: gọi super.foo(17)), và như vậy sẽ rõ ràng với những người đọc mã của bạn và với SpotBugs rằng bạn muốn gọi phương thức kế thừa, không phải phương thức trong lớp bên ngoài.\n\nNếu bạn gọi this.foo(17), thì phương thức kế thừa sẽ được gọi. Tuy nhiên, vì SpotBugs chỉ xem các file class, nó không thể phân biệt giữa việc gọi this.foo(17) và foo(17), nó sẽ vẫn cảnh báo về việc gọi phương thức có thể gây nhầm lẫn.",
      "se_private_read_resolve_not_inherited": "Se: Phương thức readResolve riêng tư không được kế thừa bởi lớp con\nLớp này định nghĩa phương thức readResolve riêng tư. Vì nó là riêng tư, nó sẽ không được kế thừa bởi các lớp con. Điều này có thể là cố ý và đúng, nhưng cần được xem xét lại để đảm bảo rằng đó là điều bạn mong muốn.",
      "se_transient_field_of_nonserializable_class": "Se: Trường transient của lớp không phải là Serializable\nTrường này được đánh dấu là transient, nhưng lớp không phải là Serializable, vì vậy việc đánh dấu nó là transient hoàn toàn không có tác dụng. Đây có thể là dấu vết của việc đánh dấu từ một phiên bản trước của mã mà lớp đó là Serializable, hoặc có thể chỉ ra sự hiểu nhầm về cách hoạt động của serialization.\n\nLỗi này chỉ được báo cáo nếu tùy chọn đặc biệt reportTransientFieldOfNonSerializableClass được thiết lập.\n\nXem CWE-1066: Thiếu phần tử kiểm soát Serialization.",
      "sf_switch_fallthrough": "SF: Phát hiện câu lệnh switch mà một nhánh bị rơi vào nhánh tiếp theo\nPhương thức này chứa một câu lệnh switch mà một nhánh sẽ rơi vào nhánh tiếp theo. Thông thường, bạn cần kết thúc nhánh này bằng một lệnh break hoặc return.\n\nXem CWE-484: Thiếu lệnh Break trong Switch.",
      "sf_switch_no_default": "SF: Phát hiện câu lệnh switch mà thiếu case mặc định\nPhương thức này chứa một câu lệnh switch mà thiếu case mặc định. Thông thường, bạn cần phải cung cấp một case mặc định.\n\nVì phân tích chỉ xem xét bytecode được tạo ra, cảnh báo này có thể bị kích hoạt sai nếu case mặc định nằm ở cuối câu lệnh switch và câu lệnh switch không chứa các lệnh break cho các trường hợp khác.\n\nXem CWE-478: Thiếu Case Mặc Định trong Biểu Thức Điều Kiện Nhiều.",
      "uuf_unused_public_or_protected_field": "UuF: Trường công khai hoặc bảo vệ không sử dụng\nTrường này không bao giờ được sử dụng. Trường này là công khai hoặc bảo vệ, vì vậy có thể nó dự định sẽ được sử dụng với các lớp không được xem như một phần của phân tích. Nếu không, hãy xem xét xóa nó khỏi lớp.\n\nXem CWE-563: Gán giá trị cho Biến mà không Sử dụng.",
      "urf_unread_public_or_protected_field": "UrF: Trường công khai/bảo vệ không được đọc\nTrường này không bao giờ được đọc. Trường này là công khai hoặc bảo vệ, vì vậy có thể nó dự định sẽ được sử dụng với các lớp không được xem như một phần của phân tích. Nếu không, hãy xem xét xóa nó khỏi lớp.\n\nXem CWE-563: Gán giá trị cho Biến mà không Sử dụng.",
      "qf_questionable_for_loop": "QF: Tăng giảm biến phức tạp, tinh vi hoặc sai trong vòng lặp for\nBạn có chắc rằng vòng lặp for này đang tăng/giảm đúng biến không? Có vẻ như một biến khác đang được khởi tạo và kiểm tra bởi vòng lặp for.",
      "np_unwritten_public_or_protected_field": "NP: Đọc trường công khai hoặc bảo vệ chưa được ghi\nChương trình đang giải tham chiếu một trường công khai hoặc bảo vệ mà dường như không bao giờ có giá trị không null được ghi vào đó. Trừ khi trường này được khởi tạo thông qua một cơ chế không được phân tích, việc giải tham chiếu giá trị này sẽ tạo ra lỗi null pointer exception.\n\nXem CWE-457: Sử dụng Biến chưa được Khởi tạo.",
      "uwf_field_not_initialized_in_constructor": "UwF: Trường không được khởi tạo trong constructor nhưng lại giải tham chiếu mà không kiểm tra null\nTrường này không bao giờ được khởi tạo trong bất kỳ constructor nào, và vì vậy có thể là null sau khi đối tượng được tạo. Ở những nơi khác, nó được tải và giải tham chiếu mà không kiểm tra null. Điều này có thể là một lỗi hoặc một thiết kế đáng ngờ, vì điều này có nghĩa là một null pointer exception sẽ được tạo ra nếu trường này bị giải tham chiếu trước khi được khởi tạo.\n\nXem CWE-457: Sử dụng Biến chưa được Khởi tạo.",
      "uwf_unwritten_public_or_protected_field": "UwF: Trường công khai hoặc bảo vệ chưa được ghi\nKhông có ghi nào vào trường công khai/bảo vệ này. Tất cả các lần đọc nó sẽ trả về giá trị mặc định. Kiểm tra xem có lỗi không (nó lẽ ra phải được khởi tạo?), hoặc xóa nó nếu nó vô dụng.\n\nXem CWE-457: Sử dụng Biến chưa được Khởi tạo.",
      "uc_useless_void_method": "UC: Phương thức void không có tác dụng hữu ích\nPhân tích của chúng tôi cho thấy rằng phương thức void không rỗng này thực sự không thực hiện bất kỳ công việc hữu ích nào. Vui lòng kiểm tra lại nó: có thể có lỗi trong mã của nó hoặc phần thân của nó có thể bị xóa hoàn toàn.\n\nChúng tôi đang cố gắng giảm thiểu các cảnh báo sai càng nhiều càng tốt, nhưng trong một số trường hợp, cảnh báo này có thể sai. Những trường hợp cảnh báo sai phổ biến bao gồm:\n\n- Phương thức được thiết kế để kích hoạt việc tải một lớp nào đó có thể có tác dụng phụ.\n- Phương thức được thiết kế để ném ra một ngoại lệ không rõ ràng.",
      "uc_useless_condition": "UC: Điều kiện không có tác dụng\nĐiều kiện này luôn tạo ra cùng một kết quả như giá trị của biến tham gia đã được thu hẹp trước đó. Có thể điều gì đó khác đã được dự định hoặc điều kiện này có thể bị xóa.\n\nXem CWE-570: Biểu Thức Luôn Sai và CWE-571: Biểu Thức Luôn Đúng.",
      "uc_useless_condition_type": "UC: Điều kiện không có tác dụng do loại biến\nĐiều kiện này luôn tạo ra cùng một kết quả do phạm vi kiểu của biến tham gia. Có thể điều gì đó khác đã được dự định hoặc điều kiện này có thể bị xóa.\n\nXem CWE-570: Biểu Thức Luôn Sai và CWE-571: Biểu Thức Luôn Đúng.",
      "uc_useless_object": "UC: Đối tượng vô dụng được tạo ra\nPhân tích của chúng tôi cho thấy đối tượng này là vô dụng. Nó được tạo ra và sửa đổi, nhưng giá trị của nó không bao giờ ra ngoài phương thức hoặc gây ra bất kỳ tác dụng phụ nào. Có thể có một lỗi và đối tượng này lẽ ra phải được sử dụng, hoặc nó có thể bị xóa.\n\nPhân tích này hiếm khi tạo ra cảnh báo sai. Các trường hợp cảnh báo sai phổ biến bao gồm:\n\n- Đối tượng này đã được sử dụng để ném ra một ngoại lệ mơ hồ.\n\n- Đối tượng này được sử dụng như một stub để tổng quát hóa mã.\n\n- Đối tượng này được sử dụng để giữ các tham chiếu mạnh đến các đối tượng có tham chiếu yếu/mềm.",
      "uc_useless_object_stack": "UC: Đối tượng vô dụng được tạo ra trên stack\nĐối tượng này được tạo ra chỉ để thực hiện một số sửa đổi mà không có tác dụng phụ. Có thể có một điều gì đó khác đã được dự định hoặc đối tượng này có thể bị xóa.",
      "rv_return_value_ignored_inferred": "RV: Phương thức bỏ qua giá trị trả về, điều này có ổn không?\nĐoạn mã này gọi một phương thức và bỏ qua giá trị trả về. Giá trị trả về có cùng kiểu với kiểu của đối tượng mà phương thức được gọi trên đó, và từ phân tích của chúng tôi, có vẻ như giá trị trả về có thể quan trọng (ví dụ, như bỏ qua giá trị trả về của String.toLowerCase()).\n\nChúng tôi đoán rằng việc bỏ qua giá trị trả về có thể là một ý tưởng tồi chỉ từ một phân tích đơn giản về thân của phương thức. Bạn có thể sử dụng chú thích @CheckReturnValue để chỉ đạo SpotBugs rằng bỏ qua giá trị trả về của phương thức này là chấp nhận được.\n\nVui lòng xem xét kỹ điều này để quyết định liệu việc bỏ qua giá trị trả về có ổn không.",
      "rv_return_value_ignored_no_side_effect": "RV: Giá trị trả về của phương thức không có tác dụng phụ bị bỏ qua\nĐoạn mã này gọi một phương thức và bỏ qua giá trị trả về. Tuy nhiên, phân tích của chúng tôi cho thấy rằng phương thức (bao gồm cả các cài đặt của nó trong các lớp con nếu có) không tạo ra bất kỳ tác dụng nào ngoài giá trị trả về. Vì vậy, gọi phương thức này có thể bị xóa.\n\nChúng tôi đang cố gắng giảm thiểu các cảnh báo sai càng nhiều càng tốt, nhưng trong một số trường hợp, cảnh báo này có thể sai. Các trường hợp cảnh báo sai phổ biến bao gồm:\n\n- Phương thức được thiết kế để bị ghi đè và tạo ra một tác dụng phụ trong các dự án khác ngoài phạm vi phân tích.\n\n- Phương thức được gọi để kích hoạt việc tải lớp có thể có tác dụng phụ.\n\n- Phương thức được gọi chỉ để lấy một ngoại lệ.\n\nNếu bạn cảm thấy giả định của chúng tôi là sai, bạn có thể sử dụng chú thích @CheckReturnValue để chỉ đạo SpotBugs rằng bỏ qua giá trị trả về của phương thức này là chấp nhận được.",
      "rv_check_for_positive_indexof": "RV: Phương thức kiểm tra xem kết quả của String.indexOf có phải là số dương\nPhương thức này gọi String.indexOf và kiểm tra xem kết quả có phải là số dương hay không. Thông thường, bạn sẽ kiểm tra xem kết quả có phải là số âm hay không. Nó chỉ dương nếu chuỗi con kiểm tra xuất hiện ở một vị trí khác ngoài đầu của chuỗi.",
      "rv_dont_just_null_check_readline": "RV: Phương thức loại bỏ kết quả của readLine sau khi kiểm tra xem nó có phải là không null\nGiá trị trả về bởi readLine bị loại bỏ sau khi kiểm tra xem giá trị trả về có phải là không null. Trong hầu hết các tình huống, nếu kết quả là không null, bạn sẽ muốn sử dụng giá trị không null đó. Gọi readLine một lần nữa sẽ cho bạn một dòng khác.",
      "np_parameter_must_be_nonnull_but_marked_as_nullable": "NP: Tham số phải là không null nhưng lại được đánh dấu là nullable\nTham số này luôn được sử dụng theo cách yêu cầu nó phải là không null, nhưng tham số này lại được chú thích là Nullable. Hoặc là việc sử dụng tham số này hoặc là chú thích này là sai.",
      "np_null_on_some_path_from_return_value": "NP: Có thể dereference null pointer do giá trị trả về của phương thức gọi\nGiá trị trả về từ một phương thức bị dereference mà không kiểm tra null, và giá trị trả về của phương thức đó là giá trị mà thông thường cần phải kiểm tra null. Điều này có thể dẫn đến NullPointerException khi mã được thực thi.",
      "np_null_on_some_path_might_be_infeasible": "NP: Có thể dereference null pointer trên nhánh có thể không thể thực thi\nCó một nhánh của câu lệnh mà, nếu được thực thi, đảm bảo rằng một giá trị null sẽ bị dereference, điều này sẽ tạo ra NullPointerException khi mã được thực thi. Tất nhiên, vấn đề có thể là nhánh hoặc câu lệnh đó không thể thực thi và ngoại lệ null pointer không bao giờ có thể được thực thi; việc quyết định điều này vượt quá khả năng của SpotBugs. Do giá trị này đã được kiểm tra null trước đó, đây là một khả năng chắc chắn.",
      "np_load_of_known_null_value": "NP: Tải giá trị null đã biết\nBiến được tham chiếu tại điểm này được biết là null do đã kiểm tra null trước đó. Mặc dù điều này hợp lệ, nhưng có thể đây là một lỗi (có thể bạn đã định tham chiếu đến một biến khác, hoặc có thể kiểm tra trước đó xem biến có phải là null đáng lẽ phải là kiểm tra xem nó có phải là không null).",
      "pzla_prefer_zero_length_arrays": "PZLA: Cân nhắc trả về mảng có độ dài bằng không thay vì null\nThông thường, một thiết kế tốt hơn là trả về mảng có độ dài bằng không thay vì một tham chiếu null để chỉ ra rằng không có kết quả (tức là danh sách kết quả rỗng). Cách này sẽ không cần kiểm tra null rõ ràng bởi các client của phương thức.\n\nMặt khác, sử dụng null để chỉ ra 'không có câu trả lời cho câu hỏi này' có thể là hợp lý. Ví dụ, File.listFiles() trả về một danh sách rỗng nếu thư mục không chứa tệp nào và trả về null nếu thư mục không phải là một thư mục.",
      "ucf_useless_control_flow": "UCF: Dòng điều khiển vô dụng\nPhương thức này chứa một câu lệnh điều khiển vô dụng, trong đó dòng điều khiển tiếp tục vào cùng một vị trí bất kể nhánh có được thực thi hay không. Ví dụ, điều này xảy ra khi có một khối câu lệnh rỗng cho một câu lệnh if:\n\nif (argv.length == 0) {\n    // TODO: xử lý trường hợp này\n}",
      "ucf_useless_control_flow_next_line": "UCF: Dòng điều khiển vô dụng tới dòng tiếp theo\nPhương thức này chứa một câu lệnh điều khiển vô dụng, trong đó dòng điều khiển tiếp tục vào cùng một dòng hoặc dòng tiếp theo bất kể nhánh có được thực thi hay không. Thường thì điều này xảy ra do vô tình sử dụng câu lệnh rỗng làm thân của câu lệnh if, ví dụ:\n\nif (argv.length == 1);\n    System.out.println('Hello, ' + argv[0]);",
      "rcn_redundant_nullcheck_of_null_value": "RCN: Kiểm tra null thừa cho giá trị đã biết là null\nPhương thức này chứa một kiểm tra thừa cho một giá trị đã biết là null so với hằng số null.",
      "rcn_redundant_nullcheck_of_nonnull_value": "RCN: Kiểm tra null thừa cho giá trị đã biết là không null\nPhương thức này chứa một kiểm tra thừa cho một giá trị đã biết là không null so với hằng số null.",
      "rcn_redundant_comparison_two_null_values": "RCN: So sánh thừa hai giá trị null\nPhương thức này chứa một so sánh thừa giữa hai tham chiếu đã biết là đều chắc chắn là null.",
      "rcn_redundant_comparison_of_null_and_nonnull_value": "RCN: So sánh thừa giá trị không null với null\nPhương thức này chứa một tham chiếu đã biết là không null với một tham chiếu đã biết là null.",
      "sa_local_self_assignment": "SA: Gán giá trị cho biến cục bộ của chính nó\nPhương thức này chứa một gán giá trị cho biến cục bộ của chính nó; ví dụ:\n\npublic void foo() {\n    int x = 3;\n    x = x;\n}\nNhững phép gán như vậy là vô dụng và có thể chỉ ra một lỗi logic hoặc lỗi đánh máy.",
      "int_bad_rem_by_1": "INT: Lấy phần dư của số nguyên với 1\nMọi biểu thức (exp % 1) đều chắc chắn trả về giá trị bằng không. Bạn có ý định sử dụng (exp & 1) hoặc (exp % 2) thay thế không?",
      "int_vacuous_comparison": "INT: So sánh số nguyên vô ích\nCó một phép so sánh số nguyên luôn trả về cùng một giá trị (ví dụ, x <= Integer.MAX_VALUE).",
      "int_vacuous_bit_operation": "INT: Phép toán bitmask vô ích trên giá trị số nguyên\nĐây là phép toán bit (và, hoặc, hoặc loại trừ) trên số nguyên không thực hiện công việc hữu ích nào (ví dụ, v & 0xffffffff).",
      "sa_local_double_assignment": "SA: Gán giá trị đôi cho biến cục bộ\nPhương thức này chứa một phép gán giá trị đôi cho một biến cục bộ; ví dụ:\n\npublic void foo() {\n    int x,y;\n    x = x = 17;\n}\nGán cùng một giá trị cho một biến hai lần là vô ích và có thể chỉ ra lỗi logic hoặc lỗi đánh máy.",
      "sa_field_double_assignment": "SA: Gán giá trị đôi cho trường\nPhương thức này chứa một phép gán giá trị đôi cho một trường; ví dụ:\n\nint x,y;\npublic void foo() {\n    x = x = 17;\n}\nGán giá trị cho một trường hai lần là vô ích và có thể chỉ ra lỗi logic hoặc lỗi đánh máy.",
      "dls_dead_local_store_in_return": "DLS: Gán vô ích trong câu lệnh return\nCâu lệnh này gán giá trị cho một biến cục bộ trong câu lệnh return. Phép gán này không có tác dụng. Vui lòng xác minh xem câu lệnh này có thực hiện đúng chức năng hay không.\n\nXem CWE-563: Gán giá trị cho biến mà không sử dụng.",
      "dls_dead_local_store": "DLS: Dead store cho biến cục bộ\nCâu lệnh này gán một giá trị cho biến cục bộ, nhưng giá trị đó không được đọc hoặc sử dụng trong bất kỳ câu lệnh nào sau đó. Thường thì điều này chỉ ra một lỗi, vì giá trị được tính toán không bao giờ được sử dụng.\n\nLưu ý rằng trình biên dịch javac của Sun thường tạo ra dead stores cho các biến cục bộ cuối cùng. Vì SpotBugs là công cụ dựa trên bytecode, không có cách dễ dàng để loại bỏ các false positives này.\n\nXem CWE-563: Gán giá trị cho biến mà không sử dụng.",
      "dls_dead_local_store_shadows_field": "DLS: Dead store cho biến cục bộ che khuất trường\nCâu lệnh này gán một giá trị cho biến cục bộ, nhưng giá trị đó không được đọc hoặc sử dụng trong bất kỳ câu lệnh nào sau đó. Thường thì điều này chỉ ra một lỗi, vì giá trị được tính toán không bao giờ được sử dụng. Có một trường với cùng tên như biến cục bộ. Bạn có phải muốn gán giá trị cho biến đó thay vì không?\n\nXem CWE-563: Gán giá trị cho biến mà không sử dụng.",
      "dls_dead_local_store_of_null": "DLS: Dead store của null vào biến cục bộ\nMã lưu trữ giá trị null vào một biến cục bộ, và giá trị được lưu không được đọc. Lưu trữ này có thể đã được thêm vào để hỗ trợ garbage collector, nhưng kể từ Java SE 6.0, điều này không còn cần thiết hoặc hữu ích nữa.\n\nXem CWE-563: Gán giá trị cho biến mà không sử dụng.",
      "rec_catch_exception": "REC: Bắt ngoại lệ khi ngoại lệ không được ném ra\nPhương thức này sử dụng một khối try-catch bắt các đối tượng Exception, nhưng Exception không được ném ra trong khối try, và RuntimeException không được bắt rõ ràng. Đây là một mô hình lỗi phổ biến khi viết try { ... } catch (Exception e) { something } như một cách rút gọn để bắt nhiều loại ngoại lệ, mỗi khối catch đều giống nhau, nhưng cấu trúc này cũng vô tình bắt RuntimeException, che giấu các lỗi tiềm ẩn.\n\nMột cách tiếp cận tốt hơn là bắt rõ ràng các ngoại lệ cụ thể được ném ra, hoặc bắt rõ ràng ngoại lệ RuntimeException, ném lại nó và sau đó bắt tất cả các ngoại lệ không phải Runtime, như sau:\n\ntry {\n    ...\n} catch (RuntimeException e) {\n    throw e;\n} catch (Exception e) {\n    ... xử lý tất cả các ngoại lệ không phải runtime ...\n}\nXem CWE-396: Khai báo bắt cho ngoại lệ tổng quát.",
      "dcn_nullpointer_exception": "DCN: Đã bắt NullPointerException\nTheo quy tắc SEI Cert ERR08-J, NullPointerException không nên được bắt. Việc xử lý NullPointerException được coi là lựa chọn kém hơn so với việc kiểm tra null.\n\nMã không tuân thủ này bắt một NullPointerException để kiểm tra xem tham số đầu vào có phải là null hay không:\n\n\nboolean hasSpace(String m) {\n  try {\n    String ms[] = m.split(' ');\n    return names.length != 1;\n  } catch (NullPointerException e) {\n    return false;\n  }\n}\nGiải pháp tuân thủ sẽ sử dụng kiểm tra null như trong ví dụ sau:\n\n\nboolean hasSpace(String m) {\n    if (m == null) return false;\n    String ms[] = m.split(' ');\n    return names.length != 1;\n}\nXem CWE-395: Sử dụng Catch NullPointerException để phát hiện dereference NULL Pointer.",
      "fe_floating_point_equality": "FE: Kiểm tra sự bằng nhau của số thực dấu phẩy động\nPhép toán này so sánh hai giá trị dấu phẩy động để kiểm tra sự bằng nhau. Vì các phép tính dấu phẩy động có thể liên quan đến làm tròn, các giá trị float và double tính toán có thể không chính xác. Đối với các giá trị cần chính xác, như giá trị tiền tệ, hãy xem xét sử dụng kiểu dữ liệu có độ chính xác cố định như BigDecimal. Đối với các giá trị không cần chính xác, hãy xem xét so sánh sự bằng nhau trong một phạm vi nhất định, ví dụ: if ( Math.abs(x - y) < .0000001 ). Xem Java Language Specification, phần 4.2.4.",
      "cd_circular_dependency": "CD: Kiểm tra sự phụ thuộc vòng giữa các lớp\nLớp này có sự phụ thuộc vòng với các lớp khác. Điều này khiến việc xây dựng các lớp này trở nên khó khăn, vì mỗi lớp phụ thuộc vào lớp khác để xây dựng chính xác. Hãy xem xét sử dụng giao diện để phá vỡ sự phụ thuộc cứng này.",
      "ri_redundant_interfaces": "RI: Lớp thực thi cùng giao diện như lớp cha\nLớp này khai báo rằng nó thực thi một giao diện mà lớp cha cũng đã thực thi. Điều này là dư thừa vì khi một lớp cha thực thi giao diện, tất cả các lớp con theo mặc định cũng thực thi giao diện này. Điều này có thể chỉ ra rằng cấu trúc kế thừa đã thay đổi kể từ khi lớp này được tạo ra, và cần xem xét quyền sở hữu việc thực thi giao diện.",
      "mtia_suspect_struts_instance_field": "MTIA: Lớp mở rộng từ lớp Struts Action và sử dụng biến thể hiện\nLớp này mở rộng từ lớp Struts Action và sử dụng biến thành viên thể hiện. Vì chỉ có một thể hiện của lớp Struts Action được tạo bởi framework Struts và được sử dụng trong môi trường đa luồng, mô hình này bị khuyến cáo tránh và rất có thể gặp phải vấn đề. Hãy xem xét chỉ sử dụng các biến cục bộ trong phương thức. Chỉ các trường thể hiện được ghi ngoài một monitor mới được báo cáo.",
      "mtia_suspect_servlet_instance_field": "MTIA: Lớp mở rộng từ lớp Servlet và sử dụng biến thể hiện\nLớp này mở rộng từ lớp Servlet và sử dụng biến thành viên thể hiện. Vì chỉ có một thể hiện của lớp Servlet được tạo bởi framework J2EE và được sử dụng trong môi trường đa luồng, mô hình này bị khuyến cáo tránh và rất có thể gặp phải vấn đề. Hãy xem xét chỉ sử dụng các biến cục bộ trong phương thức.",
      "ps_public_semaphores": "PS: Lớp công khai đồng bộ hóa và semaphore trong giao diện công khai của nó\nLớp này sử dụng đồng bộ hóa cùng với wait(), notify() hoặc notifyAll() trên chính nó (tham chiếu this). Các lớp khách sử dụng lớp này có thể, ngoài ra, sử dụng một thể hiện của lớp này như một đối tượng đồng bộ hóa. Vì hai lớp sử dụng cùng một đối tượng để đồng bộ hóa, tính chính xác trong môi trường đa luồng có thể bị nghi ngờ. Bạn không nên đồng bộ hóa hay gọi các phương thức semaphore trên tham chiếu công khai. Hãy xem xét sử dụng một biến thành viên riêng tư nội bộ để kiểm soát việc đồng bộ hóa.",
      "icast_integer_multiply_cast_to_long": "ICAST: Kết quả nhân số nguyên được ép kiểu sang long\nMã này thực hiện phép nhân số nguyên và sau đó chuyển kết quả sang kiểu long, như sau:\n\nlong convertDaysToMilliseconds(int days) { return 1000360024days; }\nNếu phép nhân được thực hiện bằng phép toán với kiểu long, bạn có thể tránh khả năng kết quả bị tràn. Ví dụ, bạn có thể sửa mã trên thành:\n\nlong convertDaysToMilliseconds(int days) { return 1000L360024days; }\nhoặc\n\nstatic final long MILLISECONDS_PER_DAY = 24L36001000;\nlong convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }\nXem CWE-192: Lỗi ép kiểu số nguyên.",
      "icast_idiv_cast_to_double": "ICAST: Kết quả phép chia số nguyên được ép kiểu sang double hoặc float\nMã này ép kiểu kết quả của phép chia số nguyên (ví dụ: phép chia int hoặc long) sang kiểu double hoặc float. Việc chia số nguyên làm tròn kết quả về giá trị nguyên gần nhất với số 0. Việc kết quả được ép kiểu sang double cho thấy độ chính xác này nên được giữ lại. Có lẽ ý định là ép kiểu một hoặc cả hai toán hạng sang double trước khi thực hiện phép chia. Đây là ví dụ:\n\nint x = 2;\nint y = 5;\n// Sai: kết quả là 0.0\ndouble value1 = x / y;\n\n// Đúng: kết quả là 0.4\ndouble value2 = x / (double) y;\nXem CWE-192: Lỗi ép kiểu số nguyên.",
      "bc_bad_cast_to_concrete_collection": "BC: Ép kiểu đáng ngờ sang bộ sưu tập cụ thể\nMã này ép kiểu một bộ sưu tập trừu tượng (chẳng hạn như Collection, List hoặc Set) sang một cài đặt cụ thể (chẳng hạn như ArrayList hoặc HashSet). Điều này có thể không chính xác và làm mã của bạn trở nên dễ bị lỗi, vì nó khiến việc chuyển sang các cài đặt cụ thể khác trong tương lai trở nên khó khăn hơn. Trừ khi bạn có lý do đặc biệt để làm như vậy, chỉ cần sử dụng lớp bộ sưu tập trừu tượng.",
      "bc_unconfirmed_cast": "BC: Ép kiểu không kiểm tra/xác nhận\nPhép ép kiểu này không được kiểm tra, và không phải tất cả các thể hiện của kiểu bị ép kiểu có thể được chuyển sang kiểu mà nó đang bị ép kiểu. Kiểm tra logic chương trình của bạn để đảm bảo phép ép kiểu này không thất bại.",
      "bc_unconfirmed_cast_of_return_value": "BC: Ép kiểu không kiểm tra/xác nhận giá trị trả về từ phương thức\nMã này thực hiện phép ép kiểu không kiểm tra giá trị trả về của một phương thức. Mã có thể gọi phương thức theo cách mà phép ép kiểu này được đảm bảo là an toàn, nhưng SpotBugs không thể xác minh liệu phép ép kiểu này có an toàn hay không. Kiểm tra logic chương trình của bạn để đảm bảo phép ép kiểu này không thất bại.",
      "bc_vacuous_instanceof": "BC: instanceof luôn luôn trả về true\nKiểm tra instanceof này sẽ luôn luôn trả về true (trừ khi giá trị được kiểm tra là null). Mặc dù điều này là an toàn, nhưng hãy chắc chắn rằng đây không phải là dấu hiệu của sự hiểu nhầm hoặc lỗi logic nào đó. Nếu bạn thực sự muốn kiểm tra giá trị là null, có lẽ cách rõ ràng hơn là thực hiện kiểm tra null thay vì kiểm tra instanceof.\n\nXem CWE-571: Biểu thức luôn luôn đúng.",
      "bc_bad_cast_to_abstract_collection": "BC: Ép kiểu đáng ngờ sang bộ sưu tập trừu tượng\nMã này ép kiểu một Collection sang một bộ sưu tập trừu tượng (chẳng hạn như List, Set, hoặc Map). Đảm bảo rằng bạn được đảm bảo rằng đối tượng là kiểu mà bạn đang ép kiểu sang. Nếu bạn chỉ cần có thể lặp qua một bộ sưu tập, bạn không cần ép kiểu nó sang Set hoặc List.\n\nXem CWE-704: Lỗi chuyển kiểu hoặc ép kiểu không đúng.",
      "im_bad_check_for_odd": "IM: Kiểm tra tính lẻ không hoạt động với số âm\nMã này sử dụng x % 2 == 1 để kiểm tra xem một giá trị có phải là số lẻ không, nhưng điều này sẽ không hoạt động với số âm (ví dụ: (-5) % 2 == -1). Nếu mã này nhằm kiểm tra tính lẻ, hãy xem xét sử dụng (x & 1) == 1, hoặc x % 2 != 0.",
      "im_average_computation_could_overflow": "IM: Tính toán trung bình có thể gây tràn số\nMã này tính toán giá trị trung bình của hai số nguyên bằng cách chia hoặc dịch phải có dấu, rồi sử dụng kết quả làm chỉ số của một mảng. Nếu các giá trị cần tính trung bình rất lớn, điều này có thể gây tràn số (dẫn đến tính toán trung bình âm). Nếu kết quả dự kiến phải là không âm, bạn có thể sử dụng dịch phải không dấu thay vào đó. Nói cách khác, thay vì sử dụng (low+high)/2, hãy sử dụng (low+high) >>> 1\n\nLỗi này tồn tại trong nhiều triển khai trước đây của thuật toán tìm kiếm nhị phân và sắp xếp trộn. Martin Buchholz đã phát hiện và sửa lỗi này trong các thư viện JDK, và Joshua Bloch đã công khai rộng rãi mẫu lỗi này.",
      "icast_questionable_unsigned_right_shift": "BSHIFT: Dịch phải không dấu và ép kiểu sang short/byte\nMã này thực hiện dịch phải không dấu, sau đó ép kết quả sang kiểu short hoặc byte, điều này làm mất các bit cao của kết quả. Vì các bit cao bị loại bỏ, có thể không có sự khác biệt giữa dịch phải có dấu và không dấu (tùy thuộc vào kích thước của phép dịch).\n\nXem CWE-192: Lỗi ép kiểu số nguyên.",
      "dmi_hardcoded_absolute_filename": "DMI: Mã chứa tham chiếu cứng đến đường dẫn tuyệt đối\nMã này tạo ra một đối tượng File bằng cách sử dụng tham chiếu cứng đến một đường dẫn tuyệt đối (ví dụ: new File('/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment');",
      "dmi_useless_substring": "DMI: Gọi substring(0), trả về giá trị gốc\nMã này gọi substring(0) trên một String, và trả về giá trị gốc.",
      "st_write_to_static_from_instance_method": "ST: Ghi vào trường tĩnh từ phương thức thể hiện\nPhương thức thể hiện này ghi vào một trường tĩnh. Điều này rất khó chính xác nếu nhiều thể hiện đang được thao tác, và thường là một thói quen xấu.",
      "dmi_nonserializable_object_written": "DMI: Đối tượng không thể tuần tự hóa được ghi vào ObjectOutput\nMã này có vẻ như đang chuyển một đối tượng không thể tuần tự hóa vào phương thức ObjectOutput.writeObject. Nếu đối tượng thực sự không thể tuần tự hóa, sẽ có lỗi xảy ra.",
      "db_duplicate_branches": "DB: Phương thức sử dụng mã giống nhau cho hai nhánh\nPhương thức này sử dụng mã giống nhau để thực hiện hai nhánh của một cấu trúc điều kiện. Kiểm tra để đảm bảo rằng đây không phải là một lỗi mã.\n\nXem CWE-1041: Sử dụng mã thừa.",
      "db_duplicate_switch_clauses": "DB: Phương thức sử dụng mã giống nhau cho hai nhánh switch\nPhương thức này sử dụng mã giống nhau để thực hiện hai nhánh của câu lệnh switch. Điều này có thể là mã trùng lặp, nhưng cũng có thể là lỗi mã.\n\nXem CWE-1041: Sử dụng mã thừa.",
      "xfb_xml_factory_bypass": "XFB: Phương thức trực tiếp cấp phát một cài đặt cụ thể của các giao diện XML\nPhương thức này cấp phát một cài đặt cụ thể của giao diện XML. Tốt hơn là sử dụng các lớp factory được cung cấp để tạo ra các đối tượng này để có thể thay đổi cài đặt trong thời gian chạy. Xem\n\njavax.xml.parsers.DocumentBuilderFactory\njavax.xml.parsers.SAXParserFactory\njavax.xml.transform.TransformerFactory\norg.w3c.dom.Document.createXXXX\nđể biết thêm chi tiết.",
      "usm_useless_subclass_method": "USM: Phương thức phân quyền không cần thiết tới phương thức lớp cha\nPhương thức kế thừa này chỉ gọi phương thức lớp cha với các tham số nhận được. Phương thức này có thể bị loại bỏ vì nó không cung cấp giá trị thêm.",
      "usm_useless_abstract_method": "USM: Phương thức trừu tượng đã được định nghĩa trong giao diện đã triển khai\nPhương thức trừu tượng này đã được định nghĩa trong một giao diện mà lớp trừu tượng này triển khai. Phương thức này có thể bị loại bỏ vì nó không cung cấp giá trị thêm.",
      "ci_confused_inheritance": "CI: Lớp là final nhưng khai báo trường protected\nLớp này được khai báo là final, nhưng khai báo các trường là protected. Vì lớp là final, nó không thể bị kế thừa, và việc sử dụng protected gây nhầm lẫn. Bộ truy cập cho trường này nên được thay đổi thành private hoặc public để thể hiện đúng mục đích sử dụng của trường.",
      "tq_explicit_unknown_source_value_reaches_never_sink": "TQ: Giá trị yêu cầu không có qualifier kiểu, nhưng được đánh dấu là không xác định\nMột giá trị được sử dụng theo cách yêu cầu nó không bao giờ là giá trị được chỉ định bởi một qualifier kiểu, nhưng có một chú thích rõ ràng cho biết rằng không biết giá trị này bị cấm có qualifier kiểu đó. Hoặc cách sử dụng, hoặc chú thích là không chính xác.",
      "tq_explicit_unknown_source_value_reaches_always_sink": "TQ: Giá trị yêu cầu có qualifier kiểu, nhưng được đánh dấu là không xác định\nMột giá trị được sử dụng theo cách yêu cầu nó luôn là giá trị được chỉ định bởi một qualifier kiểu, nhưng có một chú thích rõ ràng cho biết rằng không biết giá trị này yêu cầu phải có qualifier kiểu đó. Hoặc cách sử dụng, hoặc chú thích là không chính xác.",
      "np_method_return_relaxing_annotation": "NP: Phương thức làm lỏng chú thích nullness trên giá trị trả về\nMột phương thức luôn phải thực hiện hợp đồng của phương thức mà nó ghi đè. Do đó, nếu một phương thức được chú thích là trả về giá trị @Nonnull, bạn không nên ghi đè phương thức đó trong một lớp con với phương thức được chú thích là trả về giá trị @Nullable hoặc @CheckForNull. Làm như vậy vi phạm hợp đồng rằng phương thức không nên trả về null.",
      "np_method_parameter_tightens_annotation": "NP: Phương thức làm chặt chẽ chú thích nullness trên tham số\nMột phương thức luôn phải thực hiện hợp đồng của phương thức mà nó ghi đè. Do đó, nếu một phương thức nhận một tham số được đánh dấu là @Nullable, bạn không nên ghi đè phương thức đó trong một lớp con với phương thức mà tham số đó là @Nonnull. Làm như vậy vi phạm hợp đồng rằng phương thức nên xử lý tham số null.",
      "us_useless_suppression_on_field": "US: Loại bỏ sự đàn áp vô ích trên một trường\nCác chú thích đàn áp &SuppressFBWarnings nên được loại bỏ khỏi mã nguồn ngay khi không còn cần thiết. Việc để lại chúng có thể dẫn đến việc đàn áp cảnh báo một cách vô tình. Chú thích này có thể đã được thêm vào để đàn áp một cảnh báo được đưa ra bởi SpotBugs, nhưng giờ đây SpotBugs không còn báo cáo lỗi nữa. Hoặc là lỗi đã được giải quyết hoặc SpotBugs đã được cập nhật, và lỗi không còn được báo cáo bởi mã đó.",
      "us_useless_suppression_on_class": "US: Loại bỏ sự đàn áp vô ích trên một lớp\nCác chú thích đàn áp &SuppressFBWarnings nên được loại bỏ khỏi mã nguồn ngay khi không còn cần thiết. Việc để lại chúng có thể dẫn đến việc đàn áp cảnh báo một cách vô tình.",
      "us_useless_suppression_on_method": "US: Loại bỏ sự đàn áp vô ích trên một phương thức\nCác chú thích đàn áp &SuppressFBWarnings nên được loại bỏ khỏi mã nguồn ngay khi không còn cần thiết. Việc để lại chúng có thể dẫn đến việc đàn áp cảnh báo một cách vô tình. Chú thích này có thể đã được thêm vào để đàn áp một cảnh báo được đưa ra bởi SpotBugs, nhưng giờ đây SpotBugs không còn báo cáo lỗi nữa. Hoặc là lỗi đã được giải quyết hoặc SpotBugs đã được cập nhật, và lỗi không còn được báo cáo bởi mã đó.",
      "us_useless_suppression_on_method_parameter": "US: Loại bỏ sự đàn áp vô ích trên tham số phương thức\nCác chú thích đàn áp &SuppressFBWarnings nên được loại bỏ khỏi mã nguồn ngay khi không còn cần thiết. Việc để lại chúng có thể dẫn đến việc đàn áp cảnh báo một cách vô tình. Chú thích này có thể đã được thêm vào để đàn áp một cảnh báo được đưa ra bởi SpotBugs, nhưng giờ đây SpotBugs không còn báo cáo lỗi nữa. Hoặc là lỗi đã được giải quyết hoặc SpotBugs đã được cập nhật, và lỗi không còn được báo cáo bởi mã đó.",
      "us_useless_suppression_on_package": "US: Loại bỏ sự đàn áp vô ích trên một package\nCác chú thích đàn áp &SuppressFBWarnings nên được loại bỏ khỏi mã nguồn ngay khi không còn cần thiết. Việc để lại chúng có thể dẫn đến việc đàn áp cảnh báo một cách vô tình. Chú thích này có thể đã được thêm vào để đàn áp một cảnh báo được đưa ra bởi SpotBugs, nhưng giờ đây SpotBugs không còn báo cáo lỗi nữa. Hoặc là lỗi đã được giải quyết hoặc SpotBugs đã được cập nhật, và lỗi không còn được báo cáo bởi mã đó."
    }
  }
}
